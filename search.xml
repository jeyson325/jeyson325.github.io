<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>前言：我平淡生活的最后目击者</title>
    <url>/2020/%E5%89%8D%E8%A8%80%EF%BC%9A%E6%88%91%E5%B9%B3%E6%B7%A1%E7%94%9F%E6%B4%BB%E7%9A%84%E6%9C%80%E5%90%8E%E7%9B%AE%E5%87%BB%E8%80%85.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmcx3mbrsfj31og0qcnpe.jpg" alt="image-20210105165036090"></p>
<p>今年的大部分时间里，我一个人住在距离上班的地方仅10分钟路程的公寓里，每天会经过两个红绿灯，在第二个路口处拐弯，可以看到一排枫树，用脚步数过去，大约300多步就会到达公司楼下，然后掏出钉钉打卡。</p>
<p>所以我几乎不会迟到，因为实在太近了，以至于我可以精确的将打卡时间卡在8点59分这个节点上而游刃有余，堪称卡点狂魔。</p>
<p>生活作息也因此变得极其规律，晚上基本12点左右睡觉，早上可以睡到自然醒，然后煮点东西去洗漱，吃完早饭后带上一杯枸杞，慢悠悠的步行到公司。</p>
<p>工作任务并不算繁重，随着技术的沉淀和积累，我在处理项目问题时越来越得心应手。工作时常常会屏蔽所有消息，戴上耳机，陷入到专注开发的快乐中而无法自拔。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmcwlkt68ej315y0s2npe.jpg" alt="image-20210105163315081"></p>
<p>每天基本上就是朝九晚六，没啥娱乐活动，也懒得花费时间去社交，于是造成了一种愈发想远离人群的孤独感。</p>
<p>由于住得近，我下班后吃完晚饭通常不到8点，之后我有将近4个小时的时间可以自由安排，我可以在这段时间里选择看书、写东西、练琴、健身、敲代码、看综艺和洗澡。</p>
<p>有时候也会熬夜，比如看喜欢的节目、沉迷于代码等等，那第二天基本会被8点半的闹钟吵醒，然后赶紧起来洗漱，并顶着乱糟糟的头发一路狂奔，顺带着枸杞杯中的水一路跑一路撒。</p>
<p>每天过得就如云朵一般轻柔、平淡，像一阵风拂过。</p>
<p>风来来去去，日子也就这样过去了。</p>
<p>最近两年里，我的性格潜移默化的改变了很多。也是在这两年里，我才真心觉得自己是个大人了，从心底认可自己已不再年轻。</p>
<p>从小到大，好像都在习惯被别人照顾、被年长的照顾，当我开始想照顾别人的时候，就感觉有一种力量突然间觉醒了。</p>
<p>我开始走着无数前人走过的路，去关注柴米油盐，想拼命攒钱 ，也不再轻易就谈出发，而是理解人情世故，三思而行。</p>
<p>有些道理就在忽如一夜春风来中开了花，像是从身体血液里长出来一样鲜红。</p>
<p>去年有一段时间像着魔了一样疯狂的抢时间学习，上厕所的时候学，睡醒的时候学，走路的时候学，一直持续数月，直到有一天晚上学到头昏脑胀，恶心想吐，闭着眼躺在床上陷入长久的黑暗。</p>
<p>我那时想，与时间赛跑的夸父是不是就是这样倒下的？自嘲之后，还是爬起来继续学。</p>
<p>过程倒是谈不上辛苦，自己和自己做斗争罢了。</p>
<p>我在25岁之前都茫然不知所谓，看不到前路何在，空洞的想法多，欲望多，而脚踏实地的行动少，才能也不足，说是喜欢读书，实际并不怎么读书，性子无趣又乏味，每天就陷在无意义的琐碎小事上，如井底之蛙，安于一隅。</p>
<p>醒悟过来后，大好青春已消耗殆尽，时间一去不复返。无论后来怎样弥补，总有些遗憾是无法挽回的。</p>
<p>所以我有时候会想，如果以前换一种选择，是不是结果会不一样？</p>
<p>我尝试推演了一些结局，但最终发现，只要消除现在的记忆，无论在青春时做出哪一种选择，大概率都将殊途同归。</p>
<p>思想不变，视野不变，环境不变，何以能改变命运？</p>
<p>有些悲欢离合注定是无法避免的，我只能用付出青春的代价去试错，去一点点改变自己。</p>
<p>这两年我开始专注于对自身的投资，去学新的技术、学游泳、练琴、养花，我享受到其中源源不断的乐趣，也借此躲避现实的繁碎嘈杂，渐渐的找到了一种平衡内心的全新生活方式。</p>
<p>我开始认识到所谓的工作、金钱、虚荣……它们都只是过程而已，都是生活的一部分，最终都将成为我了解自己、认识自己、构造自己从而追寻自我安宁的养分。</p>
<p>现在我还是无法改变很多事情，但我可以选择在未来想要成为什么样的人，我清楚自己的天赋和软弱，我知道要如何一步步走到那里，我喜欢为改变所做的一切。</p>
<p>我决定着手搭建博客了。</p>
<p>我想把这几年积累的一些编程问题和笔记整理汇总一下，修建自己思维的小花园，沉淀技术。此外还准备加入日常生活的点滴成长，记录一些喜爱的小东西。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmd1jhomdjj317a0rwq7y.jpg" alt="image-20210105192415967"></p>
<p>总的来说，文字、技术、柴米油盐、冬天爱吃的橘子和夏天常吃的西瓜，这些东西大致组成了我生活的核心要素。我想把它们记录下来，在以后的某个时刻，通过这些痕迹，就可以一脚踏进时间的长河，沿河而上，追溯到此时的心情，找到隐藏在记忆桥底下真正生活状态的滚滚洪流。</p>
<p>子曰，朝闻道，夕死可矣。</p>
<p>既然有幸看到这个广阔世界的漫天星光，就想要去试试看。有些事还是想要做的，有些遗憾还是想弥补的。</p>
<p>而且，记录时我会思考，思考让我活着，这就是我的意义。</p>
<p>我是我平淡生活最后的目击者。</p>]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>用Yeoman搭建我自己的项目脚手架</title>
    <url>/2021/%E7%94%A8Yeoman%E6%90%AD%E5%BB%BA%E6%88%91%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B9%E7%9B%AE%E8%84%9A%E6%89%8B%E6%9E%B6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><p>新建一个项目，通常需要进行各种配置，比如webpack配置、eslint配置、各种通用库的安装和配置等等，如果每次新建都要重新搞一遍会比较麻烦，因此搭建一个自己常用的项目脚手架便很有必要。</p>
<p>就像vue-cli一样，一个<code>vue create my_project</code>命令就可以生成项目结构，并内置了webpack等相关基础配置，开箱即用，美滋滋。</p>
<p>下面介绍我如何使用<a href="https://yeoman.io/">Yeoman</a>工具来搭建自己的项目脚手架。</p>
<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g yo</span><br><span class="line">npm install -g generator-generator</span><br></pre></td></tr></table></figure>

<p>全局安装<code>yo</code>，使用<code>yo</code>命令来执行脚手架<code>yo &lt;name&gt;</code>，脚手架项目的名称是generator-打头，用<code>yo</code>执行的时候不带generator-打头。如<code>generator-jeyson</code>脚手架项目，执行就是<code>yo jeyson</code></p>
<p>全局安装创建脚手架生成项目<code>generator-generator</code>，通过<code>yo generator</code>可生成构建脚手架的项目。</p>
<h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><p><strong>1、使用<code>yo</code>命令执行generator脚手架，生成构建脚手架的项目</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yo generator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 弹出配置问题</span></span><br><span class="line"><span class="comment"># Your generator name (generator-my-projects) 脚手架名称，如：generator-jeyson-koa</span></span><br><span class="line"><span class="comment"># Description 描述，如：this is a jeyson&#x27;s koa project</span></span><br><span class="line"><span class="comment"># Project homepage url 项目地址，如项目的github地址，没有可以留空</span></span><br><span class="line"><span class="comment"># Author&#x27;s Name 作者名，jeyson</span></span><br><span class="line"><span class="comment"># Author&#x27;s Email 作者邮箱，123@163.com</span></span><br><span class="line"><span class="comment"># Author&#x27;s Homepage 作者首页，ljclucky.com</span></span><br><span class="line"><span class="comment"># Package keywords (comma to split) 包关键字，逗号分隔 koa,webpack,mongoose,redis</span></span><br><span class="line"><span class="comment"># Send coverage reports to coveralls 是否发送报告 Y</span></span><br><span class="line"><span class="comment"># Enter Node versions (comma separated) node版本 12.14</span></span><br><span class="line"><span class="comment"># GitHub username or organization</span></span><br><span class="line"><span class="comment"># Which license do you want to use?  协议，MIT</span></span><br></pre></td></tr></table></figure>

<p>配置完成后在当前目录下生成项目结构：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnvd3nvx9aj30ha0mkq51.jpg" alt="image-20210221190538073"></p>
<p>其中最核心的就是<code>generators</code>文件夹。</p>
<ul>
<li><p><code>generators/app/templates</code> 里面用于存放我的项目模板文件。</p>
</li>
<li><p><code>generators/app/index.js</code> 脚手架项目的入口文件，里面会触发一些生命周期：</p>
<ol>
<li><code>initializing</code> - 初始化方法（检查当前项目状态、获取配置等）</li>
<li><code>prompting</code> - 提示用户输入选项的地方</li>
<li><code>configuring</code> - 保存配置（创建.editorconfig文件和其他元数据文件）</li>
<li><code>default</code> - 如果方法名称与优先级不匹配，则会将其推送到该组</li>
<li><code>writing</code> - 执行文件写操作，即项目文件写入文件系统中</li>
<li><code>conflicts</code> - 处理冲突的地方（内部使用）</li>
<li><code>install</code> - 运行安装的位置（npm、bower）</li>
<li><code>end</code> - 最后执行，可清除临时文件</li>
</ol>
</li>
</ul>
<p><strong>2、将自己的项目复制到模板文件下</strong></p>
<p>将<code>generators/app/templates</code>目录下的dummyfile.text文件删除。</p>
<p>然后把自己的项目中除了dist、node_modules文件夹外所有工程文件复制到<code>generators/app/templates</code>目录下，如我的koa项目：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnve4nex2wj30kc0o276b.jpg" alt="image-20210221194114239"></p>
<p><strong>3、配置generator入口文件</strong></p>
<p>具体可查看文档<a href="https://yeoman.io/authoring/">generator</a>部分，<a href="https://yeoman.github.io/generator/">完整api</a></p>
<p>在文件修改配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> Generator = <span class="built_in">require</span>(<span class="string">&#x27;yeoman-generator&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">&#x27;chalk&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> yosay = <span class="built_in">require</span>(<span class="string">&#x27;yosay&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Generator</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 用脚手架生成自己的项目的时候提示信息</span></span><br><span class="line">  <span class="function"><span class="title">prompting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.log(</span><br><span class="line">      yosay(<span class="string">`Welcome to the kryptonian <span class="subst">$&#123;chalk.red(<span class="string">&#x27;generator-jeyson-koa&#x27;</span>)&#125;</span> generator!`</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> prompts = [</span><br><span class="line">      &#123;</span><br><span class="line">        type: <span class="string">&#x27;confirm&#x27;</span>, <span class="comment">// 确认类型，[Y/n]</span></span><br><span class="line">        name: <span class="string">&#x27;someAnswer&#x27;</span>, <span class="comment">// 提示名称</span></span><br><span class="line">        message: <span class="string">&#x27;Would you like to enable this option?&#x27;</span>, <span class="comment">// 提示文字</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="literal">true</span> <span class="comment">// 默认值</span></span><br><span class="line">      &#125;,</span><br><span class="line">   <span class="comment">// &#123;</span></span><br><span class="line">     <span class="comment">// type: &#x27;input&#x27;, // 输入类型</span></span><br><span class="line">     <span class="comment">// name: &#x27;author&#x27;,</span></span><br><span class="line">     <span class="comment">// message: &#x27;请输入项目作者?&#x27;,</span></span><br><span class="line">     <span class="comment">// default: &#x27;&#x27;</span></span><br><span class="line">   <span class="comment">// &#125;</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.prompt(prompts).then(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.props = props;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">writing</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.fs.copy(</span><br><span class="line">      <span class="comment">// this.templatePath(&#x27;dummyfile.txt&#x27;),</span></span><br><span class="line">      <span class="comment">// this.destinationPath(&#x27;dummyfile.txt&#x27;)</span></span><br><span class="line">      <span class="comment">// 将上面的修改成下面这样，意思是在执行脚手架生成的时候</span></span><br><span class="line">      <span class="comment">// 将templates模版下的所有文件复制到当前路径下</span></span><br><span class="line">      <span class="comment">// 具体可查看文档 https://yeoman.github.io/generator/actions_fs.html#.copyTemplate</span></span><br><span class="line">      <span class="built_in">this</span>.templatePath(<span class="string">&#x27;**&#x27;</span>),</span><br><span class="line">      <span class="built_in">this</span>.destinationPath(<span class="string">&#x27;./&#x27;</span>),</span><br><span class="line">      &#123;</span><br><span class="line">        globOptions: &#123;</span><br><span class="line">          dot: <span class="literal">true</span>, <span class="comment">// 意为匹配带.的文件</span></span><br><span class="line">          nodir: <span class="literal">true</span> <span class="comment">// 注：该选项意为不匹配空目录，强制为true，可以不写</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">install</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// npm安装所有依赖</span></span><br><span class="line">    <span class="built_in">this</span>.npmInstall();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="三、发布"><a href="#三、发布" class="headerlink" title="三、发布"></a>三、发布</h2><p>上述都配置完成后，即可进行发布了。</p>
<p><strong>1、正式发布之前，先在本地进行测试</strong></p>
<p>确认我们的命令行处在当前的脚手架项目目录下，然后输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm link</span><br><span class="line"><span class="comment"># 如果要解除 用 npm unlink</span></span><br></pre></td></tr></table></figure>

<p>该命令可以把我们当前所在的脚手架项目链接到全局node_modules中，然后我们新建一个文件夹demo，进入该目录，输入下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yo jeyson-koa</span><br><span class="line"><span class="comment"># yo your-project 即上面设置的脚手架名称，不带前面的generator-</span></span><br></pre></td></tr></table></figure>

<p>执行该命令，它会从全局的node_modules中找到之前链接的脚手架项目，然后在当前demo路径下，执行该项目，即可生成你的项目。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnvj4tvgyfj311y0k4jxj.jpg" alt="image-20210221223423282"></p>
<p>运行项目，测试是否正常运行。</p>
<p><strong>2、将项目脚手架发布到npm仓库中</strong></p>
<p>本地测试完成之后，就可以发布到npm线上仓库中了。</p>
<p>首先要注册有npm账号，然后在命令行中登陆：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm login</span><br></pre></td></tr></table></figure>

<p>然后进入到脚手架项目中，使用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm publish</span><br></pre></td></tr></table></figure>

<p><strong>注：在发布之前，需要确认脚手架项目<code>package.json</code>中的<code>version</code>要给个<code>1.0.0</code>以上的版本。</strong></p>
<p>发布成功后，即可在npm官网上搜索到这个包，这样在任何地方都能下载和使用该脚手架了，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全局安装脚手架项目</span></span><br><span class="line">npm install -g generator-jeyson-koa</span><br><span class="line"><span class="comment"># 通过yo命令运行脚手架</span></span><br><span class="line">yo jeyson-koa</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Yeoman</tag>
      </tags>
  </entry>
  <entry>
    <title>axios取消重复请求不会阻止请求到服务器</title>
    <url>/2021/axios%E5%8F%96%E6%B6%88%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82%E4%B8%8D%E4%BC%9A%E9%98%BB%E6%AD%A2%E8%AF%B7%E6%B1%82%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><p>axios取消重复请求<code>CancelToken</code>可以让<strong>同一个请求遭到用户多次触发时，只返回最近的一次请求结果，而取消之前的请求</strong>。</p>
<p>在业务生产过程中，这个优化可以增强用户体验，减少不必要的数据接收和页面渲染。</p>
<a id="more"></a>

<p>使用它很简单，我们只要对axios进行一层封装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装axios请求</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">&#x27;@/config&#x27;</span></span><br><span class="line"><span class="keyword">import</span> errorHandle <span class="keyword">from</span> <span class="string">&#x27;./errorHandle&#x27;</span></span><br><span class="line"><span class="keyword">const</span> CancelToken = axios.CancelToken</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpRequest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">baseURL</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.baseURL = baseURL</span><br><span class="line">    <span class="built_in">this</span>.pending = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取预设的配置</span></span><br><span class="line">  <span class="function"><span class="title">getInsideConfig</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      baseURL: <span class="built_in">this</span>.baseURL,</span><br><span class="line">      headers: &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span> &#125;,</span><br><span class="line">      timeout: <span class="number">10000</span>,</span><br><span class="line">      withCredentials: <span class="literal">false</span> <span class="comment">// 跨域时是否使用凭证，默认false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取请求url、method、params、data等组成key，标识这次请求</span></span><br><span class="line">  <span class="function"><span class="title">getPendingKey</span>(<span class="params">config</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      config.url,</span><br><span class="line">      config.method,</span><br><span class="line">      <span class="built_in">JSON</span>.stringify(config.params),</span><br><span class="line">      <span class="built_in">JSON</span>.stringify(config.data)</span><br><span class="line">    ].join(<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除请求pending</span></span><br><span class="line">  <span class="function"><span class="title">removePending</span>(<span class="params">key, isRequest = <span class="literal">false</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.pending[key] &amp;&amp; isRequest) &#123;</span><br><span class="line">      <span class="built_in">this</span>.pending[key](<span class="string">&#x27;取消重复请求&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.pending[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 拦截处理</span></span><br><span class="line">  <span class="function"><span class="title">interceptors</span>(<span class="params">instance</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加请求拦截器</span></span><br><span class="line">    instance.interceptors.request.use(</span><br><span class="line">      config =&gt; &#123;</span><br><span class="line">        <span class="comment">// 1、取请求标识key</span></span><br><span class="line">        <span class="comment">// 2、移除上一次该请求标识（如果有，则调用cancelToken取消上次请求）</span></span><br><span class="line">        <span class="comment">// 3、给这次请求增加cancelToken备用（如果后续有重复请求则调用）</span></span><br><span class="line">        <span class="keyword">const</span> key = <span class="built_in">this</span>.getPendingKey(config)</span><br><span class="line">        <span class="built_in">this</span>.removePending(key, <span class="literal">true</span>)</span><br><span class="line">        config.cancelToken = <span class="keyword">new</span> CancelToken(<span class="function"><span class="params">cancel</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.pending[key] = cancel</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> config</span><br><span class="line">      &#125;,</span><br><span class="line">      error =&gt; &#123;</span><br><span class="line">        <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">        errorHandle(error)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加响应拦截器</span></span><br><span class="line">    instance.interceptors.response.use(</span><br><span class="line">      response =&gt; &#123;</span><br><span class="line">        <span class="comment">// 请求返回结果，移除pending</span></span><br><span class="line">        <span class="keyword">const</span> key = <span class="built_in">this</span>.getPendingKey(response.config)</span><br><span class="line">        <span class="built_in">this</span>.removePending(key)</span><br><span class="line">        <span class="keyword">if</span> (response.status === <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(response.data)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(response)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      error =&gt; &#123;</span><br><span class="line">        <span class="comment">// 对响应错误做些什么</span></span><br><span class="line">        errorHandle(error)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发送请求</span></span><br><span class="line">  <span class="function"><span class="title">request</span>(<span class="params">config</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> instance = axios.create()</span><br><span class="line">    <span class="keyword">const</span> newOptions = <span class="built_in">Object</span>.assign(<span class="built_in">this</span>.getInsideConfig(), config)</span><br><span class="line">    <span class="built_in">this</span>.interceptors(instance)</span><br><span class="line">    <span class="keyword">return</span> instance(newOptions)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 语法糖，get请求</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">url, config</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> options = <span class="built_in">Object</span>.assign(</span><br><span class="line">      &#123;</span><br><span class="line">        url,</span><br><span class="line">        method: <span class="string">&#x27;get&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      config</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.request(options)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 语法糖，post请求</span></span><br><span class="line">  <span class="function"><span class="title">post</span>(<span class="params">url, data, config</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> options = <span class="built_in">Object</span>.assign(</span><br><span class="line">      &#123;</span><br><span class="line">        url,</span><br><span class="line">        data,</span><br><span class="line">        method: <span class="string">&#x27;post&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      config</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.request(options)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 语法糖，put请求</span></span><br><span class="line">  <span class="function"><span class="title">put</span>(<span class="params">url, data, config</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> options = <span class="built_in">Object</span>.assign(</span><br><span class="line">      &#123;</span><br><span class="line">        url,</span><br><span class="line">        data,</span><br><span class="line">        method: <span class="string">&#x27;put&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      config</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.request(options)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 语法糖，delete请求</span></span><br><span class="line">  <span class="function"><span class="title">delete</span>(<span class="params">url, config</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> options = <span class="built_in">Object</span>.assign(</span><br><span class="line">      &#123;</span><br><span class="line">        url,</span><br><span class="line">        method: <span class="string">&#x27;delete&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      config</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.request(options)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HttpRequest.prototype.all = axios.all</span><br><span class="line">HttpRequest.prototype.spread = axios.spread</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> HttpRequest(config.baseURL)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样在我们短时间内多次触发同一个请求时，<strong>在网络较慢，前一个请求还在pendding状态下，axios就可以取消掉前一次的请求</strong>。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfw9fy98gvj30nu09eq74.jpg" alt="image-20200618110121130"></p>
<p>但是该做法会潜藏一个问题，就是<strong>这些被取消的请求，还是会发给后端</strong>。这个问题导致的后果就是，比如我点击按钮插入数据，连续点击5次，虽然重复的被取消了，但是在后端依然接受到这5次请求，并执行了5次插入数据。</p>
<p>我在后端接口中埋了打印点，当被请求时触发：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfw9h3xkj2j30b8066q5a.jpg" alt="image-20200618110231931"></p>
<p>所以以前刚开始理解的<strong>axios通过CancelToken取消重复请求，会把之前的取消掉，请求不会发出去给后端，这是错误的理解</strong>。</p>
<p>只要点击了按钮触发事件，请求就发出去了，尽管可以取消重复请求，只要网络还在连接，后端还是会一一收到所有的请求，该查库的查库，该创建的创建，只是重复请求返回的数据被前端取消了而已，前端只接受最后一次数据，渲染一次页面。</p>
<p>针对该问题，可以有多种优化方式，比如后端可以做控制，对于重复创建等操作进行限制，而在前端可以在按钮点击后显示loading状态等，以限制用户重复点击触发。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack打包koa项目配置解析</title>
    <url>/2021/webpack%E6%89%93%E5%8C%85koa%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><p>以前刚接触webpack的时候，我对它繁琐复杂的配置一个头两个大，后来项目渐渐做的多了，懂得多了，就渐渐熟悉了，而且也深深的理解了它的好处。</p>
<p>不管是做前端项目，还是用node做后端项目，只要和js相关的，都可以用webpack辅助构建，它可以提供es6语法的支持、开发热更新、部署代码压缩、对各种资源文件的处理……等等许多功能。</p>
<p>下面介绍在node框架koa开发的项目中，如何进行webpack配置。</p>
<h2 id="一、新建koa项目"><a href="#一、新建koa项目" class="headerlink" title="一、新建koa项目"></a>一、新建koa项目</h2><p>新建<code>koa-demo</code>文件夹，通过npm初始化项目。然后创建以下目录结构、文件和内容：</p>
<p><strong>项目目录</strong></p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">  koa-demo</span><br><span class="line">  |- package.json</span><br><span class="line"><span class="addition">+ |- /src</span></span><br><span class="line"><span class="addition">+   |- index.js</span></span><br></pre></td></tr></table></figure>

<p><strong>src/index.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先npm安装koa </span></span><br><span class="line"><span class="comment">// 这里引用和初始化</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  ctx.body = <span class="string">&#x27;hello koa&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<p>这样一个简单的koa项目就创建好了。</p>
<br />

<h2 id="二、配置webpack"><a href="#二、配置webpack" class="headerlink" title="二、配置webpack"></a>二、配置webpack</h2><p>接下来就是重点了，配置webpack，我们先安装相关所有需要的依赖，再解释为什么要这样配置：</p>
<p>注：<strong>这里所有配置以webpack4版本为基础</strong>，升级webpack5可去官方查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -D webpack@4 webpack-cli@3</span><br><span class="line"><span class="comment"># 安装webpack4版本</span></span><br><span class="line"><span class="comment"># 安装webpack-cli3版本 此工具用于在命令行中运行 webpack</span></span><br><span class="line"></span><br><span class="line">npm i -D clean-webpack-plugin</span><br><span class="line"><span class="comment"># 常用插件，打包前自动清理之前打包的文件</span></span><br><span class="line"></span><br><span class="line">npm i -D webpack-node-externals</span><br><span class="line"><span class="comment"># 打包时排除node_modules，里面的所有依赖都不打包</span></span><br><span class="line"></span><br><span class="line">npm i -D @babel/core @babel/node @babel/preset-env babel-loader</span><br><span class="line"><span class="comment"># 使用es6语法所需的babel相关依赖</span></span><br><span class="line"><span class="comment"># @babel/node在babel7中被移了出来，如果在node环境中使用，要单独安装，有在运行Babel预设和插件之前进行编译的好处，调试用</span></span><br><span class="line"></span><br><span class="line">npm i -D terser-webpack-plugin@4</span><br><span class="line"><span class="comment"># 生产环境需要打包压缩代码</span></span><br><span class="line"></span><br><span class="line">npm i -D webpack-merge</span><br><span class="line"><span class="comment"># 分开发配置和生产配置，它们有共同配置，抽离出来，通过webpack-merge合并</span></span><br><span class="line"></span><br><span class="line">npm i -D nodemon</span><br><span class="line"><span class="comment"># 监控node.js 源代码的变化和自动重启服务</span></span><br><span class="line"></span><br><span class="line">npm i -D cross-env</span><br><span class="line"><span class="comment"># 运行跨平台设置和使用环境变量的脚本</span></span><br><span class="line"></span><br><span class="line">npm i -D npm-run-all</span><br><span class="line"><span class="comment"># 实现同时执行多个命令</span></span><br><span class="line"></span><br><span class="line">npm i -D rimraf</span><br><span class="line"><span class="comment"># 以包的形式包装rm -rf命令，用来删除文件和文件夹的。用来清理dist目录</span></span><br></pre></td></tr></table></figure>

<p>我们的koa项目分为<strong>开发时环境</strong>和<strong>生产时环境</strong>，不同环境时webpack的配置是有部分不同的，所以要新建两个配置文件<code>webpack.config.dev.js</code> 和 <code>webpack.config.prod.js</code>，同时它们又有共同之处，所以需要一个通用配置文件<code>webpack.config.base.js</code>。</p>
<p>所以在项目根目录下新建config文件夹，把这三个webpack配置文件放进去。</p>
<p><strong>项目目录</strong></p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">  koa-demo</span><br><span class="line"><span class="addition">+ |- config</span></span><br><span class="line"><span class="addition">+ 	|- webpack.config.base.js</span></span><br><span class="line"><span class="addition">+ 	|- webpack.config.dev.js</span></span><br><span class="line"><span class="addition">+ 	|- webpack.config.prod.js</span></span><br><span class="line">  |- package.json</span><br><span class="line">  |- /src</span><br><span class="line">    |- index.js</span><br></pre></td></tr></table></figure>

<p>接下来在通用配置文件<code>webpack.config.base.js</code>中配置：</p>
<p><strong>config/webpack.config.base.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> nodeExternals = <span class="built_in">require</span>(<span class="string">&#x27;webpack-node-externals&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  target: <span class="string">&#x27;node&#x27;</span>, <span class="comment">// koa项目仅在node环境下运行，因此设置称&#x27;node&#x27;</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="comment">// 设置入口文件</span></span><br><span class="line">    server: path.join(__dirname, <span class="string">&#x27;../src/index.js&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 设置打包后的文件和位置</span></span><br><span class="line">    filename: <span class="string">&#x27;[name].bundle.js&#x27;</span>,</span><br><span class="line">    path: path.join(__dirname, <span class="string">&#x27;../dist&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// devtool: &#x27;inline-source-map&#x27;,</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js|jsx$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 尽量将 loader 应用于最少数量的必要模块，因此设置include</span></span><br><span class="line">        <span class="comment">// 只针对该目录下的js文件进行babel处理</span></span><br><span class="line">        include: path.join(__dirname, <span class="string">&#x27;../src&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// modules: 告诉webpack哪些目录需要搜索去匹配解析</span></span><br><span class="line">    modules: [path.join(__dirname, <span class="string">&#x27;../src/index.js&#x27;</span>), <span class="string">&#x27;node_modules&#x27;</span>],</span><br><span class="line">    <span class="comment">// extensions: 告诉webpack这些后缀文件需要去搜索匹配</span></span><br><span class="line">    extensions: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="comment">// 设置别名指向对应目录</span></span><br><span class="line">      <span class="string">&#x27;@&#x27;</span>: path.join(__dirname, <span class="string">&#x27;../src&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  externals: [nodeExternals()], <span class="comment">// 排除对node_modules里的依赖进行打包</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(), <span class="comment">// 打包前清除输出目录</span></span><br><span class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">      <span class="comment">// 定义环境变量，区分开发和生产环境</span></span><br><span class="line">      <span class="comment">// 具体详情可查看DefinePlugin文档</span></span><br><span class="line">      <span class="string">&#x27;process.env.NODE_ENV&#x27;</span>:</span><br><span class="line">        process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span></span><br><span class="line">          ? <span class="built_in">JSON</span>.stringify(<span class="string">&#x27;production&#x27;</span>)</span><br><span class="line">          : <span class="built_in">JSON</span>.stringify(<span class="string">&#x27;development&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// node下这些选项可以使最初为Node.js环境编写的代码，在其他环境（如浏览器）中运行</span></span><br><span class="line">  node: &#123;</span><br><span class="line">    <span class="built_in">console</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="built_in">global</span>: <span class="literal">true</span>,</span><br><span class="line">    process: <span class="literal">true</span>,</span><br><span class="line">    Buffer: <span class="literal">true</span>,</span><br><span class="line">    __filename: <span class="literal">true</span>,</span><br><span class="line">    __dirname: <span class="literal">true</span>,</span><br><span class="line">    setImmediate: <span class="literal">true</span>,</span><br><span class="line">    path: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig</span><br></pre></td></tr></table></figure>

<p><strong>config/webpack.config.dev.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config.base&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过webpack-merge合并基础配置，添加开发时配置</span></span><br><span class="line"><span class="keyword">const</span> webpackConfig = merge(baseConfig, &#123;</span><br><span class="line">  mode: <span class="string">&#x27;development&#x27;</span>, <span class="comment">// 开发模式</span></span><br><span class="line">  devtool: <span class="string">&#x27;eval-source-map&#x27;</span>, <span class="comment">// 开发时出错能知道在源代码中哪一行</span></span><br><span class="line">  stats: &#123;</span><br><span class="line">    children: <span class="literal">false</span>, <span class="comment">// webpack打包时子模块信息设置不显示</span></span><br><span class="line">    modules: <span class="literal">false</span> <span class="comment">// 不显示模块信息</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig</span><br></pre></td></tr></table></figure>

<p><strong>config/webpack.config.prod.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-merge&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> baseConfig = <span class="built_in">require</span>(<span class="string">&#x27;./webpack.config.base&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过webpack-merge合并基础配置，添加生产时配置</span></span><br><span class="line"><span class="keyword">const</span> webpackConfig = merge(baseConfig, &#123;</span><br><span class="line">  mode: <span class="string">&#x27;production&#x27;</span>, <span class="comment">// 生产模式</span></span><br><span class="line">  stats: &#123;</span><br><span class="line">    children: <span class="literal">false</span>, <span class="comment">// webpack打包时子模块信息设置不显示</span></span><br><span class="line">    warnings: <span class="literal">false</span> <span class="comment">// 警告不显示</span></span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      <span class="comment">// terser-webpack-plugin插件可以压缩代码</span></span><br><span class="line">      <span class="comment">// 在webpack4版本中需要安装terser-webpack-plugin4版本</span></span><br><span class="line">      <span class="comment">// 里面是官方推荐的具体的参数，详情可查看文档</span></span><br><span class="line">      <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">        terserOptions: &#123;</span><br><span class="line">          warning: <span class="literal">true</span>,</span><br><span class="line">          compress: &#123;</span><br><span class="line">            warnings: <span class="literal">false</span>,</span><br><span class="line">            drop_console: <span class="literal">false</span>, <span class="comment">// 取消注释console 方便有时候进行调试</span></span><br><span class="line">            dead_code: <span class="literal">true</span>,</span><br><span class="line">            drop_debugger: <span class="literal">true</span></span><br><span class="line">          &#125;,</span><br><span class="line">          output: &#123;</span><br><span class="line">            comments: <span class="literal">false</span>, <span class="comment">// 不要注释</span></span><br><span class="line">            beautify: <span class="literal">false</span> <span class="comment">// 不要格式，一行显示所有代码</span></span><br><span class="line">          &#125;,</span><br><span class="line">          mangle: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        parallel: <span class="literal">true</span>, <span class="comment">// 使用多进程并行运行可提高构建速度，默认的并发运行数量 os.cpus().length - 1</span></span><br><span class="line">        sourceMap: <span class="literal">false</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// splitChunks 用来避免模块之间重复的依赖关系</span></span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        commons: &#123;</span><br><span class="line">          name: <span class="string">&#x27;commons&#x27;</span>,</span><br><span class="line">          chunks: <span class="string">&#x27;initial&#x27;</span>,</span><br><span class="line">          minChunks: <span class="number">3</span>,</span><br><span class="line">          enforce: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig</span><br></pre></td></tr></table></figure>



<h3 id="1、配置babel去支持es6语法"><a href="#1、配置babel去支持es6语法" class="headerlink" title="1、配置babel去支持es6语法"></a>1、配置babel去支持es6语法</h3><p>接着在根目录下新建<code>.babelrc</code>文件，增加babel配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;targets&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;node&quot;</span>: <span class="string">&quot;current&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改写src/index.js中的代码：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">- const Koa = require(&#x27;koa&#x27;)</span></span><br><span class="line"><span class="addition">+ import Koa from &#x27;koa&#x27;</span></span><br><span class="line">const app = new Koa()</span><br><span class="line"></span><br><span class="line">app.use(async ctx =&gt; &#123;</span><br><span class="line">  ctx.body = &#x27;hello koa&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 监听端口</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure>

<p>如果我们用<code>node src/index.js</code>去运行，则会报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">import Koa from &#x27;koa&#x27;</span><br><span class="line">^^^^^^</span><br><span class="line"></span><br><span class="line">SyntaxError: Cannot use import statement outside a module</span><br></pre></td></tr></table></figure>

<p>在在安装babel之后，node_modules中提供了一个<code>babel-node</code>命令，我们可以通过该命令来运行我们的入口文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx babel-node src/index.js</span><br></pre></td></tr></table></figure>

<p>配合之前安装的<code>nodemon</code>可以实现热更新</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx nodemon --<span class="built_in">exec</span> babel-node src/index.js</span><br></pre></td></tr></table></figure>

<p>我们在<code>package.json</code>中添加这个脚本：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;script&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;nodemon --exec babel-node src/index.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样通过在终端里运行<code>npm run start</code>即可启动项目了。</p>
<p>当然这个只是简单的实现去支持es6语法和开发时热更新功能，并没有通过用webpack去构建，在项目简单的情况下尚可。后面将介绍通过webpack去启动。</p>
<h3 id="2、调试webpack配置文件"><a href="#2、调试webpack配置文件" class="headerlink" title="2、调试webpack配置文件"></a>2、调试webpack配置文件</h3><p>运行命令去监听webpack配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx node --inspect-brk ./node_modules/.bin/webpack --config config/webpack.config.prod.js --progress</span><br><span class="line"><span class="comment"># --config 指定要监听的配置文件</span></span><br><span class="line"><span class="comment"># --progress 打印webpack编译的过程</span></span><br></pre></td></tr></table></figure>

<p>可以在chrome浏览器里调试，也可以在编辑器里调试，具体方法见<a href="https://nodejs.org/en/docs/guides/debugging-getting-started/">node调试文档</a>。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnag6rqjrjj31sk0joalj.jpg" alt="image-20210203165556606"></p>
<p>我们在<code>package.json</code>中添加这个脚本用来调试用：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;script&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;nodemon --exec babel-node src/index.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack:debug&quot;</span>: <span class="string">&quot;node --inspect-brk ./node_modules/.bin/webpack --config config/webpack.config.prod.js --progress&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、通过webpack构建开发时环境"><a href="#3、通过webpack构建开发时环境" class="headerlink" title="3、通过webpack构建开发时环境"></a>3、通过webpack构建开发时环境</h3><p>我们已经把开发时环境配置好了，接下来就是启动它，<strong>通过<code>webpack --watch</code>命令来监听项目中文件的变化，如果其中一个文件被更新，代码将被重新编译</strong>，而不必再去手动运行整个构建。</p>
<p>同时我们通过<code>cross-env</code>来设置环境变量，来指定当当前开发环境还是生产环境。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx cross-env NODE_ENV=development webpack --watch --config config/webpack.config.dev.js --progress</span><br></pre></td></tr></table></figure>

<p>执行该命令的意思就是，设置一个环境变量NODE_ENV，值为development，因为我们之前在配置文件中通过DefinePlugin做了配置，所以当这个值不是production时就是开发环境，定义了对应的变量，在项目文件中就可以拿到这个变量，来针对开发和生产时做不同的逻辑处理。</p>
<p>设置了开发时的环境变量后，通过<code>webpack --watch</code>启动监听模式，指定开发时的配置文件<code>config/webpack.config.dev.js</code>文件，当项目中文件发生变化，代码将被重新编译打包输出到<code>dist/server.bundle.js</code>。</p>
<p>但仅仅这样时不够的，文件虽然重新被编译并打包了，但是我们并没有监听这个打包后的文件，因此我们通过<code>nodemon</code>来监听输出后的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx nodemon --inspect ./dist/server.bundle.js</span><br></pre></td></tr></table></figure>

<p>我们这时候将不再简单的监听原始入口文件<code>src/index.js</code>了，而是监听经过了webpack处理（包括babel转换、代码压缩等）打包后生成的文件。</p>
<p>通过运行上面这两个命令就可以帮助我们实现构建开发时环境。我们把该命令配置到<code>package.json</code>脚本中：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;script&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;nodemon --exec babel-node src/index.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack:debug&quot;</span>: <span class="string">&quot;node --inspect-brk ./node_modules/.bin/webpack --config config/webpack.config.prod.js --progress&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;watch&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=development webpack --watch --config config/webpack.config.dev.js --progress&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;debug&quot;</span>: <span class="string">&quot;nodemon --inspect dist/server.bundle.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这是两个命令，一个终端控制台只能监听一个命令，如果每次启动项目都开两个终端比较麻烦，所以我们安装一个工具<code>npm-run-all</code>，来实现一个脚本同时执行多个命令。继续在<code>package.json</code>中添加脚本：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;script&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;nodemon --exec babel-node src/index.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack:debug&quot;</span>: <span class="string">&quot;node --inspect-brk ./node_modules/.bin/webpack --config config/webpack.config.prod.js --progress&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;watch&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=development webpack --watch --config config/webpack.config.dev.js --progress&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;debug&quot;</span>: <span class="string">&quot;nodemon --inspect dist/server.bundle.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;start:dist&quot;</span>: <span class="string">&quot;npm-run-all -p watch debug&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>npm-run-all -p watch debug</code>命令的含义是并行执行watch和debug两个脚本命令<code>-p</code>是并行执行的意思。</p>
<p>配置好后，我们直接在终端运行即可<strong>启动开发时环境</strong>了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run start:dist</span><br></pre></td></tr></table></figure>

<p>然后就可以安心写koa项目代码啦。</p>
<h3 id="4、项目打包，运用到生产环境"><a href="#4、项目打包，运用到生产环境" class="headerlink" title="4、项目打包，运用到生产环境"></a>4、项目打包，运用到生产环境</h3><p>项目写好之后，我们需要打包部署到线上生产环境，这时候再通过<code>npm run start:dist</code>命令就不合适了，因此我们来配置下构建生产环境的打包命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx cross-env NODE_ENV=production webpack --config config/webpack.config.prod.js</span><br></pre></td></tr></table></figure>

<p>和上面构建开发环境的命令很类似，不过此时我们设置环境变量NODE_ENV值为production，并指定配置文件<code>config/webpack.config.prod.js</code>文件去打包构建。</p>
<p>我们把该命令配置到<code>package.json</code>中：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;script&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;nodemon --exec babel-node src/index.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack:debug&quot;</span>: <span class="string">&quot;node --inspect-brk ./node_modules/.bin/webpack --config config/webpack.config.prod.js --progress&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;watch&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=development webpack --watch --config config/webpack.config.dev.js --progress&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;debug&quot;</span>: <span class="string">&quot;nodemon --inspect dist/server.bundle.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;start:dist&quot;</span>: <span class="string">&quot;npm-run-all -p watch debug&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=production webpack --config config/webpack.config.prod.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行该命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>即完成了生产环境下的项目打包构建。</p>
<p>将整个项目目录除了<code>node_modules</code>文件夹，推送到线上服务器，然后运行<code>npm install</code>安装依赖，接着用node命令执行文件<code>node dist/server.bundle.js</code>把项目启动起来，通过服务器地址和暴露的端口既可以访问koa项目接口啦。</p>
<blockquote>
<p>注：清除dist目录配置</p>
<p>使用<code>npm run build</code>文件项目时每次都会生成一个dist目录，有时需要把dist目录全部删掉，除了在命令行使用rm -rf /dist/命令删除外，还可以使用rimraf命令：</p>
<p>安装：<code>npm install -D rimraf</code></p>
<p>使用：<code>npx rimraf dist</code></p>
<p>我们将其配置到<code>package.json</code>中：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config config/webpack.config.prod.js&quot;,</span><br><span class="line"><span class="addition">+   &quot;clean&quot;: &quot;rimraf dist&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后通过运行该命令即可清除dist目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run clean</span><br></pre></td></tr></table></figure>
</blockquote>
<br />

<h2 id="三、配置eslint-prettier风格"><a href="#三、配置eslint-prettier风格" class="headerlink" title="三、配置eslint + prettier风格"></a>三、配置eslint + prettier风格</h2><p>我习惯写项目必配eslint，操作如下：</p>
<h3 id="1、安装eslint"><a href="#1、安装eslint" class="headerlink" title="1、安装eslint"></a>1、安装eslint</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装eslint</span></span><br><span class="line">npm i eslint -D</span><br><span class="line"></span><br><span class="line"><span class="comment"># eslint初始化</span></span><br><span class="line">npx eslint --init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入自定义选择项</span></span><br><span class="line"><span class="comment"># 1. 你想要怎么使用eslint？ To check syntax and find problems</span></span><br><span class="line"><span class="comment"># 2. 哪一种模块是你的项目使用的？ JavaScript modules</span></span><br><span class="line"><span class="comment"># 3. 选择哪一个框架？ None of these</span></span><br><span class="line"><span class="comment"># 4. 你想要使用TypeScript吗？ N</span></span><br><span class="line"><span class="comment"># 5. 你要运行在哪个环境？ Browser, Node</span></span><br><span class="line"><span class="comment"># 6. 你想要配置文件格式是哪个？ JavaScript</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全部选择完成后，会在本地生成.eslintrc.js文件</span></span><br></pre></td></tr></table></figure>

<h3 id="2、安装prettier"><a href="#2、安装prettier" class="headerlink" title="2、安装prettier"></a>2、安装prettier</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装相关配置依赖</span></span><br><span class="line">npm install --save-dev eslint-config-prettier</span><br><span class="line">npm install --save-dev eslint-plugin-prettier</span><br><span class="line">npm install --save-dev --save-exact prettier</span><br></pre></td></tr></table></figure>

<p>然后在<code>.eslintrc.js</code>文件中添加配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  plugins: [<span class="string">&#x27;prettier&#x27;</span>],</span><br><span class="line">  <span class="keyword">extends</span>: [<span class="string">&#x27;eslint:recommended&#x27;</span>, <span class="string">&#x27;prettier&#x27;</span>, <span class="string">&#x27;prettier/prettier&#x27;</span>],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">&#x27;prettier/prettier&#x27;</span>: <span class="string">&#x27;error&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的prettier规则可以新建一个<code>.prettierrc</code>文件设置。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;semi&quot;</span>: <span class="literal">false</span>, <span class="comment">// 结尾是否加分号</span></span><br><span class="line">  <span class="attr">&quot;singleQuote&quot;</span>: <span class="literal">true</span>, <span class="comment">// 是否使用单引号</span></span><br><span class="line">  <span class="attr">&quot;printWidth&quot;</span>: <span class="number">80</span>, <span class="comment">// 一行代码最长显示80的length</span></span><br><span class="line">  <span class="attr">&quot;endOfLine&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;trailingComma&quot;</span>: <span class="string">&quot;none&quot;</span> <span class="comment">// 对象或者数组结尾一项是否逗号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：如果在<code>.eslintrc.js</code>文件里直接设置规则也行，但是这样在后面提交检查执行lint-staged的命令<code>prettier --write</code>时，就无法拿到这个规则，而使用prettier默认的规则。</p>
<p>因此我们需要新建<code>.prettierrc</code>文件去让它们识别。</p>
</blockquote>
<p>另外为了增加验证效率，排除那些不需要验证规则的文件，比如<code>mode_modules</code>，可以新建<code>.eslintignore</code>和<code>.prettierignore</code>文件。</p>
<blockquote>
<p>注：webstorm编辑器默认JavaScript文件最后分号结尾，如果上述prettier规则结尾不要分号，则会有个编辑器默认的warning：unterminated statement颜色，虽然没啥错，但是看着不爽，可以在编辑器里设置去掉warning。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gn9a1y4d6yj31f00oc0yy.jpg" alt="image-20210202163811226"></p>
</blockquote>
<br />

<h2 id="四、提交git前代码检查"><a href="#四、提交git前代码检查" class="headerlink" title="四、提交git前代码检查"></a>四、提交git前代码检查</h2><p>为了增强代码线上质量，可以在git提交到仓库前使用<code>husky</code>和<code>lint-staged</code>进行检查。</p>
<p>它们的功能就是在git提交时触发钩子，其中最重要的一个钩子是<code>pre-commit</code>，在提交代码前可以让我们配置具体做什么，比如运行一下代码检查，如果不符合eslint规则的就中止这次git提交，让你去检查代码问题。</p>
<p>配置它们很简单，先安装这两个工具。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install husky lint-staged --save-dev</span><br></pre></td></tr></table></figure>

<p>然后在<code>package.json</code>中增加配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;husky&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;pre-commit&quot;</span>: <span class="string">&quot;lint-staged&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;lint-staged&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// 匹配所有js文件，按顺序执行任务</span></span><br><span class="line">    <span class="attr">&quot;*.js&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;prettier --write&quot;</span>,</span><br><span class="line">      <span class="string">&quot;eslint&quot;</span>,</span><br><span class="line">      <span class="string">&quot;git add&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>git的hooks可以在.git文件下的hooks目录里去查看它们，我们可以理解为执行git操作过程中的一系列生命周期，就像vue生命周期一样，在提交时触发一个<code>pre-commit</code>钩子，里面可以执行提交前要做的事情。比如可以执行检查代码：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;husky&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;pre-commit&quot;</span>: <span class="string">&quot;prettier --write&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样它就在提交前执行了prettier修复命令。但是这样有一个问题，就是它会检查项目所有的代码，而不是仅仅你这次提交的，所以我们需要<code>lint-staged</code>来解决这个问题，而且<code>lint-staged</code>中可以分任务去执行多个命令。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;husky&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;pre-commit&quot;</span>: <span class="string">&quot;lint-staged&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;lint-staged&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// 匹配提交的所有js文件，按顺序执行任务</span></span><br><span class="line">    <span class="attr">&quot;*.js&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;prettier --write&quot;</span>,</span><br><span class="line">      <span class="string">&quot;eslint&quot;</span>,</span><br><span class="line">      <span class="string">&quot;git add&quot;</span></span><br><span class="line">    ]，</span><br><span class="line">    <span class="comment">// 匹配提交的所有vue文件，按顺序执行任务</span></span><br><span class="line">    <span class="string">&quot;*.vue&quot;</span>: [...]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述检查js文件的任务就是，先通过<code>prettier --write *.js</code>命令修复文件中不符合规则的代码，执行完后再执行<code>eslint *.js</code>命令检查不符合eslint规则的代码，没问题后执行<code>git add *.js</code>将修复的文件（如果有修复更改）重新添加到暂存区，然后再执行提交操作。</p>
<p>这其中有任何一个任务没通过，则本地提交中止，显示报错信息，提醒你规范代码。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnbavn3j68j30va0u00zg.jpg" alt="image-20210204103753077"></p>
<p>通过以上所有基础配置，开发koa项目之前的构建环境已经搭建完成，接下来只需要安心写项目代码即可。</p>
<p>后续可针对这些配置，再加上koa系列相关基础中间件，做成脚手架，以减少重复搭建项目基础环境的成本。</p>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器探索之旅：基础环境搭建</title>
    <url>/2021/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A2%E7%B4%A2%E4%B9%8B%E6%97%85%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><p><a href="/2020/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A2%E7%B4%A2%E4%B9%8B%E6%97%85%EF%BC%9A%E9%80%89%E8%B4%AD%E5%92%8C%E7%99%BB%E9%99%86.html">服务器选购和登陆</a>之后，就要进行基础环境搭建了。</p>
<p>每个人的需求不同，我个人需要安装的环境有<strong>node环境</strong>和<strong>docker环境</strong>。其他的数据库服务、HTTP Server服务等都是基于docker实现的，因此下面主要介绍这些环境的搭建。</p>
<a id="more"></a>

<h2 id="一、node环境安装"><a href="#一、node环境安装" class="headerlink" title="一、node环境安装"></a>一、node环境安装</h2><p>如果要安装node，强烈推荐使用<code>nvm</code>方式去安装。<code>nvm</code>可以控制和切换node版本，特别方便。</p>
<p>根据<code>nvm</code>在github上的<a href="https://github.com/nvm-sh/nvm#install--update-script">文档</a>介绍进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载脚本</span></span><br><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.37.2/install.sh | bash</span><br></pre></td></tr></table></figure>

<p>运行脚本将nvm存储库克隆到~/.nvm，并添加到环境变量中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">&quot;<span class="subst">$([ -z <span class="string">&quot;<span class="variable">$&#123;XDG_CONFIG_HOME-&#125;</span>&quot;</span> ] &amp;&amp; printf %s <span class="string">&quot;<span class="variable">$&#123;HOME&#125;</span>/.nvm&quot;</span> || printf %s <span class="string">&quot;<span class="variable">$&#123;XDG_CONFIG_HOME&#125;</span>/nvm&quot;</span>)</span>&quot;</span></span><br><span class="line">[ -s <span class="string">&quot;<span class="variable">$NVM_DIR</span>/nvm.sh&quot;</span> ] &amp;&amp; \. <span class="string">&quot;<span class="variable">$NVM_DIR</span>/nvm.sh&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>下载脚本拒绝连接解决方法</strong></p>
<p>在下载脚本时出现报错：<code>Failed connect to raw.githubusercontent.com:443; 拒绝连接</code></p>
<p>这是因为墙的原因，要解决这个问题，可以使用科学上网，或者添加hosts来解决</p>
<p>在<a href="https://www.ipaddress.com/">https://www.ipaddress.com/</a> 查询raw.githubusercontent.com的真实IP</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入hosts文件</span></span><br><span class="line">vim /etc/hosts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加</span></span><br><span class="line">199.232.96.133 raw.githubusercontent.com</span><br></pre></td></tr></table></figure>
</blockquote>
<p>安装完成后查看版本确认已正常安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm --version</span><br></pre></td></tr></table></figure>

<blockquote>
<p>nvm常用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看</span></span><br><span class="line">nvm ls-remote <span class="comment"># 列出node有哪些版本</span></span><br><span class="line">nvm list <span class="comment"># 查看已安装的node版本</span></span><br><span class="line">nvm current <span class="comment"># 显示当前版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装和卸载</span></span><br><span class="line">nvm install <span class="comment"># 安装最新版本</span></span><br><span class="line">nvm install 12.20.0 <span class="comment"># 安装指定版本</span></span><br><span class="line">nvm uninstall 12.20.0 <span class="comment"># 卸载指定版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">nvm use 8.0.0 <span class="comment"># 当前切换到指定版本</span></span><br><span class="line">nvm <span class="built_in">alias</span> default 8.1.0 <span class="comment"># 设置默认版本</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>安装node：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm install 12.20.1</span><br></pre></td></tr></table></figure>

<p>完成后检查node版本及是否正常安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node --version</span><br></pre></td></tr></table></figure>

<br />

<h2 id="二、docker环境安装"><a href="#二、docker环境安装" class="headerlink" title="二、docker环境安装"></a>二、docker环境安装</h2><p>docker安装及常用操作在上篇博文<a href="/2021/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB.html">docker常用命令汇总</a>中已经介绍，便不再赘述。</p>
<p>配置好docker环境之后，下面介绍使用docker安装各种服务：</p>
<h3 id="1、mongodb数据库"><a href="#1、mongodb数据库" class="headerlink" title="1、mongodb数据库"></a>1、mongodb数据库</h3><p>在服务器上新建<code>docker-compose.yml</code>文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在home目录下新建mongodb文件文件夹，在里面新建docker-compose.yml文件</span></span><br><span class="line"><span class="built_in">cd</span> /home</span><br><span class="line">mkdir mongodb</span><br><span class="line"><span class="built_in">cd</span> mongodb</span><br><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure>

<p>然后对yml文件进行配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将下面的配置复制到里面</span></span><br><span class="line">version: &#x27;3.8&#x27; # compose版本</span><br><span class="line">services:</span><br><span class="line">  mongo:</span><br><span class="line">    image: mongo # 选择镜像 如指定版本mongo:4.2</span><br><span class="line">    restart: always</span><br><span class="line">    container_name: mongodb # 设置镜像名称</span><br><span class="line">    environment:</span><br><span class="line">      MONGO_INITDB_ROOT_USERNAME: root</span><br><span class="line">      MONGO_INITDB_ROOT_PASSWORD: 123456</span><br><span class="line">    ports:</span><br><span class="line">      - 27017:27017 # 映射端口</span><br><span class="line">    volumes:</span><br><span class="line">      - /home/mongodb:/data/db # 挂载</span><br></pre></td></tr></table></figure>

<p>保存文件后退出，然后挂在后台运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<p>注意：上面映射端口后，需要在防火墙和安全组中放通该端口。</p>
<p>这时候，mongodb数据库服务就启动了，接下来是初始化数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入容器内 运行mongo连接到数据库</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;运行的mongodb容器的id或名称&gt; mongo</span><br><span class="line"><span class="comment"># 进入后到达mongodb的shell终端 然后再通过账号密码连接</span></span><br><span class="line"><span class="comment"># 使用（创建）数据库</span></span><br><span class="line">use admin</span><br><span class="line"><span class="comment"># 用账号密码登录该数据库（认证、权限）</span></span><br><span class="line"><span class="comment"># root用户是超级管理员，可以做任何事情，一般交给运维管理使用</span></span><br><span class="line">db.auth(<span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;567123&#x27;</span>)  <span class="comment"># 输出1则表示成功了</span></span><br><span class="line"><span class="comment"># 显示数据库列表</span></span><br><span class="line">show dbs</span><br><span class="line"></span><br><span class="line">use jeyson_db</span><br><span class="line"><span class="comment"># 创建一个用户（名称、密码、角色权限：对对应的数据库享有dbOwner权限）</span></span><br><span class="line"><span class="comment"># 注：需要有足够的权限才能创建用户，比如root用户，所以如果要创建，先认证root用户</span></span><br><span class="line"><span class="comment"># 然后再use jeyson_db切换到你想要新增用户的数据库下</span></span><br><span class="line">db.createUser(&#123;user: <span class="string">&#x27;mytest&#x27;</span>,<span class="built_in">pwd</span>:<span class="string">&#x27;098890&#x27;</span>,roles:[&#123;role:<span class="string">&#x27;dbOwner&#x27;</span>,db:<span class="string">&#x27;jeyson_db&#x27;</span>&#125;]&#125;)</span><br><span class="line"><span class="comment"># 创建完成后退出当前数据库 再重新进来认证登录（不要同一个数据库多个用户认证,否则报错too many users are authenticated）</span></span><br><span class="line"><span class="comment"># 重新进来后 切换到jeyson_db数据库 使用新创建的用户认证登陆</span></span><br><span class="line">use jeyson_db</span><br><span class="line">db.auth(<span class="string">&#x27;mytest&#x27;</span>, <span class="string">&#x27;098890&#x27;</span>)</span><br><span class="line"><span class="comment"># 插入users collection（类似表）中一条数据</span></span><br><span class="line">db.users.insertOne(&#123;name:<span class="string">&#x27;myname&#x27;</span>,age:30,email:<span class="string">&#x27;31231test@qq.com&#x27;</span>&#125;)</span><br><span class="line"><span class="comment"># 查询所有数据</span></span><br><span class="line">db.users.find(&#123;&#125;)</span><br><span class="line"><span class="comment"># 更新一条数据</span></span><br><span class="line">db.users.updateOne(&#123;name:<span class="string">&#x27;myname&#x27;</span>, &#123;<span class="variable">$set</span>:&#123;email:<span class="string">&#x27;83821dw@qq.com&#x27;</span>&#125;&#125;&#125;)</span><br><span class="line"><span class="comment"># 删除一条数据</span></span><br><span class="line">db.users.deleteOne(&#123;name:<span class="string">&#x27;myname&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他常用命令</span></span><br><span class="line">show users：显示用户</span><br><span class="line">show collections：显示当前数据库中的集合（类似关系数据库中的表）</span><br><span class="line">use &lt;db name&gt;：切换当前数据库</span><br><span class="line"><span class="comment"># MongoDB没有创建数据库的命令，但有类似的命令。</span></span><br><span class="line"><span class="comment"># 如：如果你想创建一个“myTest”的数据库，先运行use myTest命令，之后就做一些操作（如：db.createCollection(&#x27;user&#x27;)）,这样就可以创建一个名叫“myTest”的数据库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户相关</span></span><br><span class="line">1、添加一个用户</span><br><span class="line"> db.addUser(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"> db.addUser(<span class="string">&quot;userName&quot;</span>, <span class="string">&quot;pwd123&quot;</span>, <span class="literal">true</span>); 添加用户、设置密码、是否只读</span><br><span class="line"></span><br><span class="line">2、数据库认证、安全模式</span><br><span class="line"> db.auth(<span class="string">&quot;userName&quot;</span>, <span class="string">&quot;123123&quot;</span>);</span><br><span class="line"></span><br><span class="line">3、显示当前所有用户</span><br><span class="line"> show users;</span><br><span class="line"></span><br><span class="line">4、删除用户</span><br><span class="line"> db.removeUser(<span class="string">&quot;userName&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>mongoBD的备份和恢复</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 备份</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;容器id或名称&gt; mongodump -h localhost -u root -p 123456 -d &lt;指定数据库，去掉-d备份所有数据库&gt; -o /tmp/<span class="built_in">test</span></span><br><span class="line"><span class="comment"># 将数据备份到/tep/test目录下 该目录在容器内部 需要复制出来</span></span><br><span class="line">docker cp &lt;容器名称或id&gt;:/tmp/<span class="built_in">test</span> /tmp/<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复</span></span><br><span class="line"><span class="comment"># 可以先将宿主机里的/tmp/test目录拷贝到容器里的/tmp/test</span></span><br><span class="line"><span class="comment"># 然后再执行恢复</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;容器名称或id&gt; mongorestore -h localhost -u root -p 123456 --dir /tmp/<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 例如在服务器A docker里把运行的mongo数据库迁移到服务器B docker里</span></span><br><span class="line"><span class="comment"># 先备份服务器A上的数据库数据</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;容器id或名称&gt; /bin/bash <span class="comment"># 进容器里</span></span><br><span class="line"><span class="comment"># 指定test_db数据库及该数据库对应的账号密码 备份到/tmp/test下</span></span><br><span class="line">mongodump -h localhost -u testName -p 123456 -d test_db -o /tmp/<span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后恢复到服务器B上,其数据库地址和端口为121.132.12.11:27017</span></span><br><span class="line">mongorestore -h 121.132.12.11:27017 -u root -p 123456 --dir /tmp/<span class="built_in">test</span></span><br><span class="line"><span class="comment"># 指定服务器B数据库地址和端口，输入有权限的用户名密码，传递要恢复的数据/tmp/test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后服务器B数据库中就多了这个库的数据</span></span><br><span class="line"><span class="comment"># 如果之前没创建过这个库，那么需要先登陆root用户，然后切换到该数据库下，然后新建登陆账号密码</span></span><br><span class="line"><span class="comment"># 所以备份的数据只是把数据传过来了，并不是把旧服务器上该库的登陆账号密码也传过来，需要自己重新设置</span></span><br></pre></td></tr></table></figure>

<br />

<h3 id="2、redis数据库安装"><a href="#2、redis数据库安装" class="headerlink" title="2、redis数据库安装"></a>2、redis数据库安装</h3><p>在服务器上新建<code>docker-compose.yml</code>文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在home目录下新建redis文件文件夹，在里面新建docker-compose.yml文件</span></span><br><span class="line"><span class="built_in">cd</span> /home</span><br><span class="line">mkdir redis</span><br><span class="line"><span class="built_in">cd</span> redis</span><br><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure>

<p>然后对yml文件进行配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将下面的配置复制到里面</span></span><br><span class="line">version: &#x27;3.8&#x27; # compose版本</span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis # 镜像名</span><br><span class="line">    restart: always</span><br><span class="line">    container_name: &#x27;redis&#x27; # 容器名称</span><br><span class="line">    ports:</span><br><span class="line">      - 6379:6379</span><br><span class="line">    volumes:</span><br><span class="line">      - /home/redis:/data </span><br><span class="line">    command: [&quot;redis-server&quot;, &quot;--requirepass&quot;, &quot;700209&quot;]</span><br></pre></td></tr></table></figure>

<p>保存文件后退出，然后挂在后台运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<p>注意：上面映射端口后，需要在防火墙和安全组中放通该端口。</p>
<br />

<h3 id="3、mock测试服务安装"><a href="#3、mock测试服务安装" class="headerlink" title="3、mock测试服务安装"></a>3、mock测试服务安装</h3><p>使用mock数据提供方式：</p>
<p>1、本地引用mock测试，详情<a href="http://mockjs.com/">mock.js官方文档</a></p>
<p>2、自己的服务器上通过DOClever测试服务（详见<a href="https://github.com/sx1989827/DOClever">DOClever github上面文档</a>）</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gn7v8kfkcag30eq0d8dh3.gif" alt="mock"></p>
<p>下面介绍在服务器上搭建DOClever测试服务。</p>
<p>新建<code>docker-compose.yml</code>文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在home目录下新建redis文件文件夹，在里面新建docker-compose.yml文件</span></span><br><span class="line"><span class="built_in">cd</span> /home</span><br><span class="line">mkdir doclever</span><br><span class="line"><span class="built_in">cd</span> doclever</span><br><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure>

<p>然后对yml文件进行配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将下面的配置复制到里面</span></span><br><span class="line">version: &#x27;3.8&#x27;</span><br><span class="line">services:</span><br><span class="line">  DOClever:</span><br><span class="line">    image: lw96/doclever</span><br><span class="line">    restart: always</span><br><span class="line">    container_name: &quot;DOClever&quot;</span><br><span class="line">    ports:</span><br><span class="line">    - 12333:10000</span><br><span class="line">    volumes:</span><br><span class="line">    - /srv/doclever/file:/root/DOClever/data/file</span><br><span class="line">    - /srv/doclever/img:/root/DOClever/data/file/img</span><br><span class="line">    - /srv/doclever/tmp:/root/DOClever/data/tmp</span><br><span class="line">    environment:</span><br><span class="line">    - DB_HOST=mongodb://mongo:27017/DOClever</span><br><span class="line">    - PORT=10000</span><br><span class="line">    links:</span><br><span class="line">    - mongo:mongo</span><br><span class="line"></span><br><span class="line">  mongo:</span><br><span class="line">    image: mongo:latest</span><br><span class="line">    restart: always</span><br><span class="line">    container_name: &quot;mongodb&quot;</span><br><span class="line">    volumes:</span><br><span class="line">    - /srv/doclever/db:/data/db</span><br><span class="line">    # 将doclever里的数据全部存放在/srv/doclever里</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果使用的数据库为非本地mongodb</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&quot;2&quot;</span></span><br><span class="line">services:</span><br><span class="line">DOClever:</span><br><span class="line"> image: lw96/doclever:latest</span><br><span class="line"> restart: always</span><br><span class="line"> container_name: <span class="string">&quot;DOClever&quot;</span></span><br><span class="line"> ports:</span><br><span class="line">    - 10000:10000</span><br><span class="line">    volumes:</span><br><span class="line">    - /hostdir/file:/root/DOClever/data/file</span><br><span class="line">    - /hostdir/img:/root/DOClever/data/file/img</span><br><span class="line">    - /hostdir/tmp:/root/DOClever/data/tmp</span><br><span class="line">    environment:</span><br><span class="line">    - DB_HOST=mongodb://remoteIP:remotePort/DOClever</span><br><span class="line">    - PORT=10000</span><br></pre></td></tr></table></figure>
</blockquote>
<p>保存文件后退出，然后挂在后台运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<p>注意：上面映射端口后，需要在防火墙和安全组中放通该端口。</p>
<p>改完配置，去云服务器和防火墙处给对应的端口放行，然后运行项目</p>
<ul>
<li><p>然后在浏览器里输入服务器ip+对应端口，即可进入管理系统</p>
</li>
<li><p>修改总后台密码（初始都是DOClever），然后进入整理好项目，输入返回数据</p>
</li>
<li><p><strong>直接请求线上的地址即可返回数据</strong>，或者使用在本地运行（net.js里设置的默认端口为36742）：</p>
<p><code>node net.js http://101.133.162.136:12301/mock/5e197d14c52cc5000bae3689 http://localhost:8081</code></p>
<p>然后，在postman里设置请求方式，地址loacalhost:36742/api，即可返回数据</p>
</li>
</ul>
<blockquote>
<p>注意文档里面有两个坑：</p>
<ol>
<li><p>docker-compose.yml配置文件里volumes挂载的img路径不对</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gn7v9r7gp2j30zc0u0npd.jpg" alt="image-20210201112110201"></p>
</li>
<li><p>mock规则有的例子有的不对</p>
<p>在DOClever官方文档中Mock数据这块，有一个规则是<code>@mj(&#123;@DTD:@DPD&#125;)</code>，但是它跟的例子是：<code>例如：@mj(&#123;&quot;3&quot;,&quot;a&quot;&#125;)</code>，它例子中间用的逗号，而不是规则里的冒号，导致我直接复制例子运行返回的数据一直报错，花了很长时间都没理解为什么……抓狂</p>
</li>
</ol>
</blockquote>
<p>另外有个功能未实现：参数如何传递到mockjs规则中？</p>
<p>在尝试用DOClever实践此项目时，需要输入num参数，根据输入的数字，确定返回的数据有多少条，于是问题来了，如何将num参数传递到DOClever的result结果规则里？</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gn7vdogb4ej320g0pq4d3.jpg" alt="image-20210201112457006"></p>
<p>我翻遍了DOClever的文档，它的mock规则只有@count可以返回多条数组数据，在@code里可以获取到一些内置对象，其中通过query可以获取到传递的参数，但是这两个规则并不能同时生效……</p>
<p>尝试了多次各种嵌套无果之后，用原生的@mj规则也没找到方法能实现输入参数num后，DOClever里自动根据num值返回对应的数据条数这个功能。</p>
<p>在原生的mock.js中，可以通过<code>Mock.mock( rurl, function( options ) )</code>中的options获取到的url/body，然后提取出参数，但是DOClever里还没发现有效的解决方法。据了解，这个功能并未实现。</p>
<br />

<h3 id="4、showdoc安装"><a href="#4、showdoc安装" class="headerlink" title="4、showdoc安装"></a>4、showdoc安装</h3><p>通过docker方式安装，先拉取镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull star7th/showdoc</span><br></pre></td></tr></table></figure>

<p>接着新建存放showdoc数据的目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /srv</span><br><span class="line">mkdir showdoc_data/html</span><br><span class="line">chmod  -R 777 showdoc_data <span class="comment"># 给予权限</span></span><br></pre></td></tr></table></figure>

<p>挂载启动容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name showdoc -p 12302:80 -v /srv/showdoc_data/html:/var/www/html/ star7th/showdoc</span><br></pre></td></tr></table></figure>

<p>注意在防火墙和安全组中放通该端口。</p>
<p>使用方法和数据的迁移等各种操作可查<a href="https://www.showdoc.com.cn/help?page_id=1385767280275683">文档</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>docker常用命令汇总</title>
    <url>/2021/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><p>在服务器上我钟爱docker服务，真香。</p>
<p>以下是我<strong>基于CentOS系统</strong>对它进行安装、管理、记录常用命令的相关笔记汇总。</p>
<a id="more"></a>

<h2 id="一、安装docker"><a href="#一、安装docker" class="headerlink" title="一、安装docker"></a>一、安装docker</h2><p>各个系统的安装方法官网上有详细的说明，这里是<a href="https://docs.docker.com/engine/install/centos/">CentOS系统的安装方法</a></p>
<p>安装过程简单的介绍如下：</p>
<h3 id="1、先删除旧的版本（确定没有可跳过）"><a href="#1、先删除旧的版本（确定没有可跳过）" class="headerlink" title="1、先删除旧的版本（确定没有可跳过）"></a>1、先删除旧的版本（确定没有可跳过）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine</span><br></pre></td></tr></table></figure>

<h3 id="2、安装相关依赖，设置存储库"><a href="#2、安装相关依赖，设置存储库" class="headerlink" title="2、安装相关依赖，设置存储库"></a>2、安装相关依赖，设置存储库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<h3 id="3、安装最新的稳定版本"><a href="#3、安装最新的稳定版本" class="headerlink" title="3、安装最新的稳定版本"></a>3、安装最新的稳定版本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<p>如果要选择指定的安装版本，先查看可安装的稳定版本列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line"></span><br><span class="line">docker-ce.x86_64  3:18.09.1-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64  3:18.09.0-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64  18.06.1.ce-3.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64  18.06.0.ce-3.el7                    docker-ce-stable</span><br></pre></td></tr></table></figure>

<p>然后选择其中一个版本安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io</span><br><span class="line"><span class="comment"># 比如要安装18.06.1这个版本，就执行这个命令</span></span><br><span class="line">sudo yum install docker-ce-18.06.1 docker-ce-cli-18.06.1 containerd.io</span><br></pre></td></tr></table></figure>

<h3 id="4、启动docker服务并测试"><a href="#4、启动docker服务并测试" class="headerlink" title="4、启动docker服务并测试"></a>4、启动docker服务并测试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用hello-world测试下</span></span><br><span class="line">sudo docker run hello-world</span><br><span class="line">Unable to find image <span class="string">&#x27;hello-world:latest&#x27;</span> locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">1b930d010525: Pull complete</span><br><span class="line">Digest: sha256:2557e3c07ed1e38f26e389462d03ed943586f744621577a99efb77324b0fe535</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果看到上面的提示，说明Docker已经成功安装并运行了了。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gn4n6mjs6jj31ls0ognh5.jpg" alt="image-20210129162438346"></p>
<h2 id="二、docker常用命令"><a href="#二、docker常用命令" class="headerlink" title="二、docker常用命令"></a>二、docker常用命令</h2><h3 id="1、镜像相关命令"><a href="#1、镜像相关命令" class="headerlink" title="1、镜像相关命令"></a>1、镜像相关命令</h3><ul>
<li><p>列出本地镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images [Options]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Options</span></span><br><span class="line"><span class="comment"># -a: 列出所有镜像</span></span><br><span class="line"><span class="comment"># -q :只显示镜像ID</span></span><br><span class="line"><span class="comment"># -f: 过滤显示满足条件的镜像</span></span><br><span class="line"></span><br><span class="line">docker images -f dangling=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把那些虚悬镜像列出来，这类镜像已经是没用的了，可以用下面命令删除</span></span><br><span class="line">docker rmi $(docker images -q -f dangling-true)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除本地镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker rmi [Options] &lt;镜像名&gt;</span></span><br><span class="line"><span class="comment"># -f: 强制删除</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>docker仓库</p>
<p>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/">Docker Hub</a>，大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p>
<p>先在 <a href="https://hub.docker.com/">https://hub.docker.com</a> 免费注册一个 Docker 账号。</p>
<ul>
<li><p>登录和退出</p>
<p>登录需要输入用户名和密码，登录成功后，我们就可以从 docker hub 上拉取自己账号下的全部镜像。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker login -u 用户名 -p 密码</span><br><span class="line">docker logout</span><br></pre></td></tr></table></figure>
</li>
<li><p>推送镜像到仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker tag ubuntu:18.04 username/ubuntu:18.04</span><br><span class="line">docker images</span><br><span class="line">docker push username/ubuntu:18.04</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>从仓库中寻找镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search httpd</span><br></pre></td></tr></table></figure>
</li>
<li><p>从仓库中拉取镜像下来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull httpd</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个新的镜像</p>
<ul>
<li><p>从容器中创建一个新的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit -a <span class="string">&quot;runoob.com&quot;</span> -m <span class="string">&quot;my apache&quot;</span> a404c6c174a2  mymysql:v1</span><br><span class="line"><span class="comment"># 将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Dockerfile文件创建新的镜像</p>
<p>Dockerfile 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># build stage</span></span><br><span class="line"><span class="comment"># 基于node10版本的环境</span></span><br><span class="line">FROM node:10 as build-stage</span><br><span class="line"></span><br><span class="line"><span class="comment"># maintainer是指谁在维护这个项目</span></span><br><span class="line">LABEL maintainer=ljclucky@163.com</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 创建一个工作目录</span></span><br><span class="line"> WORKDIR /app</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 把当前项目中的所有文件复制到镜像中来</span></span><br><span class="line"> <span class="comment"># 注：通过.dockerignore文件忽略不需要复制的文件</span></span><br><span class="line"> COPY . .</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 安装依赖 </span></span><br><span class="line"> <span class="comment">## 可以把npm换成yarn 并增加淘宝的镜像源</span></span><br><span class="line"> <span class="comment"># RUM yarn install --registry=https://registry.npm.taobao.org</span></span><br><span class="line"> RUN npm install</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 运行打包 生成dist文件夹</span></span><br><span class="line"> RUN npm run build</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># production stage</span></span><br><span class="line"> <span class="comment"># 生产部署环节，基于nginx稳定版环境</span></span><br><span class="line"> FROM nginx:stable-alpine as production-stage</span><br><span class="line"> <span class="comment"># 复制上面打包后项目目录里dist文件夹到 nginx主页html下</span></span><br><span class="line"> COPY --from=build-stage /app/dist /usr/share/nginx/html</span><br><span class="line"> <span class="comment"># 暴露80端口</span></span><br><span class="line"> EXPOSE 80</span><br><span class="line"> <span class="comment"># 把nginx运行起来</span></span><br><span class="line"> CMD [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>然后通过命令运行这个Dockerfile文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t web:1.0 .</span><br><span class="line"><span class="comment"># -t 打tag  . 指的是当前目录下的Dockerfile文件  </span></span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h3 id="2、容器相关命令"><a href="#2、容器相关命令" class="headerlink" title="2、容器相关命令"></a>2、容器相关命令</h3><ul>
<li><p>查看进程和日志服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps  // 查看当前运行的进程</span><br><span class="line">docker ps -a  // 查看所有进程 包括停止的</span><br><span class="line"></span><br><span class="line"><span class="comment"># -a: 列出所有进程</span></span><br><span class="line"><span class="comment"># -s: 显示总的文件大小。</span></span><br><span class="line"></span><br><span class="line">docker logs -f mysql  // -f 持续打印 输出容器日志信息</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>

<p><code>docker run 一个镜像</code>，如果找不到该镜像，就回去docker hub仓库拉取下来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -itd --name ubuntu-test ubuntu</span><br><span class="line"><span class="comment"># -i: 以交互模式运行容器，通常与 -t 同时使用</span></span><br><span class="line"><span class="comment"># -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用</span></span><br><span class="line"><span class="comment"># -d: 挂在后台运行，并返回容器ID</span></span><br><span class="line"><span class="comment"># --name: 为容器指定一个自定义名称</span></span><br><span class="line"></span><br><span class="line">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=123456 -p 10022:3306 -d mysql:latest</span><br><span class="line"><span class="comment"># -e: 设置环境变量</span></span><br><span class="line"><span class="comment"># -p: 端口映射，外部端口映射到容器内端口</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>停止</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop &lt;容器 ID或名字&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动已停止运行的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start &lt;容器 ID或名字&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker restart &lt;容器 ID或名字&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rm &lt;容器 ID或名字&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注：如果docker在运行中，不能删除，要先停止之后才能删除</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>进入容器内操作</p>
<p>在使用 <strong>-d</strong> 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</p>
<ul>
<li><p>docker attach</p>
</li>
<li><p><strong>docker exec</strong>：推荐使用 docker exec 命令，因为它退出容器终端，不会导致容器的停止。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> [OPTIONS] CONTAINER COMMAND [ARG...]</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it 243c32535da7 /bin/bash</span><br><span class="line">docker <span class="built_in">exec</span> -it 1e33b26152e1 /bin/sh</span><br><span class="line"><span class="comment"># or docker exec -it 1e33b26152e1 bash</span></span><br><span class="line"><span class="comment"># or docker exec -it 1e33b26152e1 sh</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>容器与主机之间的数据拷贝</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下</span></span><br><span class="line">docker cp /www/runoob 96f7f14e99ab:/www/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中</span></span><br><span class="line">docker cp 96f7f14e99ab:/www /tmp/</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h2 id="三、docker-compose工具"><a href="#三、docker-compose工具" class="headerlink" title="三、docker-compose工具"></a>三、docker-compose工具</h2><p>Compose是一个<code>批量</code>工具，用于运行与管理多个<code>docker</code>容器。使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>
<p>Compose 使用的三个步骤：</p>
<ul>
<li>使用 Dockerfile文件 定义应用程序的环境。</li>
<li>使用 docker-compose.yml文件 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li>
<li>最后，执行 docker-compose up 命令来启动并运行整个应用程序。</li>
</ul>
<h3 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h3><p>（详见官网 <a href="https://docs.docker.com/compose/install/%EF%BC%89">https://docs.docker.com/compose/install/）</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载docker-compose</span></span><br><span class="line">sudo curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/1.28.2/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给予执行权限</span></span><br><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试命令</span></span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>

<h3 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h3><p>docker-compose.yml 的配置案例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  jenkins:</span><br><span class="line">    container_name: <span class="string">&#x27;jenkins&#x27;</span></span><br><span class="line">    image: jenkins/jenkins:lts</span><br><span class="line">    restart: always</span><br><span class="line">    user: jenkins:994</span><br><span class="line">    ports:</span><br><span class="line">    - <span class="string">&quot;10050:8080&quot;</span></span><br><span class="line">    - <span class="string">&quot;50000:50000&quot;</span></span><br><span class="line">    - <span class="string">&quot;10051:10051&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">    - /srv/jenkins/data:/var/jenkins_home</span><br><span class="line">    - /usr/bin/docker:/usr/bin/docker</span><br><span class="line">    - /var/run/docker.sock:/var/run/docker.sock</span><br></pre></td></tr></table></figure>

<ul>
<li><p>启动程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br><span class="line">docker-compose up -d    // -d 在后台执行该服务</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose stop</span><br><span class="line">docker-compose rm</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>《海子诗集》读书笔记</title>
    <url>/2021/%E3%80%8A%E6%B5%B7%E5%AD%90%E8%AF%97%E9%9B%86%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gn0bndt0j2j31ci0u07wh.jpg" alt="image-20210125224320542"></p>
<p>11月底的时候在图书馆借了两本书，分别是《海子诗集》和《海子传》。</p>
<p>每天抽时间看一点，断断续续看了2个月才全部看完。</p>
<p>我是先看《海子传》的，要理解作品，自然得先从他成长的环境和时代背景开始了解。</p>
<p>海子生于安庆市怀宁县查家湾，父母是上个世纪典型的中国式农民，大半辈子都把汗水洒在庄稼里。海子的母亲在年轻时经历了家破人亡的痛苦，父亲是个沉默寡言的人，靠种地、做裁缝养活一家老幼。海子便在这样一个贫穷的小村庄中渐渐长大了。</p>
<blockquote>
<p>《村庄》</p>
<p>村庄中住着</p>
<p>母亲和儿女</p>
<p>儿子静静地长大</p>
<p>母亲静静地注视</p>
<br/>

<p>芦花丛中</p>
<p>村庄是一只白色的船</p>
<p>我妹妹叫芦花</p>
<p>我妹妹很美丽</p>
</blockquote>
<p>1979年海子通过自己的聪慧和努力，以15岁的年龄考入了北京大学法律系，成为这个贫瘠的村子里的一个传奇，也成为父母一生的荣耀。</p>
<p>上了北大之后，海子见识到了全国各地的青年才俊，感受到了各种文化思想的交流碰撞。当时文学诗歌潮流席卷全国，各种文化团体和报刊如雨后春笋般冒了出来，即便海子是法律学专业，也间接的被这种潮流氛围所影响，他从开始的只看些通俗小说，到后来转向古今中外各种文学著作：《诗经》、《楚辞》、《草叶集》、《摩诃婆罗多》、《神曲》……随着阅读量的增大，海子的兴趣不仅在于诗歌、哲学、美学，也开始关注民族民俗学。</p>
<p>在大二之后他陆续结识了好朋友骆一禾和西川，他们三人也即是后来所称的“北大三大诗人”。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gn3ti5xog3j31d00oanpd.jpg" alt="image-20210128231745697"></p>
<p>1983年，海子大学毕业，被分配到中国政法大学哲学教研室工作。如果说在大学里他只是模仿和尝试写诗，而到了这里他则正式开始踏上写诗之路了。</p>
<p>《海子诗集》是按写诗的时间顺序排列的，海子一生写诗的时间其实很短，从1983年开始，到1989年卧轨自杀结束——只有6年的时间。他前期的诗相对比较清澈单纯，主要意像包括故乡、村庄、麦子、少年、春天、马匹等，比如这首我特别喜欢的《新娘》：</p>
<blockquote>
<p>故乡的小木屋、筷子、一缸清水</p>
<p>和以后的许许多多日子</p>
<p>许许多多告别</p>
<p>被你照耀</p>
</blockquote>
<p>清澈如水，干净透明，我喜欢这种质朴平淡的文字，像家门口那条静静流淌的小溪，岁月隐在其中，暗藏力量。</p>
<p>海子工作后有了工资，可以帮父母分担一点经济压力，同时他开始谈恋爱了，女生是中国政法大学的学生，家境优越，父母都是高级知识分子。</p>
<p>按理说，如果继续持续下去，生活的一切都会越来越好的，但往往有些美好只是昙花一现的表象，根源上的问题早就在一开始就注定了。</p>
<p>首先是海子的诗作被各种拒绝。他大量的列印自己的诗作，不断寄给外面的诗人、评论家、诗歌爱好者，但并没有什么人去关心他的诗作，人们更关系那些已经成名的诗人，而且还有一些诗人在攻击他的写作行为。</p>
<p>接着是女朋友的父母对海子贫困农民出生表现出了鄙夷之情，他们绝不容许自己的女儿和这样一个穷小子谈恋爱。</p>
<p>在经济上，他经常充满着生存危机，除了定期向家里寄些钱之外，他的大部分工资都用来买书，只要他看上了一本书，会不惜血本买下，完全不考虑这一个月怎么过。</p>
<p>他就是这样单纯的活着，不会打理自己的日常，常常胡子啦喳，不谙人际交往，不知道如何和诗歌编辑们打好关系，不参与学校和系里的各种会议和活动，性格固执，工作好几年后在职称评定上还是一开始的“助教”资格。</p>
<p>1986年年底的时候，女友的父母来到学校逼迫他们彻底分手，对于海子来说，这是一个难以承受的受难之年，便如他日记中所说：</p>
<blockquote>
<p>我一直就预感到今天是一个很大的难关。一生之中最艰难、最凶险的关头。我差点被毁了。</p>
<p>两年来的情感和烦闷的枷锁，在这两个星期已充分显露的死神的面貌出现。我差一点自杀了……</p>
</blockquote>
<p>家境的贫寒，地位的低微，爱情的终结，海子心灰意冷，只能将目光投向无人察觉的内在世界。</p>
<blockquote>
<p>孤独是一只鱼筐</p>
<p>是鱼筐中的泉水</p>
<p>放在泉水中</p>
</blockquote>
<p>《海子诗集》到了后期，充斥着一些死亡意向：死亡、鲜血、头盖骨、尸体等等，而且很多诗的结尾备注时间是凌晨3-5点。</p>
<p>在那个没有手机和网络的年代，一个人常年通宵熬夜去构思和沉迷于鲜血、头盖骨、尸体这些幻想，这究竟是怎样的癫狂与宣泄？</p>
<p>他的好友西川后来说海子：</p>
<blockquote>
<p>每天上午睡觉，下午读书，晚上工作，在贫穷、单调、枯燥于孤独中写作。他紧紧封闭了大门，一无所有。</p>
</blockquote>
<p>我想象着他在很多个孤独的夜晚，就在自己一个人的小屋里，沉浸在自己的精神王国里，沉醉于自己的才华，他写着各种或憧憬、或血腥的文字，刀，火焰，他在发泄自己的现实中的无力感。</p>
<p>谁不想渴望一份尊重、渴望一份家的归属感呢？但是他没有了。</p>
<p>从小长大的故乡已经与他渐渐陌生，除了过年回一趟老家之外，他的学识和思想与父母已经分隔成两个世界的人，他工作的昌平也不是他的家，他的小屋永远孤零零的一人，爱情在这里埋葬了，他寄希望的远方也不是他的家，在远游内蒙古、青海、西藏之后，他写“远方除了遥远一无所有”、“远方的幸福 是多么痛苦”。</p>
<p>这是一种根本没法解决的生命处境、尴尬和悲凉——内心的无家可归。</p>
<p>海子的父亲后来对海子的自杀一直只有三个字：”不理解“，父子之间的隔阂与陌生至死都无法消解。</p>
<blockquote>
<p>柿子树</p>
<p>镇子边的柿子树</p>
<br/>

<p>树枝稀疏的秋之树</p>
<p>我只能站在路口望着她</p>
<br/>

<p>在镇子边的小村庄</p>
<p>有两颗秋天的柿子树</p>
<br/>

<p>柿子树下</p>
<p>不是我的家</p>
</blockquote>
<p>那个时候的海子还不是现在文学史上的海子，他终究只是一个无人问津的贫困的普通人。</p>
<p>海子的自杀行为后来被赋予了许多神性意义，“祭诗”、“倾心死亡”、“看到了消费时代的带来”……这些观点我不置可否，但我更多的还是想从一个正常的人的角度去解读。</p>
<p>海子的人间面临着诸多现实的困境，家庭的负担、心爱的女友已嫁为人妇、自己呕心泣血的诗作被贬的一文不值、生活窘迫贫困、想辞职去创办报刊被父亲痛斥、沉迷气功而出现精神幻觉……</p>
<p>每一个痛苦都像一把铁锤重击在他的心脏，我觉得这只是一个正常的人被现实逼迫到极致的绝望自救。他逃避了现实，躲进他的精神王国里，追求他的太阳与王位。</p>
<blockquote>
<p>秋天深了，王在写诗</p>
</blockquote>
<p>我想，如果他在当时是个像他父亲一样的普通的农民，如果他没有那么高的文化水平、没有那么多的胡思乱想，如果他没有看过那些哲学著作、没有看过诗人叶赛宁等一些诗人们的自杀事迹，如果他结婚生子了，如果他赚到了足够的钱让自己富足、让父母高兴.……任何一件事发生在他身上，他大概率都不会自杀。</p>
<p>但偏偏都没有。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gn2m7acxgfj311s0jy1kx.jpg" alt="image-20210127221933223"></p>
<p>海子在自杀前那个春节，还曾兴奋的对父母说，我要发大财了。他渴望用诗稿赚的费用让家庭摆脱贫困，让父母过上好日子，他的内心到底还是想能证明自己的价值，但是希望越大，失望时的痛苦就越深。</p>
<p>其实想想，自己又何尝不是这样呢？海子的处境难道不是我的处境吗？</p>
<p>父母长辈把我养大，供我读书，长大后我却与他们成为活在两个世界的人，每年过年回家，听爷爷说他过去的日子，我常常无动于衷，我无法融入他的世界，他也无法理解我的悲欢，唯有一种简单的朴素的关怀在中间维持。</p>
<p>我渴望能靠自己的才华和努力去获取更好的生活，但是一步步走来，却步履蹒跚、生活笨拙。</p>
<p>我单纯甚至幼稚的理解着这个世界，逃避与人的沟通，渐渐活在自己的岛上。</p>
<p>谁不憧憬着做一个自由而幸福的人呢？</p>
<blockquote>
<p>从明天起，做一个幸福的人</p>
<p>喂马，劈柴，周游世界</p>
<p>从明天起，关心粮食和蔬菜</p>
<p>我有一所房子，面朝大海，春暖花开</p>
<br/>

<p>从明天起，和每一个亲人通信</p>
<p>告诉他们我的幸福</p>
<p>那幸福的闪电告诉我的</p>
<p>我将告诉每一个人</p>
<br/>

<p>给每一条河每一座山取一个温暖的名字</p>
<p>陌生人，我也为你祝福</p>
<p>愿你有一个灿烂的前程</p>
<p>愿你有情人终成眷属</p>
<p>愿你在尘世获得幸福</p>
<p>我只愿面朝大海，春暖花开</p>
</blockquote>
<p>马匹、木柴、沾着水珠的粮食和蔬菜，这是海子心中的幸福的生活，也是每一个陷入现实沼泽的游子向往的生活。</p>
<p>我爱这清澈如水的文字，爱一切照映幸福的事物，但是我亦为写下这些文字的海子感到深深的悲伤——“从明天起”，所以今天呢？</p>
<p>海子在一生最灿烂的年纪却活在自我痛苦和流浪之中，他把幸福生活寄托在了想象之中，这到底不是我所追求的。</p>
<p>我佩服他自杀的勇气，亦轻视他作为一个男子汉的担当。海子死后，苦的是他的母亲，那位农村的老母亲，几乎疯了，见人就下跪……</p>
<p>鲁迅曾说，不要为了一己小小的悲欢，而忘了整个世界。</p>
<p>放下一些没必要的虚荣、名利、执念，去站在一个更高的位置俯瞰世界，所有困难都将会烟消云散。生死之外，皆是小事，这是我现在的观点，也是我对抗一切现实苦难的法宝。</p>
<p>《海子诗集》读完了，我喜欢的诗篇大概有10来首，也就是一两百行的字，其他晦涩难懂、悲观抑郁、鲜血淋漓的部分我是不爱读的，并且我一直认为有些诗仅仅是作者的私事，旁人没必要去深入曲解它。看自己喜欢的，从中汲取到一些力量，便已足够。</p>
<p>海子自杀后不久，中国迎来了改革开放，人们以轻快的步伐迎接消费时代的来临。生活条件渐渐改善，而文学则开始退出社会主流，不再是人人追求的白月光，也不再有大批的年轻人夜以继日的读诗写作，它渐渐退至社会边缘，成为一小部分人的精神寄托。</p>
<p>这是好事，我觉得文学本就不该成为社会的主流，他应该是成为基础教育的一部分，也成为人们自由选择的一个方向。让喜欢的人去喜欢，让无兴趣的去做他感兴趣的，幸福生活应该是自己去掌握。</p>
<p>海子在人生的最后一首诗《春天，十个海子》中写道：</p>
<p><strong>春天，十个海子全部复活</strong></p>
<br/>

<p><font color="#999999">—— 2021年1月28日晚  春天来临之前</font></p>]]></content>
      <categories>
        <category>写作</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中transition过渡组件全掌握</title>
    <url>/2021/Vue%E4%B8%ADtransition%E8%BF%87%E6%B8%A1%E7%BB%84%E4%BB%B6%E5%85%A8%E6%8E%8C%E6%8F%A1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6804a1350b9b4b7cae6fce6803ac6d55~tplv-k3u1fbpfcp-zoom-1.image" alt="view4"></p>
<p>在冷冰冰的网页上，加上些许过渡或动画，其变化虽小，却能极大的提升页面质感，给人一种顺畅、丝滑的视觉体验。它的实现过程主要是通过css中的<code>transition</code>和<code>animation</code>来实现的。</p>
<a id="more"></a>

<p>而在vue框架中也对此进行了封装，提供了便捷的过渡用法。</p>
<h3 id="1、transition组件用法"><a href="#1、transition组件用法" class="headerlink" title="1、transition组件用法"></a>1、transition组件用法</h3><p>在业务开发过程中，最常用的还是transition组件的用法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;slide-fade&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;show&quot;</span>&gt;</span> hello world <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 可以设置不同的进入和离开动画 */</span></span><br><span class="line"><span class="comment">/* 设置持续时间和动画函数 */</span></span><br><span class="line"><span class="selector-class">.slide-fade-enter-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all .<span class="number">3s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.slide-fade-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all .<span class="number">8s</span> <span class="built_in">cubic-bezier</span>(<span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">0.8</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.slide-fade-enter</span>, <span class="selector-class">.slide-fade-leave-to</span></span><br><span class="line">  <span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(10<span class="selector-tag">px</span>);</span><br><span class="line">  <span class="selector-tag">opacity</span>: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进入/离开的过渡中，主要有 6 个 钩子被触发，并对应6个class 切换。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18c2e6475de64fe08c67647395f1a4bf~tplv-k3u1fbpfcp-zoom-1.image" alt="状态过渡变化"></p>
<p>如果你的<code>transition</code>组件没有设置<code>name</code>属性，则 <code>v-</code> 是这些类名的默认前缀。如果你使用了<code>&lt;transition name=&quot;my-transition&quot;&gt;</code> ，那么 <code>v-enter</code> 会替换为 <code>my-transition-enter</code>。</p>
<p>这6种class类名可以自定义，他们的优先级高于普通的类名：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;slide-fade&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">enter-active-class</span>=<span class="string">&quot;custom-enter-active-class&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">leave-active-class</span>=<span class="string">&quot;custom-leave-active-class&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;show&quot;</span>&gt;</span> hello world <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* css部分 */</span></span><br><span class="line"><span class="selector-class">.custom-enter-active-class</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: bounce-in .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.custom-leave-active-class</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: bounce-in .<span class="number">5s</span> reverse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> bounce-in &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当有<strong>相同标签名</strong>的元素切换时，推荐<strong>在 <code>&lt;transition&gt;</code> 组件中的多个元素设置 key</strong> 让vue区分它们</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-if</span>=<span class="string">&quot;isEditing&quot;</span> <span class="attr">key</span>=<span class="string">&quot;save&quot;</span>&gt;</span></span><br><span class="line">    Save</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-else</span> <span class="attr">key</span>=<span class="string">&quot;edit&quot;</span>&gt;</span></span><br><span class="line">    Edit</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>该例子可以用key不同的值代替<code>v-if</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">:key</span>=<span class="string">&quot;isEditing&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; isEditing ? &#x27;Save&#x27; : &#x27;Edit&#x27; &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>另外在不同组件中切换过渡：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;component-fade&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;out-in&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">    	view: <span class="string">&#x27;v-a&#x27;</span></span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">&#x27;v-a&#x27;</span>: &#123;</span><br><span class="line">      template: <span class="string">&#x27;&lt;div&gt;Component A&lt;/div&gt;&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;v-b&#x27;</span>: &#123;</span><br><span class="line">      template: <span class="string">&#x27;&lt;div&gt;Component B&lt;/div&gt;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，上述两个组件的进入和离开是同时发生的，一个离开过渡的时候另一个开始进入过渡，只有离开的组件完成动画之后，才会把位置让出来，通常这会造成一种卡顿的效果（<strong>如果两个元素都设置了绝对定位，则没有这个问题</strong>）。</p>
<p>可以通过添加<strong>过渡模式mode</strong>来满足我们的需求：</p>
<ul>
<li><code>in-out</code>：新元素先进行过渡，完成之后当前元素过渡离开。</li>
<li><code>out-in</code>：当前元素先进行过渡，完成之后新元素过渡进入。</li>
</ul>
<p>通常我们更多的会使用<code>out-in</code>，让当前元素先离开，然后再进行新元素的进入。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;fade&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;out-in&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 不同元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>了解了以上的用法，基本就可以实现大部分业务场景了。</p>
<h3 id="2、使用JavaScript动态过渡"><a href="#2、使用JavaScript动态过渡" class="headerlink" title="2、使用JavaScript动态过渡"></a>2、使用JavaScript动态过渡</h3><p>在大部分场景下，我们主要是使用css来进行过渡，css已经前置写好了，但在某些情况下，我们还需要动态过渡。</p>
<p>动态过渡最基本的操作就是绑定动态属性，比如<code>name</code>，当有不同的情况时切换不同的过渡效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">:name</span>=<span class="string">&quot;transitionName&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>不过这同样需要我们提前写好对应的过渡效果，除此之外，最直接的实现动态过渡的方式是使用JavaScript过渡：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">before-enter</span>=<span class="string">&quot;beforeEnter&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">enter</span>=<span class="string">&quot;enter&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">after-enter</span>=<span class="string">&quot;afterEnter&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">enter-cancelled</span>=<span class="string">&quot;enterCancelled&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">  @<span class="attr">before-leave</span>=<span class="string">&quot;beforeLeave&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">leave</span>=<span class="string">&quot;leave&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">after-leave</span>=<span class="string">&quot;afterLeave&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">leave-cancelled</span>=<span class="string">&quot;leaveCancelled&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  <span class="comment">// 过渡进入之前触发</span></span><br><span class="line">  beforeEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123; &#125;,</span><br><span class="line">  <span class="comment">// 过渡进入时触发</span></span><br><span class="line">  enter: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 当与 CSS 结合使用时，回调函数 done 是可选的</span></span><br><span class="line">    <span class="comment">// 不用CSS过渡，设置了:css=&quot;false&quot;，则必须使用回调done </span></span><br><span class="line">    done()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 过渡进入结束时触发</span></span><br><span class="line">  afterEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123; &#125;,</span><br><span class="line">  <span class="comment">// 过渡进入被取消时触发</span></span><br><span class="line">  enterCancelled: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123; &#125;,</span><br><span class="line">	<span class="comment">// 在离开之前触发</span></span><br><span class="line">  beforeLeave: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123; &#125;,</span><br><span class="line">  <span class="comment">// 离开时触发</span></span><br><span class="line">  leave: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 当与 CSS 结合使用，回调函数 done 是可选的</span></span><br><span class="line">    <span class="comment">// 不用CSS过渡，设置了:css=&quot;false&quot;，则必须使用回调done </span></span><br><span class="line">    done()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 离开后触发</span></span><br><span class="line">  afterLeave: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123; &#125;,</span><br><span class="line">  <span class="comment">// 离开过程被取消时触发（只用于 v-show 中）</span></span><br><span class="line">  leaveCancelled: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这些JavaScript过渡钩子可以和 CSS <code>transitions/animations</code> 同时使用，也可以单独使用。</p>
<p>不过<strong>既然你都使用了 JavaScript 过渡，那么推荐就不用CSS过渡，元素添加 <code>v-bind:css=&quot;false&quot;</code>，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响</strong>。</p>
<p>如这个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Velocity 和 jQuery.animate 的工作方式类似，也是用来实现 JavaScript 动画的一个很棒的选择 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-4&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;show = !show&quot;</span>&gt;</span></span><br><span class="line">    Toggle</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">before-enter</span>=<span class="string">&quot;beforeEnter&quot;</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">enter</span>=<span class="string">&quot;enter&quot;</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">leave</span>=<span class="string">&quot;leave&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:css</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;show&quot;</span>&gt;</span></span><br><span class="line">      Demo</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example-4&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    show: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 钩子函数里写具体的过渡数据，可以实现js动态控制</span></span><br><span class="line">    beforeEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">      el.style.opacity = <span class="number">0</span></span><br><span class="line">      el.style.transformOrigin = <span class="string">&#x27;left&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    enter: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</span><br><span class="line">      Velocity(el, &#123; <span class="attr">opacity</span>: <span class="number">1</span>, <span class="attr">fontSize</span>: <span class="string">&#x27;1.4em&#x27;</span> &#125;, &#123; <span class="attr">duration</span>: <span class="number">300</span> &#125;)</span><br><span class="line">      Velocity(el, &#123; <span class="attr">fontSize</span>: <span class="string">&#x27;1em&#x27;</span> &#125;, &#123; <span class="attr">complete</span>: done &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    leave: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</span><br><span class="line">      Velocity(el, &#123; <span class="attr">translateX</span>: <span class="string">&#x27;15px&#x27;</span>, <span class="attr">rotateZ</span>: <span class="string">&#x27;50deg&#x27;</span> &#125;, &#123; <span class="attr">duration</span>: <span class="number">600</span> &#125;)</span><br><span class="line">      Velocity(el, &#123; <span class="attr">rotateZ</span>: <span class="string">&#x27;100deg&#x27;</span> &#125;, &#123; <span class="attr">loop</span>: <span class="number">2</span> &#125;)</span><br><span class="line">      Velocity(el, &#123;</span><br><span class="line">        rotateZ: <span class="string">&#x27;45deg&#x27;</span>,</span><br><span class="line">        translateY: <span class="string">&#x27;30px&#x27;</span>,</span><br><span class="line">        translateX: <span class="string">&#x27;30px&#x27;</span>,</span><br><span class="line">        opacity: <span class="number">0</span></span><br><span class="line">      &#125;, &#123; <span class="attr">complete</span>: done &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="3、初始渲染appear"><a href="#3、初始渲染appear" class="headerlink" title="3、初始渲染appear"></a>3、初始渲染appear</h3><p>上述过渡的用法通常需要元素或者组件有变化才会触发，如需要<code>v-if</code>、<code>v-show</code>、<code>动态组件</code>等。</p>
<p>如果你的需求是第一次进页面的时候，它就过渡渲染出来，之后是不需要再过渡的，那可以使用<code>appear</code>这个属性。如下面这个示例：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16557ad5478a411787323d10ab20c8b5~tplv-k3u1fbpfcp-zoom-1.image" alt="view2"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- appear 也可以自定义 CSS 类名 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">appear</span></span></span><br><span class="line"><span class="tag">            <span class="attr">appear-class</span>=<span class="string">&quot;custom-appear-class&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">appear-active-class</span>=<span class="string">&quot;custom-appear-active-class&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">appear-to-class</span>=<span class="string">&quot;custom-appear-to-class&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一段测试appear初始渲染文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.custom-appear-class</span>&#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.custom-appear-active-class</span>&#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">3s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.custom-appear-to-class</span>&#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>appear</code>和<code>enter</code>有点像，但它只在初始渲染的时候触发，并且只要把触发之前和触发之后的状态设置不同，便可以实现中间的自然过渡。</p>
<p>同时，它也可以用JavaScript钩子函数实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">appear</span> </span></span><br><span class="line"><span class="tag">            @<span class="attr">before-appear</span>=<span class="string">&quot;customBeforeAppearHook&quot;</span></span></span><br><span class="line"><span class="tag">            @<span class="attr">appear</span>=<span class="string">&quot;customAppearHook&quot;</span></span></span><br><span class="line"><span class="tag">            @<span class="attr">after-appear</span>=<span class="string">&quot;customAfterAppearHook&quot;</span></span></span><br><span class="line"><span class="tag">            @<span class="attr">appear-cancelled</span>=<span class="string">&quot;customAppearCancelledHook&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="4、列表过渡和v-move"><a href="#4、列表过渡和v-move" class="headerlink" title="4、列表过渡和v-move"></a>4、列表过渡和v-move</h3><p>同一时间内渲染单个节点，或者多个节点中的一个，使用<code>&lt;transition&gt;</code>组件，如果同时渲染多个节点，比如整个列表，则需要用<code>&lt;transition-group&gt;</code>组件，该组件有几个特点：</p>
<ul>
<li>不同于 <code>&lt;transition&gt;</code>，它会以一个真实元素呈现：默认为一个 <code>&lt;span&gt;</code>。可以通过 <code>tag</code> 属性更换为其他元素。</li>
<li>列表渲染中没有过渡模式。</li>
<li>内部元素必须要提供<code>key</code>值。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置tag属性为p元素，v-for中的每一项设置key值 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- items为一个连续数字组成的数组 [0, 1, 2, ...] --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transition-group</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;p&quot;</span> <span class="attr">class</span>=<span class="string">&quot;list-item&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">     &#123;&#123; item &#125;&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list-item</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list-enter-active</span>, <span class="selector-class">.list-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list-enter</span>, <span class="selector-class">.list-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">30px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc3ab1c6c0f944e0bd9a0e6fef5efb84~tplv-k3u1fbpfcp-zoom-1.image" alt="view3"></p>
<p>效果如上，但是这有一个问题：当添加和移除元素的时候，周围的元素会瞬间移动到他们的新布局的位置，有一种卡顿的感觉。</p>
<p>要解决这个问题可以通过<code>&lt;transition-group&gt;</code>组件中的 <strong><code>v-move</code></strong> class，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 <code>name</code> attribute 来自定义前缀，也可以通过 <code>move-class</code> attribute 手动设置。</p>
<p>于是只要在上面的例子中修改一下css：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list-item</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 这里增加和一个.list-move类样式，它会在元素改变的过程中生效 */</span></span><br><span class="line"><span class="selector-class">.list-move</span>&#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list-enter-active</span>, <span class="selector-class">.list-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 这里在元素离开时增加一个绝对定位属性 */</span></span><br><span class="line"><span class="comment">/* 这样元素离开的瞬间就会触发改变位置，使上面的.list-move生效 */</span></span><br><span class="line"><span class="comment">/* 如果不加绝对定位，则元素离开动作完成后周围的元素才会移动到它的位置 */</span></span><br><span class="line"><span class="comment">/* 而那个时候所有过渡已结束 .list-move已经被移除，会造成卡顿感觉 */</span></span><br><span class="line"><span class="selector-class">.list-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list-enter</span>, <span class="selector-class">.list-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">30px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6804a1350b9b4b7cae6fce6803ac6d55~tplv-k3u1fbpfcp-zoom-1.image" alt="view4"></p>
<p>如此就有了一种丝滑的感觉，另外上述css可进一步修改简化：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 直接在元素上增加transition属性 */</span></span><br><span class="line"><span class="comment">/* 它会在元素改变的所有过程中生效，包括v-move的时候 */</span></span><br><span class="line"><span class="selector-class">.list-item</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 因此v-move和v-active相关的均可不需要了 */</span></span><br><span class="line"><span class="comment">/* 只要在元素离开时增加一个绝对定位属性即可 */</span></span><br><span class="line"><span class="selector-class">.list-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list-enter</span>, <span class="selector-class">.list-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">30px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：v-move的内部实现，Vue 使用了一个叫 <a href="https://aerotwist.com/blog/flip-your-animations/">FLIP</a> 简单的动画队列。</p>
<p><strong>使用 FLIP 过渡的元素不能设置为 <code>display: inline</code> 。</strong></p>
<p><strong>所以可以设置为 <code>display: inline-block</code> 或者放置于 flex 中。</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue知识点补缺补漏</title>
    <url>/2021/Vue%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecde62367bf34970a53576e38a8f1073~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210119141418551"></p>
<p>最近重读了一遍vue2.0文档，感触颇深。在经过大量业务实践之后，回过头再读它们，会带着全新的视角去认识和理解。</p>
<p>另外在读文档的过程中还发现了一些盲区，有的是以前读文档时没注意一略而过，有的是实际业务开发中用的很少而渐渐忘记了，重读之后，感觉豁然开朗，有一种如汤化雪、水到渠成的舒畅感。</p>
<p>于是趁着这个机会，把一些或常用、或生僻的知识点提取出来，以记之。</p>
<h3 id="1、v-bind、v-on绑定动态属性"><a href="#1、v-bind、v-on绑定动态属性" class="headerlink" title="1、v-bind、v-on绑定动态属性"></a>1、v-bind、v-on绑定动态属性</h3><p>在实际开发中，常用的是v-bind、v-on绑定参数值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但重读文档才发现属性也可以动态绑定，以前倒是一直没注意：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 动态属性的绑定 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">key</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态事件的绑定 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">event</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>思考：</strong> 仔细想想，感觉应用场景并不多，因为一般html标签的属性并不需要动态更换， 需要什么属性在开发业务的过程都能提前预知并准备好，只要更改属性绑定的值就好了。不过还是mark一下，以便在以后遇到了合适的开发场景，能提供一个很好的解决方案。</p>
<h3 id="2、prop中传入对象的所有属性"><a href="#2、prop中传入对象的所有属性" class="headerlink" title="2、prop中传入对象的所有属性"></a>2、prop中传入对象的所有属性</h3><p>在实际开发中，最常用的是传单个属性：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">:title</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>有多少属性都一个个的传，但一次性传所有属性也很好用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 组件中</span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind</span>=<span class="string">&quot;post&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// data中的值</span><br><span class="line">post: &#123;</span><br><span class="line">  id: 1,</span><br><span class="line">  title: &#x27;My Journey with Vue&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这种也就等价于：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:id</span>=<span class="string">&quot;post.id&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:title</span>=<span class="string">&quot;post.title&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>思考：</strong> 在组件上面需要传递很多属性的时候，如果一个个的传，那么组件上会显得特别臃肿，而且每一个属性绑定的动态值都要放在data里，形成getter和setter，增加额外开销，通过传入对象的所有属性就能很好的解决这个问题。此外，<strong>配合<code>$attr</code>，<code>$listeners</code>等属性使用，成为封装组件的利器</strong>。</p>
<h3 id="3、prop中类型可以自定义构造函数"><a href="#3、prop中类型可以自定义构造函数" class="headerlink" title="3、prop中类型可以自定义构造函数"></a>3、prop中类型可以自定义构造函数</h3><p>vue中组件传递数据的prop，一般使用如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">   propA: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">   &#125; 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中type指的是传递数据的类型，可以定义原生构造函数中的8种类型之一：</p>
<p><code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Array</code>、<code>Object</code>、<code>Date</code>、<code>Function</code>、<code>Symbol</code></p>
<p>但实际上<code>type</code> 还可以是一个自定义的构造函数，如定义一个构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.firstName = firstName</span><br><span class="line">  <span class="built_in">this</span>.lastName = lastName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">props: &#123;</span><br><span class="line">    author: &#123;</span><br><span class="line">      type: Person,</span><br><span class="line">      <span class="keyword">default</span>: <span class="function">() =&gt;</span> <span class="keyword">new</span> Person(<span class="string">&#x27;Jeyson&#x27;</span>, <span class="string">&#x27;Liu&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在<code>author</code>的值不是构造函数Person的实例的时候，就会验证不通过而报错。</p>
<p><strong>思考：</strong> 在自己封装一些组件的时候，需要自定义一些专属的属性，可以通过自定义构造函数，来对传递参数进行检查验证，从而增强组件的健壮性。</p>
<h3 id="4、计算属性缓存-vs-方法的区别"><a href="#4、计算属性缓存-vs-方法的区别" class="headerlink" title="4、计算属性缓存 vs 方法的区别"></a>4、计算属性缓存 vs 方法的区别</h3><p>在实际开发中，计算属性和方法常常能达到一样的最终结果，如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 使用计算属性</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">// 使用方法</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 在组件中</span><br><span class="line">data: &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">	message: &#x27;&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">computed: &#123;</span><br><span class="line">  reversedMessage: function () &#123;</span><br><span class="line">    return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  reversedMessage: function () &#123;</span><br><span class="line">    return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是它们是有区别的。</p>
<ul>
<li><strong>计算属性是基于它们的响应式依赖进行缓存的</strong>。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 <code>message</code> 还没有发生改变，多次访问 <code>reversedMessage</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。</li>
<li>方法是每当<strong>触发重新渲染时，调用方法将总会再次执行函数</strong>。</li>
</ul>
<p>另外<strong>计算属性</strong>和<strong>侦听属性</strong>的区别是：</p>
<ul>
<li>计算属性适合应用在有一些数据需要随着其它数据变动而变动时，需要计算。</li>
<li>watch需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。比如当data里某个数据变化了，需要重新像后台发送请求获取数据，或者需要重新执行某个方法，就需要用watch。</li>
</ul>
<p><strong>思考：</strong> 在实际开发的过程中，要灵活的使用着三种方式，虽然大部分情况下多种方式都能实现，但是各自都有各自优劣的地方，理解它们，扬长避短。</p>
<h3 id="5、自定义v-model"><a href="#5、自定义v-model" class="headerlink" title="5、自定义v-model"></a>5、自定义v-model</h3><p>组件上<strong>v-model默认是value和input事件</strong>，如果是单选框和复选框等<strong>自定义类型的输入，就需要用model属性</strong>改变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;base-checkbox&#x27;</span>, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    <span class="comment">// 用model属性将默认的props:value和event:input改成想要的checked和change</span></span><br><span class="line">    prop: <span class="string">&#x27;checked&#x27;</span>,</span><br><span class="line">    event: <span class="string">&#x27;change&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    checked: <span class="built_in">Boolean</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      type=&quot;checkbox&quot;</span></span><br><span class="line"><span class="string">      v-bind:checked=&quot;checked&quot;</span></span><br><span class="line"><span class="string">      v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>现在在这个组件上使用 <code>v-model</code> 的时候，就可以实现单选框、复选框等自定义双向绑定：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-checkbox</span> <span class="attr">v-model</span>=<span class="string">&quot;lovingVue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">base-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="6、禁止继承-attr来接传递的属性"><a href="#6、禁止继承-attr来接传递的属性" class="headerlink" title="6、禁止继承 + $attr来接传递的属性"></a>6、禁止继承 + $attr来接传递的属性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">Vue.component(<span class="string">&#x27;base-input&#x27;</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>, <span class="comment">// 禁止继承</span></span><br><span class="line">  props: [<span class="string">&#x27;label&#x27;</span>, <span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;label&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;input</span></span><br><span class="line"><span class="string">        v-bind=&quot;$attrs&quot;</span></span><br><span class="line"><span class="string">        v-bind:value=&quot;value&quot;</span></span><br><span class="line"><span class="string">        v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">    &lt;/label&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// $attrs即父组件传递的额外参数</span></span><br><span class="line"><span class="comment">// 因为子组件设置了inheritAttrs: false, 所以父组件传递的额外参数不会落在根元素上</span></span><br><span class="line"><span class="comment">// 而是进入了$attrs里面，可以你让你决定这些 attribute 会被赋予哪个元素上。</span></span><br><span class="line"><span class="comment">// 注：style 和 class 属性依然还是在根元素上</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 父组件</span><br><span class="line"><span class="tag">&lt;<span class="name">base-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">&quot;username&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">required</span></span></span><br><span class="line"><span class="tag">  <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>思考：</strong> 封装组件很好用，可以接父组件传递的额外参数，尤其是针对原生元素进行封装。</p>
<h3 id="7、-native-listeners来接监听的事件"><a href="#7、-native-listeners来接监听的事件" class="headerlink" title="7、.native + $listeners来接监听的事件"></a>7、.native + $listeners来接监听的事件</h3><p>组件的根元素上直接监听一个原生事件，用 <code>.native</code> 修饰符：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span> <span class="attr">v-on:focus.native</span>=<span class="string">&quot;onFocus&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是.native只作用在子组件的根元素上，如果根元素没有这个事件，则是无效的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">  &#123;&#123; label &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:value</span>=<span class="string">&quot;value&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:input</span>=<span class="string">&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你想在父组件调用.native是作用在子组件里的某个元素上，可以使用Vue 提供了 <code>$listeners</code> 属性，它是一个对象，里面包含了作用在这个组件上的所有监听器。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  focus: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  input: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如同给子组件内指定的元素继承属性<code>$attrs</code>一样，通过<code>$listeners</code>属性就可以给指定的元素继承该事件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;base-input&#x27;</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  props: [<span class="string">&#x27;label&#x27;</span>, <span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">  computed: &#123;</span><br><span class="line">    inputListeners: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> vm = <span class="built_in">this</span></span><br><span class="line">      <span class="comment">// `Object.assign` 将所有的对象合并为一个新对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,</span><br><span class="line">        <span class="comment">// 我们从父级添加所有的监听器</span></span><br><span class="line">        <span class="built_in">this</span>.$listeners,</span><br><span class="line">        <span class="comment">// 然后我们添加自定义监听器，</span></span><br><span class="line">        <span class="comment">// 或覆写一些监听器的行为</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 这里确保组件配合 `v-model` 的工作</span></span><br><span class="line">          input: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">            vm.$emit(<span class="string">&#x27;input&#x27;</span>, event.target.value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;label&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;input</span></span><br><span class="line"><span class="string">        v-bind=&quot;$attrs&quot;</span></span><br><span class="line"><span class="string">        v-bind:value=&quot;value&quot;</span></span><br><span class="line"><span class="string">        v-on=&quot;inputListeners&quot;</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">    &lt;/label&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在子组件想要监听事件的元素上中通过v-on=”YourListenersObj”，绑定一个对象，里面是从父组件添加的监听事件，这个对象可以通过computed计算属性里面处理一些逻辑后返回（比如覆写一些监听器行为，防止被父组件添加的覆盖），拿父组件监听事件通过<code>$listeners</code>属性。如果不需要处理逻辑，则可以直接v-on=”$listeners”。</p>
<h3 id="8、-sync对prop-进行“双向绑定”"><a href="#8、-sync对prop-进行“双向绑定”" class="headerlink" title="8、.sync对prop 进行“双向绑定”"></a>8、.sync对prop 进行“双向绑定”</h3><p>在有些情况下，我们可能需要对一个 prop 进行“双向绑定”，可以通过.sync修饰符来实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件text-document中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;，</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 在需要修改props中title的值的时候，调用update:myPropName方法</span></span><br><span class="line">    handleChangeEvent () &#123;</span><br><span class="line">      <span class="built_in">this</span>.$emit(<span class="string">&#x27;update:title&#x27;</span>, <span class="string">&#x27;testTitle&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在父组件中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span> <span class="attr">:title.sync</span>=<span class="string">&quot;doc.title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>.sync</code>修饰符写法是简写，这样写实际上等价于：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:title</span>=<span class="string">&quot;doc.title&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:update:title</span>=<span class="string">&quot;doc.title = $event&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这种双向绑定的思路实际上和v-model很类似。实际上都是子组件通过$emit向上通知父组件去改动数据。</p>
<p>当我们用一个对象同时设置多个 prop 的时候，也可以将这个 <code>.sync</code> 修饰符和 <code>v-bind</code> 配合使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span> <span class="attr">v-bind.sync</span>=<span class="string">&quot;doc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样会把 <code>doc</code> 对象中的每一个 property (如 <code>title</code>) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 <code>v-on</code> 监听器。</p>
<h3 id="9、插槽基础"><a href="#9、插槽基础" class="headerlink" title="9、插槽基础"></a>9、插槽基础</h3><p><strong>#具名插槽</strong></p>
<p>有时我们需要多个插槽，通过name属性具名。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把页头放这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把主要内容放这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把页脚放这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一个不带 <code>name</code> 的 <code>slot</code> 出口会带有隐含的名字“default”。</p>
<p>在父组件使用插槽的时候通过在<code>&lt;template&gt;</code>元素上使用<code>v-slot:slotName</code>的方式（可缩写成 <code>#slotName</code>）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里面的内容在头部 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 没有指定slot名字的，默认放在default部分的slot里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 这里面的内容在底部 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 可缩写成#footer，注：如果使用缩写，后面必须有参数，如#default才行 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意 <strong><code>v-slot</code> 只能添加在 <code>&lt;template&gt;</code>上</strong>，除非只有一个默认插槽。</p>
<p><strong>#作用域插槽</strong></p>
<p>插槽内容和子组件里的数据是各自在独立的作用域内，如果想插槽内容可以访问子组件内的数据，可以在子组件的<code>&lt;slot&gt;</code>元素上绑定该数据，如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 子组件中插槽里绑定了user属性，值为user，默认插槽内是具体数据 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 绑定在 &lt;slot&gt; 元素上的 attribute 被称为 插槽prop --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:user</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; user.lastName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在父组件中引用时，可以定义插槽prop来取子组件提供的属性值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 将包含所有 插槽prop 的对象命名为 slotProps，这个可以自定义名字 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为只有一个默认插槽，可以简洁写法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>作用域插槽的内部工作原理是将插槽内容包裹在一个拥有单个参数的函数里：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">slotProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 插槽内容</span></span><br><span class="line">  <span class="comment">// slotProps即包含所有 插槽prop 的对象,也就是形参，可以自由命名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以形参slotProps也可以通过es6来解构：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; user, detail, info: newInfo &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName + newInfo &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>另外可以实现<strong>动态插槽</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:</span>[<span class="attr">dynamicSlotName</span>]&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>注：以上插槽用法是2.6.0版本后更新的，有一些ui组件或者插件还是之前废弃的写法，大致如下：</p>
<p>具名插槽使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或者直接作用在元素上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">slot</span>=<span class="string">&quot;header&quot;</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>作用域插槽：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;header&quot;</span> <span class="attr">slot-scope</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; slotProps.msg &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 或者直接作用在元素上，如果是default插槽可以简写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">slot-scope</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; slotProps.msg &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="10、插槽妙用：复用模版"><a href="#10、插槽妙用：复用模版" class="headerlink" title="10、插槽妙用：复用模版"></a>10、插槽妙用：复用模版</h3><p>例如，我们要实现一个 <code>todo-list</code> 组件，它是一个列表且包含布局和过滤逻辑：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in filteredTodos&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;todo.id&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们可以在每个li元素里面写一个同名插槽，并传递插槽prop出去，在父组件对其进行统一控制：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in filteredTodos&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;todo.id&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 每个todo里面都有一个同名插槽，并绑定了数据向外传递。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;todo&quot;</span> <span class="attr">:todo</span>=<span class="string">&quot;todo&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 后备内容 --&gt;</span></span><br><span class="line">      &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在父组件使用时为所有同名插槽定义一个不一样的 <code>&lt;template&gt;</code> 作为替代方案，并且可以从子组件获取传递过来的数据：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">todo-list</span> <span class="attr">:todos</span>=<span class="string">&quot;todos&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">todo</span>=<span class="string">&quot;&#123; todo &#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;todo.isComplete&quot;</span>&gt;</span>✓<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">todo-list</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个同名插槽的 <code>&lt;template&gt;</code> 模版将插入子组件所有同名的插槽里，并且渲染不同的数据。</p>
<p>因此，可以设置不同名字的插槽，设置不同的模版：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id + index&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;slotTitle&quot;</span> <span class="attr">:todo</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123; item.title &#125;&#125;</span><br><span class="line">     <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;slotData&quot;</span> <span class="attr">:todo</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123; item.data &#125;&#125;</span><br><span class="line">     <span class="tag">&lt;/<span class="name">slot</span>&gt;</span>         </span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">todo-list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">slotTitle</span>=<span class="string">&quot;&#123; todo &#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;todo.isComplete&quot;</span>&gt;</span>✓<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo.title &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">slotData</span>=<span class="string">&quot;&#123; todo &#125;&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo.data &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">todo-list</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="11、依赖注入provide、inject"><a href="#11、依赖注入provide、inject" class="headerlink" title="11、依赖注入provide、inject"></a>11、依赖注入provide、inject</h3><p>场景：父组件下有多个子组件，并且子组件内可能嵌套了子组件。此时多个子组件内需要访问父组件的一些数据/方法，可以尝试使用依赖注入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在父组件内，通过provide提供一些数据/方法</span></span><br><span class="line">provide: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 注：这里需要使用function ()的形式，如果使用() =&gt; 箭头函数，则this执行的不是本组件实例</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getData: <span class="built_in">this</span>.getData</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 另外如果是直接一个对象，里面的this是调用者的this，也就是子组件调用，则this是子组件</span></span><br><span class="line"><span class="comment">// 因此最好是通过function 返回一个对象</span></span><br><span class="line">provide: &#123;</span><br><span class="line">  getData () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  foo: <span class="number">123</span></span><br><span class="line">&#125;,</span><br><span class="line">  </span><br><span class="line">methods: &#123;</span><br><span class="line">  getData () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">123</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件内，通过inject注入父组件提供的数据或者方法，然后就可以在组件内访问了</span></span><br><span class="line"><span class="comment">// 所以在子组件内可以尝试更新父组件的数据，从而影响到子组件，但这样会造成读起来不容易理解</span></span><br><span class="line">inject: [<span class="string">&#x27;getData&#x27;</span>],</span><br><span class="line">methods: &#123;</span><br><span class="line">  test () &#123;</span><br><span class="line">    <span class="built_in">this</span>.getData()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在任何后代组件里，我们都可以使用 <code>inject</code> 选项来接收从父组件提供的数据/方法，实际上，可以把依赖注入看作针对父组件下任何后代组件的“大范围有效的 prop”。</p>
<p>注：使用依赖注入容易使各组件结构耦合，负面影响类似于通过$root、$parents来访问组件，所以更好的推荐是使用vuex。<code>provide</code> 和 <code>inject</code> 主要在开发高阶插件/组件库时使用。并不推荐用于普通应用程序代码中。</p>
<h3 id="12、程序化的侦听器去清理自己"><a href="#12、程序化的侦听器去清理自己" class="headerlink" title="12、程序化的侦听器去清理自己"></a>12、程序化的侦听器去清理自己</h3><p><code>$emit</code>可以派发一个事件，然后可以侦听：</p>
<ul>
<li>通过 <code>$on(eventName, eventHandler)</code> 侦听一个事件</li>
<li>通过 <code>$once(eventName, eventHandler)</code> 一次性侦听一个事件</li>
<li>通过 <code>$off(eventName, eventHandler)</code> 停止侦听一个事件</li>
</ul>
<p>你通常不会用到这些，但是当你需要在一个组件实例上手动侦听事件时，它们是派得上用场的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Pikaday 是一个第三方日期选择器的库</span></span><br><span class="line">  <span class="built_in">this</span>.picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">    field: <span class="built_in">this</span>.$refs.input,</span><br><span class="line">    format: <span class="string">&#x27;YYYY-MM-DD&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 在组件被销毁之前，也销毁这个日期选择器。</span></span><br><span class="line">beforeDestroy: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.picker.destroy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样有两个问题：</p>
<p>1、需要在组件实例data中保存这个picker，如果别的地方不需要调用，则最好不要这样保存，只在生命函数钩子里可以访问到它就好了。</p>
<p>2、创建代码和清理代码相互独立，不利于程序化的去管理。</p>
<p>所以可以通过一个程序化的侦听器解决这两个问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">    field: <span class="built_in">this</span>.$refs.input,</span><br><span class="line">    format: <span class="string">&#x27;YYYY-MM-DD&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 侦听钩子函数事件beforeDestroy，触发清理</span></span><br><span class="line">  <span class="built_in">this</span>.$once(<span class="string">&#x27;hook:beforeDestroy&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    picker.destroy()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以程序化的清理自己：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.attachDatepicker(<span class="string">&#x27;startDateInput&#x27;</span>)</span><br><span class="line">  <span class="built_in">this</span>.attachDatepicker(<span class="string">&#x27;endDateInput&#x27;</span>)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  attachDatepicker: <span class="function"><span class="keyword">function</span> (<span class="params">refName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">      field: <span class="built_in">this</span>.$refs[refName],</span><br><span class="line">      format: <span class="string">&#x27;YYYY-MM-DD&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.$once(<span class="string">&#x27;hook:beforeDestroy&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      picker.destroy()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="13、递归组件和循环引用"><a href="#13、递归组件和循环引用" class="headerlink" title="13、递归组件和循环引用"></a>13、递归组件和循环引用</h3><p><strong>#递归组件</strong></p>
<p>组件是可以在它们自己的模板中调用自身的。不过它们只能通过 <code>name</code> 选项来做这件事，稍有不慎，递归组件就可能导致无限循环：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">name: <span class="string">&#x27;stack-overflow&#x27;</span>,</span><br><span class="line">template: <span class="string">&#x27;&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>类似上述的组件将会导致“max stack size exceeded”错误，所以请确保递归调用是条件性的 (例如使用一个最终会得到 <code>false</code> 的 <code>v-if</code>)。</p>
<p><strong>#组件循环引用</strong></p>
<p>假设需要构建一个文件目录树，模板是这样的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;tree-folder&gt;组件模版 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; folder.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tree-folder-contents</span> <span class="attr">:children</span>=<span class="string">&quot;folder.children&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;tree-folder-contents&gt;组件模版 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;child in children&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tree-folder</span> <span class="attr">v-if</span>=<span class="string">&quot;child.children&quot;</span> <span class="attr">:folder</span>=<span class="string">&quot;child&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123; child.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>&lt;tree-folder&gt;组件</code>中引用了<code>&lt;tree-folder-contents&gt;组件</code>，而<code>&lt;tree-folder-contents&gt;组件</code>中又引用了<code>&lt;tree-folder&gt;组件</code>，这样就会出现问题。</p>
<p>解决的方法是：</p>
<p>1、通过 <code>Vue.component</code> 全局注册组件。</p>
<p>2、本地注册组件的时候，你可以使用 webpack 的异步 <code>import</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">components: &#123;</span><br><span class="line">  TreeFolderContents: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./tree-folder-contents.vue&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="14、X-Template另一种模板方式"><a href="#14、X-Template另一种模板方式" class="headerlink" title="14、X-Template另一种模板方式"></a>14、X-Template另一种模板方式</h3><p>另一个定义模板的方式是在一个 `` 元素中，并为其带上 <code>text/x-template</code> 的类型，然后通过一个 id 将模板引用过去。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/x-template&quot;</span> id=<span class="string">&quot;hello-world-template&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;Hello hello hello&lt;/p&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">&#x27;hello-world&#x27;</span>, &#123;</span><br><span class="line">  template: <span class="string">&#x27;#hello-world-template&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>x-template 需要<strong>定义在 Vue 所属的 DOM 元素外</strong>。</p>
<p>注：这些可以用于模板特别大的 demo 或极小型的应用，但是<strong>其它情况下请避免使用，因为这会将模板和该组件的其它定义分离开</strong>。</p>
<h3 id="15、自定义指令directive"><a href="#15、自定义指令directive" class="headerlink" title="15、自定义指令directive"></a>15、自定义指令directive</h3><p>除了vue内置的v-modal、v-show之外，可以自定义指令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个自定义指令v-focus</span></span><br><span class="line">directives: &#123;</span><br><span class="line">  focus: &#123;</span><br><span class="line">    inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">      el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在需要的地方使用</span></span><br><span class="line"><span class="comment">// &lt;input v-focus&gt;</span></span><br></pre></td></tr></table></figure>

<p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p>
<ul>
<li><p><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p>
</li>
<li><p><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p>
</li>
<li><p><code>update</code>：所在组件的 VNode 更新时调用，<strong>但是可能发生在其子 VNode 更新之前</strong>。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 。</p>
</li>
<li><p><code>componentUpdated</code>：指令所在组件的 VNode <strong>及其子 VNode</strong> 全部更新后调用。</p>
</li>
<li><p><code>unbind</code>：只调用一次，指令与元素解绑时调用。</p>
</li>
</ul>
<p>钩子函数的参数，以下面这个<code>v-demo</code>为例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是模版部分</span></span><br><span class="line"><span class="comment">// &lt;div v-demo:foo.a.b=&quot;message&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是script部分</span></span><br><span class="line">directives: &#123;</span><br><span class="line">  demo: &#123;</span><br><span class="line">    bind: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding, vnode</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 处理一些事情</span></span><br><span class="line">      <span class="built_in">console</span>.log(el) <span class="comment">// 本例即div元素，指定绑定的元素</span></span><br><span class="line">      <span class="built_in">console</span>.log(binding.name) <span class="comment">// demo，不包括 v- 前缀的指令名</span></span><br><span class="line">      <span class="built_in">console</span>.log(binding.value) <span class="comment">// hello，指定的绑定值</span></span><br><span class="line">      <span class="built_in">console</span>.log(binding.expression) <span class="comment">// message，字符串形式的指令表达式</span></span><br><span class="line">      <span class="built_in">console</span>.log(binding.arg) <span class="comment">// foo，传给指令的参数</span></span><br><span class="line">      <span class="built_in">console</span>.log(binding.modifiers) <span class="comment">// &#123;a: true, b: true&#125; 一个包含修饰符的对象</span></span><br><span class="line">      <span class="built_in">console</span>.log(vnode) <span class="comment">// vue编译生成的虚拟节点</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">data () &#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		message: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>el</code>：指令所绑定的元素。</li>
<li><code>binding</code>：一个对象，包含以下 property：<ul>
<li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。上例为：</li>
<li><code>value</code>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code>。</li>
<li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li>
<li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>。</li>
<li><code>arg</code>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。</li>
<li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>&#123; foo: true, bar: true &#125;</code>。</li>
</ul>
</li>
<li><code>vnode</code>：Vue 编译生成的虚拟节点。</li>
<li><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</li>
</ul>
<blockquote>
<p>注：除了 <code>el</code> 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的<code>dataset</code>来进行。</p>
</blockquote>
<h3 id="16、自定义指令动态参数妙用"><a href="#16、自定义指令动态参数妙用" class="headerlink" title="16、自定义指令动态参数妙用"></a>16、自定义指令动态参数妙用</h3><p>在 <code>v-mydirective:[argument]=&quot;value&quot;</code> 中，<code>argument</code> 参数可以根据组件实例数据进行更新。</p>
<p>如下面这个例子把元素动态的固定在距离页面顶部（或者左侧） 200 px的位置：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;dynamicexample&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Scroll down inside this section ↓<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pin:</span>[<span class="attr">direction</span>]=<span class="string">&quot;200&quot;</span>&gt;</span>I am pinned onto the page at 200px to the left.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Vue.directive(&#x27;pin&#x27;, &#123;</span><br><span class="line">  bind: function (el, binding, vnode) &#123;</span><br><span class="line">    el.style.position = &#x27;fixed&#x27;</span><br><span class="line">    var s = (binding.arg == &#x27;left&#x27; ? &#x27;left&#x27; : &#x27;top&#x27;)</span><br><span class="line">    el.style[s] = binding.value + &#x27;px&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#dynamicexample&#x27;,</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      direction: &#x27;left&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="17、渲染函数render"><a href="#17、渲染函数render" class="headerlink" title="17、渲染函数render"></a>17、渲染函数render</h3><p>大部分情况下用模版来创建html就好了，但是在某些情况下，需要js完全编程的能力，可以用渲染函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一个js文件 render-test.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;h1&#x27;</span>, <span class="built_in">this</span>.title)</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">&#x27;标题&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在vue文件中引用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">render-test</span> <span class="attr">title</span>=<span class="string">&quot;测试标题&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">render-test</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上面这个组件渲染为 &lt;h1&gt;测试标题&lt;/h1&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> RenderTest <span class="keyword">from</span> <span class="string">&#x27;./render-test.js&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  components: &#123; RenderTest &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实际场景如：需要动态创建html标签h1-h6，里面内容通过插槽来传入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一个js文件 render-title.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this.$slots.default是一个数组，里面包含这个元素之间的虚拟节点</span></span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;h&#x27;</span> + <span class="built_in">this</span>.level, <span class="built_in">this</span>.$slots.default)</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    level: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">1</span>,</span><br><span class="line">      required: <span class="literal">true</span>,</span><br><span class="line">      validator: <span class="function">(<span class="params">val</span>) =&gt;</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>].includes(val)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在vue文件中引用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">render-title</span> <span class="attr">:level</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 这里面的内容即为render-title组件的$slot.default中内容 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- $slot.default是虚拟节点组成的数组 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;title-icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>我是标题</span><br><span class="line">  	<span class="tag">&lt;/<span class="name">render-title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上面这个组件渲染为 &lt;h3&gt;【图标】我是标题&lt;/h3&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> RenderTitle <span class="keyword">from</span> <span class="string">&#x27;./render-title.js&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  components: &#123; RenderTitle &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>渲染函数的实现过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">&#x27;h1&#x27;</span>, <span class="built_in">this</span>.title)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过createElement()方法返回的是虚拟dom，createElement方法中的参数如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">createElement(</span><br><span class="line">  <span class="comment">// &#123;String | Object | Function&#125;</span></span><br><span class="line">  <span class="comment">// 一个html标签名、组件选项对象，或者 resolve 了这两个中任何一种的一个 async 函数。必填项。</span></span><br><span class="line">  <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;Object&#125;</span></span><br><span class="line">  <span class="comment">// 对上述标签/组件属性的描述。可选。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&#x27;class&#x27;</span>: &#123; <span class="attr">foo</span>: <span class="literal">true</span>, <span class="attr">bar</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="comment">// (详情见vue文档中渲染函数部分)</span></span><br><span class="line">    <span class="comment">// https://cn.vuejs.org/v2/guide/render-function.html#%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;String | Array&#125;</span></span><br><span class="line">  <span class="comment">// 子级虚拟节点，可选。</span></span><br><span class="line">  [</span><br><span class="line">    <span class="string">&#x27;先写一些文字&#x27;</span>,</span><br><span class="line">    createElement(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;一则头条&#x27;</span>),</span><br><span class="line">    createElement(MyComponent, &#123;</span><br><span class="line">      props: &#123;</span><br><span class="line">        someProp: <span class="string">&#x27;foobar&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上述内容可渲染为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;foo&quot;</span>&gt;</span></span><br><span class="line">  先写一些文字</span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>一则头条<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-component</span> <span class="attr">someProp</span>=<span class="string">&quot;foobar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里只是演示，my-component组件将渲染为html --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="18、用渲染函数重写模版功能"><a href="#18、用渲染函数重写模版功能" class="headerlink" title="18、用渲染函数重写模版功能"></a>18、用渲染函数重写模版功能</h3><ul>
<li><p>在模板中使用的 <code>v-if</code> 和 <code>v-for</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">&quot;items.length&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>No items found.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用渲染函数重写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.items.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> h(<span class="string">&#x27;ul&#x27;</span>, <span class="built_in">this</span>.items.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h(<span class="string">&#x27;li&#x27;</span>, item.name)</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> h(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;No items found.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    items: &#123;</span><br><span class="line">      type: <span class="built_in">Array</span>,</span><br><span class="line">      <span class="keyword">default</span>: [</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&#x27;one&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&#x27;two&#x27;</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用渲染函数重写v-model：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: [<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;input&#x27;</span>, &#123;</span><br><span class="line">      domProps: &#123;</span><br><span class="line">        value: self.value</span><br><span class="line">      &#125;,</span><br><span class="line">      on: &#123;</span><br><span class="line">        input: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">          self.$emit(<span class="string">&#x27;input&#x27;</span>, event.target.value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="comment">// &lt;render-input :value=&quot;message&quot; @input=&quot;message = $event&quot;&gt;&lt;/render-input&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>渲染函数中的事件&amp;修饰符</p>
<p>对于 <code>.passive</code>、<code>.capture</code> 和 <code>.once</code> 这些事件修饰符，Vue 提供了相应的前缀可以用于 <code>on</code>：</p>
<table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">前缀</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>.passive</code></td>
<td align="left"><code>&amp;</code></td>
</tr>
<tr>
<td align="left"><code>.capture</code></td>
<td align="left"><code>!</code></td>
</tr>
<tr>
<td align="left"><code>.once</code></td>
<td align="left"><code>~</code></td>
</tr>
<tr>
<td align="left"><code>.capture.once</code> 或 <code>.once.capture</code></td>
<td align="left"><code>~!</code></td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">on: &#123;</span><br><span class="line">  <span class="string">&#x27;!click&#x27;</span>: <span class="built_in">this</span>.doThisInCapturingMode,</span><br><span class="line">  <span class="string">&#x27;~keyup&#x27;</span>: <span class="built_in">this</span>.doThisOnce,</span><br><span class="line">  <span class="string">&#x27;~!mouseover&#x27;</span>: <span class="built_in">this</span>.doThisOnceInCapturingMode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于所有其它的修饰符，私有前缀都不是必须的，因为你可以在事件处理函数中使用事件方法：</p>
<table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">处理函数中的等价操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>.stop</code></td>
<td align="left"><code>event.stopPropagation()</code></td>
</tr>
<tr>
<td align="left"><code>.prevent</code></td>
<td align="left"><code>event.preventDefault()</code></td>
</tr>
<tr>
<td align="left"><code>.self</code></td>
<td align="left"><code>if (event.target !== event.currentTarget) return</code></td>
</tr>
<tr>
<td align="left">按键： <code>.enter</code>, <code>.13</code></td>
<td align="left"><code>if (event.keyCode !== 13) return</code> (对于别的按键修饰符来说，可将 <code>13</code> 改为<a href="http://keycode.info/">另一个按键码</a>)</td>
</tr>
<tr>
<td align="left">修饰键： <code>.ctrl</code>, <code>.alt</code>, <code>.shift</code>, <code>.meta</code></td>
<td align="left"><code>if (!event.ctrlKey) return</code> (将 <code>ctrlKey</code> 分别修改为 <code>altKey</code>、<code>shiftKey</code> 或者 <code>metaKey</code>)</td>
</tr>
</tbody></table>
<p>这里是一个使用所有修饰符的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">on: &#123;</span><br><span class="line">  keyup: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果触发事件的元素不是事件绑定的元素</span></span><br><span class="line">    <span class="comment">// 则返回</span></span><br><span class="line">    <span class="keyword">if</span> (event.target !== event.currentTarget) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 如果按下去的不是 enter 键或者</span></span><br><span class="line">    <span class="comment">// 没有同时按下 shift 键</span></span><br><span class="line">    <span class="comment">// 则返回</span></span><br><span class="line">    <span class="keyword">if</span> (!event.shiftKey || event.keyCode !== <span class="number">13</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 阻止 事件冒泡</span></span><br><span class="line">    event.stopPropagation()</span><br><span class="line">    <span class="comment">// 阻止该元素默认的 keyup 事件</span></span><br><span class="line">    event.preventDefault()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>渲染函数中的插槽和插槽作用域</p>
<p>使用<code>this.$slots</code>访问静态插槽的内容，每个插槽都是一个 VNode 数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// &lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;</span></span><br><span class="line">  <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, <span class="built_in">this</span>.$slots.default)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>this.$scopedSlots</code>访问作用域插槽，每个作用域插槽都是一个返回若干 VNode 的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">&#x27;message&#x27;</span>],</span><br><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// &lt;div&gt;&lt;slot :text=&quot;message&quot;&gt;&lt;/slot&gt;&lt;/div&gt;</span></span><br><span class="line">  <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, [</span><br><span class="line">    <span class="built_in">this</span>.$scopedSlots.default(&#123;</span><br><span class="line">      text: <span class="built_in">this</span>.message</span><br><span class="line">    &#125;)</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要用渲染函数向子组件中传递作用域插槽，可以利用描述节点对象中的 <code>scopedSlots</code> 字段：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// &lt;div&gt;&lt;child v-slot=&quot;props&quot;&gt;&lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt;&lt;/child&gt;&lt;/div&gt;</span></span><br><span class="line">  <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, [</span><br><span class="line">    h(<span class="string">&#x27;child&#x27;</span>, &#123;</span><br><span class="line">      scopedSclots: &#123;</span><br><span class="line">        <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> h(<span class="string">&#x27;span&#x27;</span>, props.text)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="19、JSX语法"><a href="#19、JSX语法" class="headerlink" title="19、JSX语法"></a>19、JSX语法</h3><p>写render函数通常没有写模版直观简单，所以有个babel插件用来在vue中写jsx语法，让我们更接近模版的写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> AnchoredHeading <span class="keyword">from</span> <span class="string">&#x27;./AnchoredHeading.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;AnchoredHeading level=&#123;<span class="number">1</span>&#125;&gt;</span><br><span class="line">        &lt;span&gt;Hello&lt;/span&gt; world!</span><br><span class="line">      &lt;/AnchoredHeading&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过在render函数中返回一个类似模版的写法，这种就是jsx语法。</p>
<h3 id="20、函数式组件"><a href="#20、函数式组件" class="headerlink" title="20、函数式组件"></a>20、函数式组件</h3><p>上述渲染函数可以像正常的组件一样拥有各种属性和生命周期：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// functional: true,</span></span><br><span class="line">  props: [<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      test: <span class="string">&#x27;11111&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;created&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.test)</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">h, context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注：只有上面设置了functional: true，这里context才有值，否则是undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(context)</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;233333&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是<strong>如果它只是一个接受一些 prop，没有响应数据，没有实例，这样的场景下可以使用函数式组件，将组件标记为 <code>functional</code>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-component&#x27;</span>, &#123;</span><br><span class="line">  functional: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// Props 是可选的</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 为了弥补缺少的实例</span></span><br><span class="line">  <span class="comment">// 提供第二个参数作为上下文</span></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement, context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>组件需要的一切都是通过 <code>context</code> 参数传递，它是一个包括如下字段的对象：</p>
<ul>
<li><code>props</code>：提供所有 prop 的对象</li>
<li><code>children</code>：VNode 子节点的数组</li>
<li><code>slots</code>：一个函数，返回了包含所有插槽的对象</li>
<li><code>scopedSlots</code>：(2.6.0+) 一个暴露传入的作用域插槽的对象。也以函数形式暴露普通插槽。</li>
<li><code>data</code>：传递给组件的整个数据对象，作为 <code>createElement</code> 的第二个参数传入组件</li>
<li><code>parent</code>：对父组件的引用</li>
<li><code>listeners</code>：(2.3.0+) 一个包含了所有父组件为当前组件注册的事件监听器的对象。这是 <code>data.on</code> 的一个别名。</li>
<li><code>injections</code>：(2.3.0+) 如果使用了 inject选项，则该对象包含了应当被注入的 property。</li>
</ul>
<p>这种函数式组件的好处是：<strong>因为函数式组件只是函数，所以渲染开销也低很多</strong>。</p>
<h3 id="21、开发插件"><a href="#21、开发插件" class="headerlink" title="21、开发插件"></a>21、开发插件</h3><p>Vue.js 的插件应该暴露一个 <code>install</code> 方法。这个方法的第一个参数是 <code>Vue</code> 构造器，第二个参数是一个可选的选项对象。通过全局方法 <code>Vue.use()</code> 使用插件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MyPlugin.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 添加全局方法或 property</span></span><br><span class="line">  Vue.myGlobalMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 添加全局资源</span></span><br><span class="line">  Vue.directive(<span class="string">&#x27;my-directive&#x27;</span>, &#123;</span><br><span class="line">    bind (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 注入组件选项</span></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">  Vue.prototype.$myMethod = <span class="function"><span class="keyword">function</span> (<span class="params">methodOptions</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入组件模版</span></span><br><span class="line"><span class="keyword">import</span> FullLoadingComponent <span class="keyword">from</span> <span class="string">&#x27;./FullLoading&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fullLoading = &#123;</span><br><span class="line">  install: <span class="function"><span class="params">Vue</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建组件构造器</span></span><br><span class="line">    <span class="keyword">const</span> FullLoadingConstructor = Vue.extend(FullLoadingComponent)</span><br><span class="line">    <span class="comment">// 实例化组件</span></span><br><span class="line">    <span class="keyword">const</span> instance = <span class="keyword">new</span> FullLoadingConstructor()</span><br><span class="line">    <span class="comment">// 将组件挂载到div上</span></span><br><span class="line">    instance.$mount(<span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>))</span><br><span class="line">    <span class="comment">// 将div元素放到body里</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(instance.$el)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给vue绑定全局对象$fullLoading 提供两个方法show、hide</span></span><br><span class="line">    Vue.prototype.$fullLoading = &#123;</span><br><span class="line">      show: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        instance.show()</span><br><span class="line">      &#125;,</span><br><span class="line">      hide: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        instance.hide()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> fullLoading</span><br></pre></td></tr></table></figure>

<p>调用该插件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> FullLoadingComponent <span class="keyword">from</span> <span class="string">&#x27;@/plugins/FullLoading&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(FullLoadingComponent) <span class="comment">// 这样就在Vue上绑定了 $fullLoading 提供的两个方法show、hide</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...组件选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>神仙资源合集</title>
    <url>/2021/%E7%A5%9E%E4%BB%99%E8%B5%84%E6%BA%90%E5%90%88%E9%9B%86.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><p>要分享的资源主要分三大类：</p>
<p>1、 <strong>vip资源破解类</strong>：如百度文库vip资源下载、各大平台vip视频资源播放和下载（包括pc端、手机端、电视端）。<br>2、 <strong>浏览器插件类</strong>：如跨平台音乐播放、神仙功能百宝箱。<br>3、 <strong>收藏的网站类</strong>：一些个人觉得不错的网站。</p>
<h2 id="一、vip资源破解类"><a href="#一、vip资源破解类" class="headerlink" title="一、vip资源破解类"></a>一、vip资源破解类</h2><h3 id="1、-百度文库vip资源获取"><a href="#1、-百度文库vip资源获取" class="headerlink" title="1、 百度文库vip资源获取"></a>1、 百度文库vip资源获取</h3><p>在地址栏的baidu后面加vvv：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmht9kaa1uj31980lgwmt.jpg" alt="image-20210109222528101"></p>
<p>然后回车，自动跳转到下载页：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhtapirxwj31od0u0wxo.jpg" alt="image-20210109222640092"></p>
<p>首次可能要关注个公众号拿个验证码，拿到后就行了，word和pdf格式自选下载。</p>
<h3 id="2、vip视频资源破解"><a href="#2、vip视频资源破解" class="headerlink" title="2、vip视频资源破解"></a>2、vip视频资源破解</h3><blockquote>
<p><strong>方法1：在视频地址上加 wn.run</strong><font color="#ff0000"><strong>（效果一般）</strong></font></p>
</blockquote>
<p>在该视频链接地址 https://  后面 <strong>加上wn.run</strong>，然后回车。如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhu6jzfm0j31wk0oi17i.jpg" alt="image-20210109225717479"></p>
<p>跳转到这个页面：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhu2uv84nj31kz0u0gzf.jpg" alt="image-20210109225344123"></p>
<p>然后这个vip视频就解析出来了：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhu850zsxj31gz0u0e1z.jpg" alt="image-20210109225848799"></p>
<p>该方法同样可适用在<strong>手机浏览器</strong>上（但手机浏览器解析效果没有pc端好，因为脚本代码大多数是为PC端写的）：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhv5yhf07j316x0u0b29.jpg" alt="image-20210109233117697"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhv6v1jv3j31qf0u0b29.jpg" alt="image-20210109233211260"></p>
<p>注：<strong>wn.run这个命令可适用于几乎任何网站，针对要解析的网站，它可能会提供视频破解、下载、翻译、网页转pdf等各种功能，相当于把许多功能的脚本进行了汇总</strong>。</p>
<p>所以这个方法也可以适用于百度文库vip资源下载：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhvfvj305j31ya0s2h0j.jpg" alt="image-20210109234050404"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhvi1w01sj318y0u0gv2.jpg" alt="image-20210109234256547"></p>
<p>综上，以后遇到任何想要破解的vip资源，不管是视频还是文档，都可以先通过加 wn.run/ 的方法去试验一下。</p>
<p><strong>注：该方法在解析视频资源方面稳定性和效率上一般，远没有后面将介绍的方法二以及插件破解方式好。</strong>不过该方法还提供了其他包括下载、翻译、网页转pdf等功能，相对比较简单全面，算是一种<strong>后备方案</strong>。</p>
<blockquote>
<p><strong>方法2：针对手机端和电视端</strong><font color="#ff0000"><strong>（效果还不错）</strong></font></p>
</blockquote>
<p>由于最近有朋友问我有没有办法找到电视端的资源，所以去搜罗了一圈，倒是找到了10几个资源包，经过一个个测试筛选后，选了其中效果最好的一个，特来更新。</p>
<p>手机端使用很简单，微信搜一个小程序叫 <strong>i酷追剧助手</strong> 即可：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwgukumfrj30xo0qo1bi.jpg" alt="image-20210122144056087"></p>
<p>在其主页面中，可以看到当前各大平台热门的综艺、电视剧、影视、动漫。</p>
<p>选择自己想看的电视剧或者综艺啥的，或者直接搜索：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwh3hpp6dj318s0u0u0x.jpg" alt="image-20210122144932981"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwhb25k5pj30v90u0b29.jpg" alt="image-20210122145649766"></p>
<p>在电视端使用也简单，它除了小程序版，还有个app版，可以安装在电视盒子里，方法如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwhjpikptj313w0qgtf2.jpg" alt="image-20210122150508472"></p>
<p>该方法的<strong>优点显而易见：简单直接</strong>。</p>
<p>手机端直接进小程序即可，主流热门的vip视频资源都有，足以满足日常绝大部分需求，而且速度也不错，线路也稳定，有很多网友在支持维护。电视端也只要在盒子里装个app就行。</p>
<p><strong>至于缺点，在后面介绍PC端插件神器——油猴的时候统一说。</strong>如果你需要在PC端看一些vip视频，我推强烈荐用后面要介绍的插件神器去看。</p>
<p>此外，如果想在手机端或者电视端要看各大卫视的频道或直播，可以试试<strong>电视家</strong>这个应用，公众号直接搜索：电视家服务号，它有电视版、手机版、电脑版。</p>
<p>我简单的测试过最新版，频道很多，功能也蛮全，而且免费，缺点嘛，因为免费，所以人家恰了些饭，带了点个人广告，倒是也不算影响。</p>
<h2 id="二、浏览器插件类"><a href="#二、浏览器插件类" class="headerlink" title="二、浏览器插件类"></a>二、浏览器插件类</h2><h3 id="1、Listen1"><a href="#1、Listen1" class="headerlink" title="1、Listen1"></a>1、Listen1</h3><p>我在2019年的时候，有一段时间特别烦听歌要切换各大音乐平台，因为版权的缘故，经常听一首歌要去网易云、酷狗、qq音乐上找一圈，歌单也变得异常零碎。</p>
<p>我那时候就想如果能开发一款跨平台音乐播放的应用多好。</p>
<p>很显然，有这样想法的远不止我一个人，而是很多人。于是我在github上找到了这样一个开源的项目：<strong>Listen1</strong>音乐播放器。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhwe3iyh4j31wy0tk44o.jpg" alt="image-20210110001342338"></p>
<p>这个项目曾因为触动了大公司的利益，被QQ音乐举报而导致代码库临时关闭。后来经过开发团队和许多支持的人的守护而发展至今。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhwbn4rzxj31li0u0e81.jpg" alt="image-20210110001122442"></p>
<p>2019年我在使用它的时候，觉得它还有点瑕疵，并向开发团队发邮件反馈过issue。如今过了快2年时间，它经过不断的升级更新，变得愈发成熟稳定。</p>
<p>它的使用方法很简单，就跟各大音乐应用一样的的操作，下载安装后打开主界面：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhxc7fu2ej31cy0kw43h.jpg" alt="123"></p>
<p>最重要的功能是，在这里<strong>你可以创建一个歌单，这个歌单里能存放跨平台的音乐</strong>：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhxmqc8g8j323y0f60x2.jpg" alt="image-20210110005638679"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhxq3lbhvj322k0bu0w0.jpg" alt="image-20210110005952304"></p>
<p>我的歌单瞬间打破了平台壁垒，可以愉快的跨平台听歌啦：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhxtvfxusj31lg0ssgsa.jpg" alt="image-20210110010329974"></p>
<p>当前<strong>Listen1</strong>音乐播放器提供多种下载安装方式，包括<strong>windows桌面端、mac桌面端、手机安卓端、手机IOS端、浏览器插件端</strong>等等，可自行选择平台下载。</p>
<p><a href="http://listen1.github.io/listen1/">Listen1官网选择平台下载</a></p>
<h3 id="2、Tempermonkey（油猴）"><a href="#2、Tempermonkey（油猴）" class="headerlink" title="2、Tempermonkey（油猴）"></a>2、Tempermonkey（油猴）</h3><p>插件对于浏览器来说，就像给老虎插上了翅膀，瞬间让浏览器升了一个档次。</p>
<p>而在插件领域，你可以没有任何别的插件，但一定要有Tempermonkey（俗称油猴）。</p>
<p>无他，因为它是综合的用户脚本管理器，就相当于机器猫的那个口袋，里面包罗万象，什么神仙功能都有可能搞出来。</p>
<p>它经过全球各地无数开发者数年的积累，现在其官网已经有一大把的优秀的现成脚本，完全可以满足普通用户的日常应用，比如：<strong>屏蔽网页广告，网盘全速下载，免费观看腾讯、优酷、爱奇艺等各大视频网站VIP电影，免费下载酷狗、腾讯等音乐网站歌曲，免费下载文库文档，领取京东、天猫购物券，购物比价</strong>等等。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhywtsmfdj30u20u0qc8.jpg" alt="image-20210110014055843"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhz039rwxj30ts0z4k1s.jpg" alt="image-20210110014404532"></p>
<p>总之，这个插件综合管理了一大堆的神仙功能脚本，只要你到这个广阔的空间中去搜索和选择自己想要的功能，然后一键安装启动即可。</p>
<p>通过这个插件去<strong>破解视频是最稳定、速度最快、效率最高的，没有之一</strong>。</p>
<p><strong>安装及使用方法</strong>：</p>
<blockquote>
<p> 以360安全浏览器为例（其他国内大部分浏览器都类似，主要是找拓展程序，如果找不到可以去度娘，或者联系我）</p>
<p> <strong>1、打开浏览器进入市场搜索 tampermonkey，然后安装</strong></p>
</blockquote>
<blockquote>
<p> <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmkyi6cuyxj31di0kqtjd.jpg" alt="image-20210112154329841"></p>
<p> <strong>2、安装成功后，从库中获取你想要的功能脚本</strong></p>
<p> <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmkykmifcmj319i0rqdri.jpg" alt="image-20210112154550941"></p>
<p> <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmkyl2renyj31720q6qc5.jpg" alt="image-20210112154616769"></p>
<p> <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmkylmwjswj31cs0m2nfu.jpg" alt="image-20210112154648716"></p>
<p> <strong>3、寻找你需要的功能脚本并安装</strong></p>
<p> <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmkynftfh0j31820u01kx.jpg" alt="image-20210112154832407"></p>
<p> <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmkyod8osij31bg0quqn5.jpg" alt="image-20210112154926765"></p>
<p> <strong>4、使用</strong></p>
<p> <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmkz3v2ujsj31v90u016p.jpg" alt="image-20210112160419841"></p>
<p> <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmkz687a9vj31e40u0gz6.jpg" alt="image-20210112160636204"></p>
<p> <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmkz7ol6d9j31f10u0wip.jpg" alt="image-20210112160759999"></p>
</blockquote>
<p>因此，<strong>只要你用电脑端，我就建议你花2分钟安装一下这个插件，安装完之后你就可以享受各种爽歪歪的功能了，其中好处，懂得人都懂</strong>。</p>
<p>至于在手机端上去安装这个插件，需要指定的少数几个手机浏览器才支持拓展插件，比如yandex、Kiwi，都是国外的，你懂的，如果你愿意搞，那就执行下面这几步：</p>
<blockquote>
<p>1、有梯子，手机能上梯子。</p>
<p>2、下载kiwi浏览器，去插件市场下载油猴，安装相应的脚本。</p>
<p>3、因为大多数【油猴脚本】是针对PC端的，因此要在设置里选择“桌面版网站”，然后就能正常使用了。</p>
</blockquote>
<p>具体实现细节就不介绍了，要搭建SSR梯子等一些操作，过程略长，稍微有点麻烦，所以你最好找懂得人当面给你搞。</p>
<p>下面统一说下上面那个<strong>手机端i酷追剧助手的缺点：它短时间内没有刚出的新节目资源。</strong></p>
<p>比如前段时间黄磊新出了个《戏剧新生活》的综艺，已经过去5、6天了，搜索还是一片空白，包括b站刚上的一个《大侠卢小鱼》，完全搜不到。</p>
<img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwk0nlfncj30jc0e40tz.jpg" width="50%" align="center">
<br />

<p>用油猴插件的话，则至多几个小时就出来了：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwj5r1l6ej31ap0u0hdt.jpg" alt="image-20210122160052508"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmwja9e1dpj30zo0u0b29.jpg" alt="image-20210122160515330"></p>
<p>所以综上：</p>
<p><font color="#ff0000"><strong>如果你在电脑端看，就用油猴插件破解一切；</strong></font></p>
<p><font color="#ff0000"><strong>如果你用手机端、平板或者电视端，i酷追剧助手是个不错的选择。</strong></font></p>
<h3 id="3、集装箱"><a href="#3、集装箱" class="headerlink" title="3、集装箱"></a>3、集装箱</h3><p>因为在电脑端，我用的是谷歌浏览器，它要安装油猴插件需要<strong>科学上网</strong>，如果你用的也是谷歌，那就要介绍下面这个插件了。⬇️</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhz3xavw7j319s0u0qeh.jpg" alt="image-20210110014745528"></p>
<p>集装箱这个插件想要做的其实和上面的油猴类似，也是一个插件管理一大堆的服务，目前它提供快捷跳转、搜索、生成二维码等功能的右键菜单，当然这不是重点。重点是它提供的<strong>代理功能</strong>。</p>
<p>也就是通过安装它可以实现部分<strong>科学上网</strong>，然后可以访问谷歌相关应用，比如谷歌搜索，谷歌翻译，打开谷歌网上商店等等。</p>
<blockquote>
<p> <a href="https://www.yuque.com/newday-me/doc/roppru">查看集装箱插件安装方式</a></p>
<p> 注：该安装方式介绍中，如果你还无法科学上网，推荐文件安装方式，选择你想要安装的浏览器，然后根据上面的安装介绍，下载最新crx插件文件，拖动安装。</p>
</blockquote>
<p>安装完集装箱后，在浏览器中选择启动接管浏览器代理：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhzj2ty91j30y40hsacl.jpg" alt="image-20210110020219933"></p>
<p>于是便可以愉快的（部分）科学上网了。</p>
<p>从浏览器拓展程序中打开谷歌网上商店，然后去下载安装油猴吧。</p>
<h2 id="三、收藏的网站类"><a href="#三、收藏的网站类" class="headerlink" title="三、收藏的网站类"></a>三、收藏的网站类</h2><p>1、最大资源网：<a href="http://www.zuidazy4.com/">http://www.zuidazy4.com</a> </p>
<p>   天空资源网：<a href="http://www.tiankongzy.com/">http://www.tiankongzy.com</a></p>
<blockquote>
<p>注：微信端无法打开，要在浏览器中打开。</p>
<p>如果上面介绍的<code>wn.run/</code> 命令方法获取vip资源失效了，可到这里来尝试搜索，这里面的新的视频资源很多，且很多平台的vip视频都能搜到，可以观看和下载。</p>
<p>其实这也就是上面那个<code>i酷追剧助手</code>的线路来源之一。</p>
<p>另外百度搜索<code>黑米影院</code>，里面可以实现和<code>i酷追剧助手</code>差不多的效果。</p>
</blockquote>
<p>2、今日热榜：<a href="https://tophub.today/">https://tophub.today/</a></p>
<blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmi014939aj31xu0u0tot.jpg" alt="image-20210110021939706"></p>
<p>综合了各行各业最热门的消息，不仅包括各大主流媒体的消息，也包括你所在的行业内最热门消息。可以紧跟时事，睁眼看世界。</p>
</blockquote>
<p>3、全历史：<a href="https://www.allhistory.com/">https://www.allhistory.com/</a></p>
<blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmi061ihslj31ns0u0hdu.jpg" alt="image-20210110022423594"></p>
<p>国家历史时间轴、关系图谱、时间地图、画作、古籍全都可以查，逻辑设计的很惊艳，比如你要查秦始皇和拿破仑之间的关系，只要输入这两个人，就会通过各种联系自动建立起两人的关系图，十分有趣。可以学历史、查作品、查古籍。</p>
</blockquote>
<p>4、考拉新媒体导航：<a href="https://www.kaolamedia.com/">https://www.kaolamedia.com/</a></p>
<blockquote>
<p>做自媒体相关的人必备。</p>
</blockquote>
<p>5、好用的壁纸素材站：</p>
<p>​        <a href="https://wallhaven.cc/">https://wallhaven.cc/</a></p>
<p>​        <a href="https://wall.alphacoders.com/?lang=Chinese">https://wall.alphacoders.com/?lang=Chinese</a></p>
<p>​        <a href="https://bz.zzzmh.cn/#index">https://bz.zzzmh.cn/#index</a></p>
<blockquote>
<p>手机和电脑端都有，高清、可自选尺寸、各种快捷筛选。</p>
</blockquote>
<hr>
<p>…</p>
<p>暂时就先分享这么多吧，后续有时间再持续补充。</p>
<p>如果你有好玩的、好用的资源，也欢迎随时联系我进行交流。</p>]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>我的昵称和logo诞生记</title>
    <url>/2021/%E6%88%91%E7%9A%84%E6%98%B5%E7%A7%B0%E5%92%8Clogo%E8%AF%9E%E7%94%9F%E8%AE%B0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><p>既然决定要做自己的博客，那我就要想一个昵称和logo作为标识。</p>
<p>它可以在各大平台注册账号时统一使用，也可以考虑用来以后做b站、搞公众号什么的。</p>
<p>所以这个昵称要简单好记、具有辨识度，同时能表达个人的想法，体现个性化。</p>
<p>我吃了好几个晚上的橘子，苦思冥想，取了诸如 <code>热心市民刘某</code>、<code>吃瓜者甲</code>、<code>烫烫烫的小米粥</code>、<code>打鱼的阮小六</code> 等等多个正经的好名字。</p>
<p>其中一开始拟定的是<code>吃瓜者甲</code>，连logo的设计都想好了，半个西瓜，一把勺子，一个简单的小人，体现出我立志要做一个社会闲散人士的春秋梦想。</p>
<p>后来觉得好low，越想越不满意，便果断弃了。</p>
<p>有一天看群里朋友聊天，他们提到了一个词：<strong>游刃有余</strong>。我那时候正在纠结昵称，突然觉得这个词很好，读起来很顺口、很舒服，而且它所表达的意思也是我喜欢的一种状态，淡定，从容，于是我开始对这个词下功夫。</p>
<p>一般来说，现成的成语用于昵称是不太巧妙的，所以要改一改，或音变，或形变，比如之前我看到有个网友昵称叫<code>怕瓦落地</code>，就很有趣，也很巧妙，印象深刻，所以我开始拆解变形，<code>游刃有鱼</code>、<code>游刃有渔</code>、<code>有刃有余</code>，最终定到<code>有刃有鱼</code>的时候，觉得如有一道神光入体，这个词的音好、形好、意也好，各方面都甚是巧妙。</p>
<p>于是我拟定了<code>有刃有鱼</code>这个词，后来还加入了花名<code>阮小六</code>，组成最终昵称 <strong>有刃有鱼阮小六</strong>。</p>
<p><code>阮小六</code>的想法来源于《水浒传》，梁山好汉里有三兄弟：阮小二、阮小五、阮小七，家住石碣村，皆以打渔为生，那么我就想了，既有阮小七，说明应该有七个孩子，剩下的阮小一、阮小三、阮小四和阮小六去哪了呢？</p>
<p>按照那时候的环境和习俗，我猜测其他几人或是夭折，或是平庸无奇、淡于众人也。</p>
<p>但这些已不重要，主要是我向往他们的一种平平淡淡、自由自在的生活方式，便如李煜在《渔父词》中写道：</p>
<blockquote>
<p>一棹春风一叶舟， 一纶茧缕一轻钩。</p>
<p>花满渚，酒满瓯， 万顷波中得自由。</p>
</blockquote>
<p>即如此，便借<code>阮小六</code>之名，以寄我之向往，刚好我在大学宿舍中也排行老六。</p>
<p>确定好昵称，接下来就是设计logo了。</p>
<p>我又吃了好几个晚上的橘子，苦思冥想，设计了如下草图：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmiuke0do9j31ci0u0hdt.jpg" alt="image-20210110195608471"></p>
<p>logo要包含刃、鱼、渔夫三种元素，走中国风的路子。</p>
<p>我从中筛选了两种，代表两种设计思路：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmis9t445bj31ac0ii1kx.jpg" alt="image-20210110183647105"></p>
<ol>
<li>左边的设计思路通过展示鱼、刃元素，可将船和刃融合在一起，形成有刃有鱼。</li>
<li>右边的设计思路是鱼竿下没有鱼，因为鱼藏水底，而人+倒影合在一起就是一把刃，我就是刃，以身化刃。通过鱼藏水底、以身化刃，达到有刃有鱼的意境。</li>
</ol>
<p>设计思路是有了，接下来是实践它。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmis35ludzj314b0u07wi.jpg" alt="image-20210110183019035"></p>
<p>我在双十一的时候买了个板子，本用来学板绘的，此时用来画logo却是正好。</p>
<p>初稿画出来是这个样子的，哈哈：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmisdq5pztj31cc0gsajy.jpg" alt="image-20210110184033051"></p>
<p>第一次接触板子，笔刷啥的都不太懂，在b站找的教学视频边学边画，线条丑的一批。而且渔夫身上的衣服像钢筋一样的直……妥妥的直男思维，简直不忍直视。</p>
<p>在咨询了朋友的意见之后，我又花了两个晚上进行修改，同时把下载的笔刷工具基本全都试了一遍，大致有了底，并增加设计了新的一版，然后二稿是这样的：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmisomcqd3j319k0iin53.jpg" alt="image-20210110185100710"></p>
<p>这次看起来要好很多，有点我设计之初想的那个意思了。</p>
<p>接着我又进行了第三稿的修改，加了一些的细节，还配上了样机展示：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmisqgsg47j30j208ajsz.jpg" alt="image-20210110185247734"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmit1clkdfj31c60u0npe.jpg" alt="image-20210110190314719"></p>
<p>设计到了这里，我感觉大体上算差不多了，然而理想是丰满的，<strong>现实却是残酷的</strong>，当我把第一版作为头像时，发现犯了一个致命的错误：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmiteo8nakj31060butb4.jpg" alt="image-20210110191603041"></p>
<p>因为头像的尺寸有大有小，当在比较小的情况下，几乎都看不清这是啥。</p>
<p>尤其是鱼，放小了之后就是一个小点，更不要说它身上那么细的线条了。</p>
<p>我深刻的反思了其中的问题，由于第一次设计缺乏经验，第一版算是设计了个寂寞。如果要继续修改的话，整体结构都要变，去掉字，放弃细节，鱼和刃抽象成轮廓，且画面要极简，多个元素之间尽量融合在一起。</p>
<p>相比之下，第二版要更符合logo的功能性：简洁、有轮廓感。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmitx9v1igj310c0byabz.jpg" alt="image-20210110193355535"></p>
<p>所以我决定就用这版，至于第四稿，后续可以慢慢磨，倒是也不用急。</p>
<p>我已经有了第四稿的大致想法，等板绘学的更熟练些，再来更新。</p>]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>板绘</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器探索之旅：选购和登陆</title>
    <url>/2020/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A2%E7%B4%A2%E4%B9%8B%E6%97%85%EF%BC%9A%E9%80%89%E8%B4%AD%E5%92%8C%E7%99%BB%E9%99%86.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><p>去年在阿里云上购买了第一台云服务器作为个人学习使用。在这台服务器上，我实践了linux系统操作、mysql、mongodb、docker、jenkins、node等各种好用的技能，受益匪浅。</p>
<p>可惜当时不知道 <strong>新人专享</strong> 的优惠福利，只买了1年的有效期，直到续费时看到那个费用才追悔莫及。</p>
<p>噫吁嚱，悔乎迟矣！😭</p>
<a id="more"></a>

<h2 id="一、服务器选购"><a href="#一、服务器选购" class="headerlink" title="一、服务器选购"></a>一、服务器选购</h2><p>阿里云的服务器到期之后，我开始转战腾讯云，因为我的腾讯云还没注册过，可以享受新人优惠。</p>
<p>这一次果断选了服务器3年的有效期，注册账号后，实名认证。新人第一次购买打骨折，配置是1核2G，系统环境选的是centOS 7.6。因此：</p>
<blockquote>
<p><strong>以下所有的配置都是基于centOS 7.6系统环境下</strong>的。</p>
</blockquote>
<p>服务器购买成功后，我们先进行第一次登陆。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm2i3blwp7j31wm0rw7es.jpg" alt="image-20201227163551118"></p>
<p>腾讯云的控制台里选择购买的实例，进去后<strong>重置密码</strong>，然后重启服务器。</p>
<p>因为云服务器一般均会预装好 <code>ssh</code> 服务，所以可以直接用终端连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -p 22 root@ip</span><br></pre></td></tr></table></figure>

<p>其中root指默认管理员用户，ip则是该服务器的公网ip，因为默认ssh端口就是22，可以省略<code>-p 22</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@ip</span><br></pre></td></tr></table></figure>

<p>提示输入完密码，输完后即可登录上这台服务器啦。（上车上车）</p>
<blockquote>
<p>注：登录服务器需要使用到 <code>ssh</code> 协议，如果是 <code>Mac</code> 用户，默认的 <code>terminal</code> 终端即可支持，而 <code>Windows</code> 用户可以安装  <code>Git for Windows</code> 来进行操作。</p>
</blockquote>
<h2 id="二、开启防火墙和配置安全组"><a href="#二、开启防火墙和配置安全组" class="headerlink" title="二、开启防火墙和配置安全组"></a>二、开启防火墙和配置安全组</h2><p>新购的服务器怎么能没有防火墙呢？于是第一步就是查看防火墙的状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure>

<p>发现是Active: inactive (dead)，于是开启防火墙服务，并设置开启自启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动防火墙</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机启动防火墙</span></span><br><span class="line">systemctl <span class="built_in">enable</span> firewalld</span><br></pre></td></tr></table></figure>

<p>再次查看状态就显示Active: <strong>active (running)</strong> 啦</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3bhsiq8vj31bi0b2thm.jpg" alt="image-20201228093310448"></p>
<p>常用的防火墙相关命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld <span class="comment"># 查看防火墙服务状态</span></span><br><span class="line">systemctl start firewalld <span class="comment"># 启动防火墙服务</span></span><br><span class="line">systemctl stop firewalld <span class="comment"># 关闭防火墙服务</span></span><br><span class="line">systemctl restart firewalld <span class="comment"># 重启防火墙服务</span></span><br><span class="line">systemctl <span class="built_in">enable</span> firewalld <span class="comment"># 开机自启防火墙服务</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld <span class="comment"># 禁止自启防火墙服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 防火墙新增开放一个端口号</span></span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line"><span class="comment"># 开放多个端口:</span></span><br><span class="line">firewall-cmd --zone=public --add-port=80-90/tcp --permanent</span><br><span class="line"><span class="comment"># 删除一个端口</span></span><br><span class="line">firewall-cmd --zone=public --remove-port=80/tcp --permanent</span><br><span class="line"><span class="comment"># –-zone #作用域</span></span><br><span class="line"><span class="comment"># –-add-port=80/tcp #添加端口，格式为：端口/通讯协议</span></span><br><span class="line"><span class="comment"># --remove-port=80/tcp #移除端口，格式为：端口/通讯协议</span></span><br><span class="line"><span class="comment"># –-permanent 永久生效，没有此参数重启后失效</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看防火墙相关信息，包括添加的端口</span></span><br><span class="line">firewall-cmd --list-all</span><br><span class="line"><span class="comment"># 在不改变状态的条件下重新加载防火墙（注：修改了防火墙端口后，需要重载服务）</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<p>开启了服务器内的防火墙服务，还需要在实例中配置安全组规则。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3cdptls7j31jc0u0dmd.jpg" alt="image-20201228100351348"></p>
<blockquote>
<p>安全组是一种虚拟防火墙，具备有状态的数据包过滤功能，用于设置云服务器、负载均衡、云数据库等实例的网络访问控制，控制实例级别的出入流量，是重要的网络安全隔离手段。</p>
<p>您可以通过配置安全组规则，允许或禁止安全组内的实例的出流量和入流量。</p>
</blockquote>
<p>简单的说，安全组就是在外面再加一层防火墙，只有内外“两个防火墙”的端口都开放了，那个端口才能被访问。</p>
<p>默认的安全组规则是开放所有端口，这是相对不安全的，因此我们创建一个新的安全组，只设置我们需要暴露出去的几个端口，然后将新创建的安全组绑定到服务器实例上，并取消默认安全组的绑定。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3cmz0jl9j31we0fe434.jpg" alt="image-20201228101245113"></p>
<h2 id="三、修改主机名"><a href="#三、修改主机名" class="headerlink" title="三、修改主机名"></a>三、修改主机名</h2><p>作为一个强迫症患者，进去后主机名那一连串随机字符简直不能忍，于是开启防火墙之后，第二件事就是修改主机名。</p>
<p>注：主机名最好用连续的小写字母，因为任何特殊字符或空白字符会被移除，而提供的参数中的任何大写字母会自动转化为小写。</p>
<ul>
<li><p>临时修改</p>
<p>使用命令行修改 hostname 主机名(可自定义)，如<code>hostname myHostName</code>，重新登录 shell 生效。</p>
<p>注：此命令只是暂时的修改linux的主机名,它的存活时间为linux当前的运行时间,即在下一次服务器重启前的运行时间内。</p>
</li>
<li><p>永久修改</p>
<p>如果是 CentOS 7 操作系统，可以使用命令hostnamectl set-hostname 主机名 来修改，修改完毕后重新 SHELL 登录即可。如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname myHostName</span><br></pre></td></tr></table></figure>

<p>如果是 Ubuntu 系统，则需要修改文件 /etc/hostname， 将其对应的主机名修改为新的主机名。</p>
</li>
</ul>
<p>修改完成后，再次登陆进去，即可看到主机名已修改啦。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3cw4485ej31aw052go5.jpg" alt="image-20201228102132525"></p>
<h2 id="四、修改ssh默认端口"><a href="#四、修改ssh默认端口" class="headerlink" title="四、修改ssh默认端口"></a>四、修改ssh默认端口</h2><p>ssh是安全的加密协议，默认端口是22 <code>ssh -p 22 root@ip</code> ，不写可以省略，但是默认22端口不安全，因此我们需要<strong>修改ssh默认端口</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"><span class="comment"># 注：vim是linux系统里的常用编辑器，具体文件的创建、修改、删除等操作自行查阅了解。</span></span><br></pre></td></tr></table></figure>

<p>要注意是编辑文件名为<strong>sshd_config</strong>，是指sshd服务的配置，而不是ssh_config。</p>
<p>进入到文件里后找到里面的 <strong># Port 22</strong></p>
<p>将 <strong># Port 22</strong> 前面的 # 去掉，后面22端口改成自定义端口，如: <strong>Port 10022</strong></p>
<p>建议Port 22同时保留，防止修改失误后无法远程连接服务器，修改成功后再注释去掉22。</p>
<p>保存退出vim界面，重启服务。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3die8ew0j31cg0a8aep.jpg" alt="image-20201228104257120"></p>
<blockquote>
<p>注意：在修改ssh默认端口前，要先去设置防火墙 + 云服务器的安全组规则，开放你所设置的端口，然后再去改配置文件。</p>
<ol>
<li><p>去安全组里添加规则，添加一个10022端口，具体详见服务器提供商文档。</p>
</li>
<li><p>然后登陆云服务器，查询该端口是否被占用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --query-port=10022/tcp</span><br></pre></td></tr></table></figure>

<p>如果是no，就添加一下，成功后重载防火墙：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=10022/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>修改了ssh端口 还要告诉SElinux做了改变。也就是sshd_config文件里的这个提示：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3dse4a2bj319o0a2n1p.jpg" alt="image-20201228105233126"></p>
<blockquote>
<p>SELinux是linux系统里的一个安全模块，想要了解的可自行查阅。</p>
</blockquote>
<p>于是运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">semanage port -a -t ssh_port_t -p tcp 10022</span><br></pre></td></tr></table></figure>

<p>如果提示没有semanage命令，那么可进行如下操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找semanage是通过哪个安装包来提供的</span></span><br><span class="line">yum whatprovides semanage</span><br><span class="line"><span class="comment"># 查找完成后 运行安装</span></span><br><span class="line">yum install /*上面查出来的包名*/</span><br></pre></td></tr></table></figure>

<p>安装完成后，再次运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">semanage port -a -t ssh_port_t -p tcp 10022</span><br><span class="line"><span class="comment"># 查看是否设置成功</span></span><br><span class="line">semanage port -l | grep ssh</span><br></pre></td></tr></table></figure>

<p>最后重启服务即可修改成功，退出后用新端口重新登录。</p>
<p>然后去除上面的22端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 防火墙去除</span></span><br><span class="line">firewall-cmd --zone=public --remove-port=22/tcp --permanent</span><br><span class="line"><span class="comment"># SElinux去除</span></span><br><span class="line">semanage port -d -t ssh_port_t -p tcp 22</span><br><span class="line"><span class="comment"># 重启防火墙服务</span></span><br><span class="line">systemctl restart firewalld</span><br></pre></td></tr></table></figure>



<h2 id="五、ssh密钥登陆"><a href="#五、ssh密钥登陆" class="headerlink" title="五、ssh密钥登陆"></a>五、ssh密钥登陆</h2><p>登陆云服务器的方式其实有很多种，比如通过账号密码/密钥的<strong>命令行登陆</strong>、通过安装图形化工具进行<strong>图形化登陆</strong>、通过控制台实例里的<strong>远程连接登陆</strong>。</p>
<p>但是相对来说，最常用的还是ssh命令行登陆方式。</p>
<p>其中通过<code>ssh root@ip</code>账号/密码登陆，每次连接都要输入用户、ip和登陆密码，比较麻烦，并不适合常年都是在自己电脑上使用的场景，它更适合需要切换设备、在多个不同的地方登陆访问的场景，因此我们这里主要配置便捷的密钥登陆。</p>
<p>创建密钥主要有两种方式：</p>
<ul>
<li><p>云服务器控制台里直接创建密钥对。</p>
</li>
<li><p>自己通过ssh-keygen生成密钥对。</p>
</li>
</ul>
<p>两种方式实现效果都一样，这里介绍第一种最简单的方式创建：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3ec8o023j323w0l0n0y.jpg" alt="image-20201228111138356"></p>
<p>创建成功后，会自动下载密钥.pem文件到电脑上，这里将.pem私钥文件放在~/.ssh/下，修改权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 400 ~/.ssh/你的私钥文件</span><br></pre></td></tr></table></figure>

<p>接着在.ssh/里的config进行配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.ssh/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在该文件里编辑如下</span></span><br><span class="line">Host <span class="built_in">test</span>   <span class="comment"># 这里test是别名，等会你就可以直接 “ssh test” 就能登陆服务器了</span></span><br><span class="line">    HostName 121.199.57.149 <span class="comment"># 这里是你的服务器ip</span></span><br><span class="line">    Port 10022 <span class="comment"># 你的服务器ssh端口</span></span><br><span class="line">    User root <span class="comment"># 登录用户</span></span><br><span class="line">    IdentityFile ~/.ssh/ali_ecs_study.pem  <span class="comment"># 私钥地址</span></span><br></pre></td></tr></table></figure>

<p>修改成功后保存，这样服务器端就有了公钥（公钥要绑定到你的服务器实例上），客户端上就有了私钥，相当于双端互留了电话号码，接着直接连接即可登录了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>注：如果配置了密钥登陆，设置里会默认关闭密码登录。如果你要同时可以密钥登录或者密码登录，重置下实例密码即可。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构&amp;算法：JS封装“栈”结构</title>
    <url>/2020/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95%EF%BC%9AJS%E5%B0%81%E8%A3%85%E2%80%9C%E6%A0%88%E2%80%9D%E7%BB%93%E6%9E%84.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在学习数据结构和算法，虽然前端在实际业务开发中直接用到的一般不多，但学习这些能帮助我们理解一些底层知识，优化代码逻辑、提升代码质量，更重要的是对思维的锤炼，帮助我们朝着大前端的方向迈出更扎实的步伐。</p>
<p>作为一个初涉<strong>数据结构和算法</strong>的萌新，我将多看多练，尽可能的去系统的学习，并通过js来一一实现。写代码，不含糖，搞起搞起。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glppkimlzuj312g0gytdz.jpg" alt="image-20201216150239461"></p>
<h3 id="一、【数据结构】栈的介绍"><a href="#一、【数据结构】栈的介绍" class="headerlink" title="一、【数据结构】栈的介绍"></a>一、【数据结构】栈的介绍</h3><blockquote>
<p>栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。栈的特点是：先进后出LIFO(last in first out)，从栈顶放入元素的操作叫入栈，取出元素叫出栈。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glze434gj6j30xs0fi0x3.jpg" alt="image-20201225000135502"></p>
<h3 id="二、JS封装实现一个栈"><a href="#二、JS封装实现一个栈" class="headerlink" title="二、JS封装实现一个栈"></a>二、JS封装实现一个栈</h3><p>js本身提供了数组相关操作的方法，十分方便灵活，那么我们便基于数组来封装一个类，实现简单的栈结构及相关操作。</p>
<p>思路：</p>
<ul>
<li>创建一个类，在构造实例时创建一个数组类型的变量，来存放相关操作数据</li>
<li>类中提供一些栈相关操作方法和属性</li>
<li>实例化并测试操作</li>
</ul>
<p>封装如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装一个栈类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.data = [] <span class="comment">// 存放栈数据的变量</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过length属性 获取栈的长度</span></span><br><span class="line">  get length () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.data.length</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过isEmpty属性 判断是否空栈</span></span><br><span class="line">  get isEmpty () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.data.length === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 压栈</span></span><br><span class="line">  push (item) &#123;</span><br><span class="line">    <span class="built_in">this</span>.data.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 出栈</span></span><br><span class="line">  pop () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.data.pop()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清空栈</span></span><br><span class="line">  clear () &#123;</span><br><span class="line">    <span class="built_in">this</span>.data.length = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查看栈顶元素</span></span><br><span class="line">  peek () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.data[<span class="built_in">this</span>.data.length - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的栈结构就封装好了，接下来进行测试：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化并进行相关操作</span></span><br><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> Stack()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stack.length)  <span class="comment">// 栈长度，打印结果 0</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.isEmpty) <span class="comment">// 是否空栈 打印结果 true</span></span><br><span class="line"></span><br><span class="line">stack.push(<span class="number">1</span>) <span class="comment">// 将数字1压入栈中</span></span><br><span class="line">stack.push(<span class="number">2</span>) <span class="comment">// 将数字2压入栈中</span></span><br><span class="line">stack.push(<span class="number">3</span>) <span class="comment">// 将数字3压入栈中</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.peek()) <span class="comment">// 获取栈顶元素 打印结果 3</span></span><br><span class="line"></span><br><span class="line">stack.pop() <span class="comment">// 出栈</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.length)  <span class="comment">// 栈长度，打印结果 2</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.isEmpty) <span class="comment">// 是否空栈 打印结果 false</span></span><br><span class="line"></span><br><span class="line">stack.clear()</span><br><span class="line"><span class="built_in">console</span>.log(stack.length)  <span class="comment">// 栈长度，打印结果 0</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.isEmpty) <span class="comment">// 是否空栈 打印结果 true</span></span><br></pre></td></tr></table></figure>



<h3 id="三、栈相关经典题目解法"><a href="#三、栈相关经典题目解法" class="headerlink" title="三、栈相关经典题目解法"></a>三、栈相关经典题目解法</h3><h4 id="1、元素出栈、入栈顺序的合理性。"><a href="#1、元素出栈、入栈顺序的合理性。" class="headerlink" title="1、元素出栈、入栈顺序的合理性。"></a>1、元素出栈、入栈顺序的合理性。</h4><p>题目：入栈顺序是1、2、3、4、5，那么出栈顺序是4、5、3、2、1是否合理？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解：是否合理先从出栈顺序入手，我们可以通过实例化一个栈结构来模拟</span></span><br><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> Stack()</span><br><span class="line"><span class="comment">// 第一个出栈是4，那么4必然在栈顶，那么根据入栈顺序，依次如下：</span></span><br><span class="line">stack.push(<span class="number">1</span>)</span><br><span class="line">stack.push(<span class="number">2</span>)</span><br><span class="line">stack.push(<span class="number">3</span>)</span><br><span class="line">stack.push(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">stack.pop() <span class="comment">// 出栈 4</span></span><br><span class="line"></span><br><span class="line">stack.push(<span class="number">5</span>)</span><br><span class="line">stack.pop() <span class="comment">// 出栈 5</span></span><br><span class="line"></span><br><span class="line">stack.pop() <span class="comment">// 出栈 3</span></span><br><span class="line">stack.pop() <span class="comment">// 出栈 2</span></span><br><span class="line">stack.pop() <span class="comment">// 出栈 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此以上出栈顺序是合理的</span></span><br></pre></td></tr></table></figure>



<h4 id="2、通过栈结构来实现进制转换"><a href="#2、通过栈结构来实现进制转换" class="headerlink" title="2、通过栈结构来实现进制转换"></a>2、通过栈结构来实现进制转换</h4><p>题目，实现十进制整数转换为二进制、八进制、十六进制。</p>
<p>分析：<strong>十进制整数转换为二进制整数采用”除2取余，逆序排列”法。具体做法是：用2整除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glzefwxlrgj30ui0e8dj2.jpg" alt="image-20201225001302901"></p>
<p>转八进制和转十六进制思路同样如此。</p>
<p>下面通过栈结构来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 十进制整数转换其他进制方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>num [Number] 十进制整数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>base [Number] 要转换的进制；可选有：2-二进制（默认）；8-八进制；16-十六进制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> decimalcConversion = <span class="function">(<span class="params">num, base = <span class="number">2</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 判断要转换的是哪个进制</span></span><br><span class="line">  <span class="keyword">const</span> baseList = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">16</span>]</span><br><span class="line">  <span class="keyword">if</span> (baseList.includes(base)) &#123;</span><br><span class="line">    <span class="comment">// 创建一个栈实例</span></span><br><span class="line">    <span class="keyword">const</span> stack = <span class="keyword">new</span> Stack()</span><br><span class="line">    <span class="comment">// 向栈内压入余数</span></span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      stack.push(num % base)</span><br><span class="line">      num = <span class="built_in">Math</span>.floor(num / base)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出栈，存放到字符串中</span></span><br><span class="line">    <span class="keyword">let</span> string = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty) &#123;</span><br><span class="line">      <span class="keyword">let</span> item = stack.pop()</span><br><span class="line">      <span class="comment">// 针对16进制的处理</span></span><br><span class="line">      <span class="keyword">if</span> (item &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        item = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>][item - <span class="number">10</span>]</span><br><span class="line">      &#125;</span><br><span class="line">      string += item</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回转换后的进制字符串值</span></span><br><span class="line">    <span class="keyword">return</span> string</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;请输入正确的进制数&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">decimalcConversion(<span class="number">100</span>) <span class="comment">// 二进制 1100100</span></span><br><span class="line">decimalcConversion(<span class="number">100</span>, <span class="number">8</span>) <span class="comment">// 八进制 144</span></span><br><span class="line">decimalcConversion(<span class="number">100</span>, <span class="number">16</span>) <span class="comment">// 十六进制 64</span></span><br><span class="line">decimalcConversion(<span class="number">300</span>) <span class="comment">// 二进制 100101100</span></span><br><span class="line">decimalcConversion(<span class="number">300</span>, <span class="number">8</span>) <span class="comment">// 八进制 454</span></span><br><span class="line">decimalcConversion(<span class="number">300</span>, <span class="number">16</span>) <span class="comment">// 十六进制 12c</span></span><br></pre></td></tr></table></figure>



<h4 id="3、返回栈中元素的最小值"><a href="#3、返回栈中元素的最小值" class="headerlink" title="3、返回栈中元素的最小值"></a>3、返回栈中元素的最小值</h4><p>分析：元素入栈后，要直接从栈中寻找最小值是很困难的，因为栈结构主要就是入栈、出栈两个核心操作，因此要获取最小值，可以通过新建一个数组存放。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glzetiyujmj30ui0d6djv.jpg" alt="image-20201225002608310"></p>
<p>可以在上面封装栈的基础上继承，增加一个存放最小值的数组以及获取最小值的方法。</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承上面封装的栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> <span class="keyword">extends</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>()</span><br><span class="line">    <span class="built_in">this</span>.minData = [] <span class="comment">// 存放栈中最小值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取栈中最小元素</span></span><br><span class="line">  get minimum () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.minData[<span class="built_in">this</span>.minData.length - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重写压栈push方法</span></span><br><span class="line">  push (item) &#123;</span><br><span class="line">    <span class="keyword">let</span> min = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.data.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 第一个元素进来时</span></span><br><span class="line">      min = item</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则，对栈顶元素和压入元素进行比较，小的进minData</span></span><br><span class="line">      <span class="keyword">const</span> minimum = <span class="built_in">this</span>.minimum</span><br><span class="line">      min = item &lt;= minimum ? item : minimum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.data.push(item)</span><br><span class="line">    <span class="built_in">this</span>.minData.push(min)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重写出栈pop方法</span></span><br><span class="line">  pop () &#123;</span><br><span class="line">    <span class="built_in">this</span>.minData.pop()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.data.pop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> MinStack()</span><br><span class="line"></span><br><span class="line">stack.push(<span class="number">2</span>)</span><br><span class="line">stack.push(<span class="number">30</span>)</span><br><span class="line">stack.push(<span class="number">1</span>)</span><br><span class="line">stack.push(<span class="number">88</span>)</span><br><span class="line"><span class="built_in">console</span>.log(stack.minimum) <span class="comment">// 1</span></span><br><span class="line">stack.pop()</span><br><span class="line">stack.pop()</span><br><span class="line"><span class="built_in">console</span>.log(stack.minimum) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>当然，上面的实现主要是基于“栈”结构的特点，提供的一种解决问题的方式，目的是为了锤炼思维的多样性和灵活性。</p>
<p>实际上由于我们是通过js的数组来模拟封装栈结构的，所以完全可以直接通过操作原始数组来获取最小值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装一个栈类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.data = [] <span class="comment">// 存放栈数据的变量</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取栈中最小元素</span></span><br><span class="line">  get minimum () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.min(...this.data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其他属性和方法</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了最小值以外，获取栈结构中最大值的写法也同样如此。</p>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>html5中播放rtsp流实现监控、直播等方案</title>
    <url>/2020/html5%E4%B8%AD%E6%92%AD%E6%94%BErtsp%E6%B5%81%E5%AE%9E%E7%8E%B0%E7%9B%91%E6%8E%A7%E3%80%81%E7%9B%B4%E6%92%AD%E7%AD%89%E6%96%B9%E6%A1%88.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><p>工作需求：<strong>在浏览器网页上播放建筑工地摄像头监控的画面，如工地出入口通道画面、塔吊可视化，并且可兼容不同型号的摄像头设备</strong>。</p>
<p>由于摄像头大多都是通过 RTSP 协议传输视频流的，而HTML 并不标准支持 RTSP 流，经过网上各种查资料并一番讨论后初步拟定如下方案，<code>node + ffmpeg + websocket + flv.js</code>：</p>
<ol>
<li>在node服务中建立websocket</li>
<li>通过fluent-ffmpeg转码，将RTSP 流转为flv格式</li>
<li>前端通过flv.js连接websocket，并对获取的flv格式视频数据进行渲染播放</li>
</ol>
<p>思路非常清晰，下面开始实践。</p>
<h3 id="一、node服务搭建"><a href="#一、node服务搭建" class="headerlink" title="一、node服务搭建"></a>一、node服务搭建</h3><p>首先是新建一个项目，配置基础的webpack和babel，并安装websocket相关的两个库 <code>ws</code>、<code>websocket-stream</code>。</p>
<p>然后新建一个index.js文件，搭建websocket服务：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> WebSocket <span class="keyword">from</span> <span class="string">&#x27;ws&#x27;</span></span><br><span class="line"><span class="keyword">import</span> webSocketStream <span class="keyword">from</span> <span class="string">&#x27;websocket-stream/stream&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立WebSocket服务</span></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">8888</span>, <span class="attr">perMessageDeflate</span>: <span class="literal">false</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接</span></span><br><span class="line">wss.on(<span class="string">&#x27;connection&#x27;</span>, handleConnection)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接时触发事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleConnection</span> (<span class="params">ws, req</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;一个客户端连接进来啦&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此，一个简单的websocket服务就搭建好了，可以通过配置脚本运行该文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;nodemon --exec babel-node index.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行 <code>npm run start</code>即可启动websocket服务，端口是8888。可在前端通过websocket连接该地址，测试是否连接成功。</p>
<h3 id="二、ffmpeg转码"><a href="#二、ffmpeg转码" class="headerlink" title="二、ffmpeg转码"></a>二、ffmpeg转码</h3><p>接下来就是重点了，通过npm安装<code>fluent-ffmpeg</code>。</p>
<blockquote>
<p>注意，在安装fluent-ffmpeg之前，需要确认你的服务器环境中是否安装了<strong>ffmpeg</strong>这个工具，因为转码的核心其实就是通过 <strong>ffmpeg命令</strong> 转码，需要你通过在命令行里输入 <code>ffmpeg</code>  来确认安装。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glu89iqm70j31iw09mgt2.jpg" alt="image-20201220125133824"></p>
<p>不同的系统安装方法可查阅ffmpeg官网，最终只要确认环境变量里有ffmpeg就好了。这样就可以通过ffmpeg命令来对视频进行各种转码、编码操作。</p>
<p>而<code>fluent-ffmpeg</code>这个库类似语法糖，本质上就是通过nodejs在终端中执行ffmpeg的命令，它将繁琐的ffmpeg命令进行封装，转化成易于理解的链式调用，让我们不需要花费太多的时间去了解ffmpeg命令中琐碎的细节，只需通过封装好的一些显而易见的方法就可以操作视频转码。</p>
</blockquote>
<p>好了，直接上代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> WebSocket <span class="keyword">from</span> <span class="string">&#x27;ws&#x27;</span></span><br><span class="line"><span class="keyword">import</span> webSocketStream <span class="keyword">from</span> <span class="string">&#x27;websocket-stream/stream&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ffmpeg <span class="keyword">from</span> <span class="string">&#x27;fluent-ffmpeg&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立WebSocket服务</span></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">8888</span>, <span class="attr">perMessageDeflate</span>: <span class="literal">false</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接</span></span><br><span class="line">wss.on(<span class="string">&#x27;connection&#x27;</span>, handleConnection)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接时触发事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleConnection</span> (<span class="params">ws, req</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取前端请求的流地址（前端websocket连接时后面带上流地址）</span></span><br><span class="line">  <span class="keyword">const</span> url = req.url.slice(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 传入连接的ws客户端 实例化一个流</span></span><br><span class="line">  <span class="keyword">const</span> stream = webSocketStream(ws, &#123; <span class="attr">binary</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  <span class="comment">// 通过ffmpeg命令 对实时流进行格式转换 输出flv格式</span></span><br><span class="line">  <span class="keyword">const</span> ffmpegCommand = ffmpeg(url)</span><br><span class="line">    .addInputOption(<span class="string">&#x27;-analyzeduration&#x27;</span>, <span class="string">&#x27;100000&#x27;</span>, <span class="string">&#x27;-max_delay&#x27;</span>, <span class="string">&#x27;1000000&#x27;</span>)</span><br><span class="line">    .on(<span class="string">&#x27;start&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Stream started.&#x27;</span>) &#125;)</span><br><span class="line">    .on(<span class="string">&#x27;codecData&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Stream codecData.&#x27;</span>) &#125;)</span><br><span class="line">    .on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;An error occured: &#x27;</span>, err.message)</span><br><span class="line">      stream.end()</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Stream end!&#x27;</span>)</span><br><span class="line">      stream.end()</span><br><span class="line">    &#125;)</span><br><span class="line">    .outputFormat(<span class="string">&#x27;flv&#x27;</span>).videoCodec(<span class="string">&#x27;copy&#x27;</span>).noAudio()</span><br><span class="line"></span><br><span class="line">  stream.on(<span class="string">&#x27;close&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ffmpegCommand.kill(<span class="string">&#x27;SIGKILL&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行命令 传输到实例流中返回给客户端</span></span><br><span class="line">    ffmpegCommand.pipe(stream)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，简单的websocket和流转码服务就搭建好了，运行起来。如果后续投入生产环境时，也可以通过docker进行服务端部署，开机自运行。</p>
<h3 id="三、前端flv-js获取视频数据并渲染"><a href="#三、前端flv-js获取视频数据并渲染" class="headerlink" title="三、前端flv.js获取视频数据并渲染"></a>三、前端flv.js获取视频数据并渲染</h3><p>服务端搭建完，接下来就等前端连接服务器上的websocket，获取转码后的flv格式数据，然后渲染出来就行了。我们通过flv.js这个库来便捷的实现它。</p>
<blockquote>
<p>flv.js 是B站开源的一款纯js编写的HTML5 Flash Video（FLV）播放器，完全不需要Flash。</p>
<p>简单的说就是一款可以利用html5的video标签对flv格式数据进行实时播放的js版播放器。</p>
<p>原理大概就是获取到FLV格式的音视频数据后将 FLV 文件流转码复用成 ISO BMFF（MP4 碎片）片段，再通过Media Source Extensions API 传递给原生HTML5 Video标签进行播放。</p>
<p>所以从兼容性上说，支持Media Source Extensions的浏览器都是兼容flv.js的。而主流浏览器都是支持的，所以flv.js的兼容性是很不错的。</p>
</blockquote>
<p>安装flv.js，在vue中使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;wrap&quot;&gt;</span><br><span class="line">    &lt;video class&#x3D;&quot;video&quot; muted autoplay controls ref&#x3D;&quot;player&quot;&gt;&lt;&#x2F;video&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import flvjs from &#39;flv.js&#39; &#x2F;&#x2F; 引入flvjs</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      player: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果浏览器支持flvjs，则执行相应的程序</span><br><span class="line">    if (flvjs.isSupported()) &#123;</span><br><span class="line">      &#x2F;&#x2F; 准备监控设备流地址</span><br><span class="line">      const url &#x3D; &#39;rtsp:&#x2F;&#x2F;admin:1234567@192.168.1.100:554&#x2F;Streaming&#x2F;Channels&#x2F;101?transportmode&#x3D;unicast&#39;</span><br><span class="line">      &#x2F;&#x2F; 创建一个flvjs实例</span><br><span class="line">      &#x2F;&#x2F; 下面的ws:&#x2F;&#x2F;localhost:8888换成你搭建的websocket服务地址，后面加上设备流地址</span><br><span class="line">      this.player &#x3D; flvjs.createPlayer(&#123;</span><br><span class="line">        type: &#39;flv&#39;,</span><br><span class="line">        isLive: true,</span><br><span class="line">        url: &#39;ws:&#x2F;&#x2F;localhost:8888&#x2F;&#39; + url</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">      this.player.on(&#39;error&#39;, (e) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(e)</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">     &#x2F;&#x2F; 将实例挂载到video元素上面</span><br><span class="line">      this.player.attachMediaElement(this.$refs.player)</span><br><span class="line">      </span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F; 开始运行加载 只要流地址正常 就可以在h5页面中播放出画面了</span><br><span class="line">        this.player.load()</span><br><span class="line">        this.player.play()</span><br><span class="line">      &#125; catch (error) &#123;</span><br><span class="line">        console.log(error)</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy () &#123;</span><br><span class="line">    &#x2F;&#x2F; 页面销毁前 关闭flvjs</span><br><span class="line">    this.player.destroy()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;</span><br><span class="line">  .wrap&#123;</span><br><span class="line">    .video &#123;</span><br><span class="line">      width: 300px;</span><br><span class="line">      height: 300px;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>以上基本上实现了业务功能需求，运用到生产环境时，可进一步完善代码细节，测试各种异常情况，增加代码健壮性。</p>
<p>如果需要同时打开多个监控或直播画面，前端多实例化几个flvjs，挂载到video元素上即可。demo效果如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glv87mbthtj31fb0u07wh.jpg" alt="image-20201221093518005"></p>
<h3 id="四、方案总结"><a href="#四、方案总结" class="headerlink" title="四、方案总结"></a>四、方案总结</h3><p>这套方案主要的核心思路就是搭建服务端websocket服务并转码，客户端通过flv.js连接websocket并渲染画面。</p>
<p>优点有：</p>
<ol>
<li>不需要flash</li>
<li>可部署在本地环境中</li>
<li>兼容性良好</li>
<li>延迟较低，没有卡顿和花屏，CPU 占用率也不高</li>
<li>服务端和客户端全部js实现，适合大前端路线的开发者来实践</li>
</ol>
<p>以上就是在html5中播放rtsp流的一个方案，可实现监控、直播、播放视频等业务。</p>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>业务实践</tag>
      </tags>
  </entry>
  <entry>
    <title>卿本佳人，奈何从贼</title>
    <url>/2020/%E5%8D%BF%E6%9C%AC%E4%BD%B3%E4%BA%BA%EF%BC%8C%E5%A5%88%E4%BD%95%E4%BB%8E%E8%B4%BC.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><p>我姓史，名小宝，之所以叫史小宝，是因为我还有个哥哥，他叫史大宝。史家两个宝，一大一小，刚刚好。但我爹贪心不足，还想再养一个，名字都想好了，叫史多宝。</p>
<p>我爹说起这名字时把头仰起，显得洋洋得意。我娘随手拿起一根板凳腿，照我爹劈头盖脸就打：“叫你多宝！叫你多宝！”我爹抱着头吓得左闪右躲，上蹿下跳，忙喊：“不多了，不多了！别打！别打！”</p>
<a id="more"></a>

<p>其实也不怪我娘，在我家，十顿有八顿喝稀饭，特别是还有个四处惹祸的哥哥，简直操碎了她的心。村里人听到我哥的大名，无不闻风丧胆，大家都说，我哥是村中一害，堪比电视里的商纣、夏桀。其中尤以马大秃头最为痛恨。</p>
<p>马大秃头是村里的小学校长，也兼任班主任和语文老师，他这个人除了发型有点炫酷之外，还有一个显著的特点，就是爱给学生起绰号。</p>
<p>当年因为我哥的裤裆上总是破破烂烂的补丁，所以给我哥取了个史裤裆的绰号，惹恼了我哥，当天中午，我哥趁没人的时候，在他家门口挖了一个坑，往里面拉了一泡屎，用稀土和树叶掩盖上。马大秃头下午出门，一脚踩进去，脸瞬间绿到了脖子根。第二天，我哥又从他家快到学校的半路上挖了一个坑，让他扶着墙在学校门口抖了半天的腿，第三天马大秃头实在是怕了，决定不从必经之路上走，而改从小道绕，却被我哥所料定，早在一堆杂草中埋伏了兵马，在一声撕裂的惨叫后又悲壮的陷于马下。</p>
<p>想那马大秃头平时出门走路都是把双手背在后面，秃头扬的高高的，步伐何等优美，举止何等高雅，但是竟然连续三天，出门都踩到了屎，简直成了村里的一大笑柄，对于我哥更是谈之色变。</p>
<p>但我和我哥不一样，我是个乖巧懂事、聪明认真、乐善好施、仗义疏财的好孩子，虽然我今年才上小学三年级，但我已经是班里的山东及时雨、孝义黑二郎了。</p>
<p>特别是今天早上吃过早饭，有个算命瞎子经过我家门口，被我爹拉进去给我算了一卦，我当时正准备背着书包上学去，突然听到那瞎子把手一掐，黑眼珠子差点都吓回来了。</p>
<p>他大叫了一声：“哎呀！”我爹连忙问：“大师，怎么了？”他把胡子一摸，笑道：“你这二儿子不凡，正是天上的文曲星下凡啊！”我爹闻言大喜，说：“何以见得？”那瞎子把我的生辰八字一摆，说：“你看，文曲属水，北斗第四星，主科甲星，与你儿子的出生年干正好一一对应，天衣无缝啊。你这儿子以后写的文章可了不得啦！”</p>
<p>我躲在门外，听得心里直痒痒，妈的，原来我出身这么不凡，是天上的星星下凡，等会到班上一定要告诉陈三炮那个家伙，让他以后见到我都服服帖帖的。想到这，我飞一般的往学校跑。</p>
<p>陈三炮这个家伙是我的同桌，本名叫陈伟东，他家十顿有八顿都吃大米饭，养的白白胖胖的。三炮是他的绰号，正是由我们亲爱的班主任马大秃头所取。</p>
<p>那天上学的时候，陈三炮发现他的板凳坏了，坐不成了，眼看着还有一下午的课，我大手一挥，说，来，坐我这，于是分出了半个板凳给他。</p>
<p>在我们村，板凳都是学生自己从家里扛过来的，我的更是我爹亲自量了我屁股的尺寸打出的一个规范的样板，实在是没考虑到还有这么一天。陈三炮的屁股实在是太大了，我只得再退一点，把半边屁股都悬在了空中。</p>
<p>但如果仅仅这样也就算了，却不知道陈三炮中午吃了什么好东西，在上课文《在艰苦的岁月里》时，突然就开始放屁。恰恰这屁还放在马大秃头转身写字、全班沉默的间隙，不早不晚，不偏不倚，真是拿捏的恰到好处，好像生怕大家听不到似的。而且还是三响连环，璞！璞！璞！堪称屁音界之离骚，建校史来之绝唱，其气势恢宏，又如三道夺命飞镖，分别朝着三个方向疾射而出，瞬间在班级群豪间掀起了一股血雨腥风。</p>
<p>我悬着半边屁股正艰难的坐在板凳上，一时还没反应过来，只听见有三声暗响传来，屁股下的板凳被嘣的嗡嗡的作响，差点就从上面震了下来，班级里早已爆发出哄堂的笑声。</p>
<p>马大秃头转过身来，脸上笑成了一团麻花，他指着陈三炮，哈哈大笑，说：“你嘣坏了自己的凳子就算了，还去嘣人家的凳子……”同学们闻言更是笑的直拍桌子。于是，马大秃头亲自给他取了陈三炮这个绰号。</p>
<p> 我赶到了学校，刚才因为一直偷听瞎子算命过去了很长时间，上课铃已经打响，马大秃头搬着一沓方格本走上讲台，我没理他，直接跑到位子上。陈三炮在一旁说：“怎么现在才来？”</p>
<p> 我放下书包，得意洋洋的说：“等会告诉你个事。”我准备等到下课后再把这件事详细的告诉他。马大秃头在讲台开始讲课了。</p>
<p> “上次布置的作文大家总体上都写的不错，尤其是有一位同学，写的事情感人肺腑，情感真挚，写的非常好。”听到这句话，同学们都感觉虎躯一震，默默的在脑中把自己的作文代入进去，忐忑的等着老师说出自己的名字。</p>
<p>我自然也不例外。只是我瞪大眼睛在脑海中想了半天，都想不起来上个星期我的作文写的是什么玩意，只得作罢。</p>
<p>只见马大秃头把最上面一个方格本打开，笑着说：“这是我们的陈三炮同学写的作文，我读一下给大家听听。”</p>
<p>说着马大秃头摇头晃脑的，咳嗽一声，清理了下喉咙。</p>
<blockquote>
<p>“上个星期，我约了好朋友小明一起去山上玩，那天的天气十分晴朗，白云一朵朵的在天空飘，我们俩一会儿爬树，一会儿打鸟，玩的十分快乐。</p>
<p>就在这时，突然碰到了一个砍柴的老奶奶，年纪很大了，好朋友小明说：‘去别的地方玩吧。’我毅然的就拒绝了他。我走到老奶奶的身边，对她说：‘奶奶，我帮您砍柴吧！’老奶奶对我露出了高兴的笑容。</p>
<p>小明看到后十分惭愧，于是加入了我们队伍。我们砍了一下午柴，虽然很累，却觉得十分快乐。临走的时候，老奶奶问：‘小伙子，你叫什么名字啊？’我回头一笑：‘奶奶，我叫雷锋！’”</p>
</blockquote>
<p>当最后一句读完，全班鸦雀无声，片刻后爆发出雷鸣般的掌声。</p>
<p>马大秃头微笑着看着大家，满意的点了点头。这真的是一篇好文章，在大家现在大部分人还在写“我昨天去奶奶家玩，路上看到了三个狗，一个是黄的，一个是黑的，一个是灰的”的时候，陈三炮已经写帮老奶奶做好事并教育好朋友小明的故事了，特别是最后一句“老奶奶问，小伙子，你叫什么名字啊，奶奶，我叫雷锋”，这种态度谦虚、语言亲切、情感真挚的好句子简直狂甩那什么“路上看到三个狗”十八条街！</p>
<p>马大秃头很满意大家的神情，毫无保留的表扬了陈三炮，只是在最后稍微批评了一句：“三炮同学啊，虽说你的作文写得很好，但还有一点要提醒一下，打鸟是不对的。以后要注意了知道吗？”陈三炮站在位子上羞涩的点了点头。</p>
<p>我在心里的念头一下子变得翻江倒海，若是以前就还算了，但是就在早上，就在刚才，那算命的大师说我是星星下凡，写的文章必然非同凡响，我现在怎么就被陈三炮这种放屁震的板凳嗡嗡响的人压过去了呢，我觉得不能忍，实在是不能忍。</p>
<p>下课后我也没跟陈三炮公布我的真实身份。我回到家找我哥，我哥刚从镇上的高中回来了。</p>
<p>我问：“哥！我怎样才能写出好文章！”</p>
<p>我哥回来后变了很多，最明显的是他开始喜欢靠在墙上，低着头不说话，眼睛被长长的头发遮住，使我一时看不清他是不是靠在墙上睡着了。我哥头也不抬，淡淡的笑了一声，说：“小宝，你知道什么样的男人最受女生喜欢吗？”</p>
<p>我说：“什么样的呀？”</p>
<p>我哥把头一甩，露出了半截眼睛：“淡淡的微笑，淡淡的行走，还有……淡淡的忧伤！”</p>
<p>我一时愣住了，感到莫名其妙。</p>
<p>我哥长叹一口气，语重心长的说：“打个比方吧，就比如你想扣鼻屎，但你不能明目张胆的扣，要装作文雅淡定的把手指塞进鼻孔里，温柔的掏出鼻屎来，然后若无其事从容不迫的将它弹出去。”</p>
<p>我歪着脑袋想了一下：“那有时弹不掉呢？”</p>
<p>我哥说：“那就多弹几下嘛！”</p>
<p>“那跟你刚才说的什么淡淡的有什么关系？”</p>
<p>“就是告诉你做什么事都要保持淡然的态度。”</p>
<p>“哦！”我说。“那我怎样才能写出好文章？”</p>
<p> 我哥直起身来，把头又轻轻的一甩。“等我下次回来再告诉你吧。”说着双手插着兜，轻轻的走开了。</p>
<p>虽然我哥还没有跟我说怎么才能写好文章，但是我却把他弹鼻屎的理论牢记在心中，并在课堂上得到了很好的实践。每次我都趁马大秃头在黑板上写字的时候，悄悄的挖出一坨鼻屎，然后淡定的弹了出去。后来练到了指哪打哪、例无虚发的境界，江湖人送绰号：弹屎神通。</p>
<p>就这样过了一个星期后，我哥终于又回来了。我迫不及待的又追问我哥。我哥从书包里拿出一本书来，对我说：“要写好文章很简单，只要你有淡然的态度，再把这本书看完，就必然能写出不同凡响的文章来。”</p>
<p>我把书拿过来一看，上面写着两个大大的字“边城”，作者是沈从文。我说为什么是这个人，而不是鲁迅、列宁呢？</p>
<p>我哥摸着我的头，说：“小宝啊，你还小，不懂，大家都知道的人你说出去就显示不出你的学问，明白了吗？”我似懂非懂的点点头，说：“哦！”于是信心十足的阅读起来。</p>
<p>终于，我花了十几分钟，把这本书从头到尾看完了，看完之后，自觉功力大增。</p>
<p>特别是《边城》里的最后一句，“那个人也许永远不会回来了，也许明天回来”那种似懂非懂，莫名其妙的感觉简直狂甩“奶奶，我叫雷锋”十九条街。我想，这么好的一句话一定要用到作文里，那用到谁身上呢？对，这么好的句子一定要用到马大秃头身上，他看到自己被用了这么好的句子，一定会十分开心。</p>
<p>我倍感兴奋，开始迫不及待的翻开方格本，在第一行写上题目：我的老师。</p>
<p>接着我写道：</p>
<blockquote>
<p>“我有一个老师，他叫马老师，是我的好朋友马小福的爸爸。他不仅是老师，还是我们小学的校长，十分的厉害。</p>
<p>他是一个很慈祥的老师，每次上课都会亲切的看着我，十分的关心我。马老师不仅关心我，也关心我的同桌陈三炮，我们俩都十分的热爱他。</p>
<p>前几天马老师还跟大家说要去镇上面给大家买本子，我们听到了都十分开心。马老师去镇上买本子的这几天，大家都很怀念。不知道他什么时候回来呢？我想，那个人也许明天回来，也许永远也回不来了。”</p>
</blockquote>
<p>写到最后一句的时候，为了表示我不是照抄的，所以特意把前后调换了一下位置，还改了几个字，一下子就显示出了我的急才。</p>
<p>写完之后我感到十分满意，觉得我和沈从文的文采简直融为了一体，于是我把封面的姓名一栏用橡皮擦掉，给自己改了个名字，写上了“史从文”三个字。</p>
<p>第二天，我满怀期待的等着马大秃头在班上念我的作文。只见他面无表情的走进教室，瞟了我一眼，说：“史从文站起来！”我立马站起来：“到！”马大秃头看着我，冷笑一声，说：“史从文，倒是好名字，跟你哥一比，你真算是从良了。我看你不如就叫史从良吧。”</p>
<p>我们班上很多人还没能明白从良这种文雅的词是什么意思，但是看到马大秃头嘲讽的笑容，顿感是个好词，是个有意义的词，是比陈三炮更有炮轰力的词。一下课都跑过来喊，从良啊，走，一起上厕所去，从良啊，放学去掏鸟窝啊，从良啊，明天打方宝啊……仿佛不喊上那么几口就不配做我的同学似的。</p>
<p>陈三炮觉得自己的名头被抢了，在一旁嘟囔着说：“切，不就从良嘛，你从良了你就了不起啊。”</p>
<p>我本来还在暗恼马大秃头给我取得名字，听到陈三炮的话，一口气涌上来，把胸膛拍的震天响：“老子从良了就是了不起，不服单挑啊！”陈三炮一拍桌子，大怒：“单挑就单挑，谁怕谁啊！”</p>
<p> 于是我们约定，今天下午两点钟，在学校外的土场上进行生死决斗。</p>
<p>回到了家后，我渐渐冷静下来，陈三炮的身体肥大，力气强硬，我绝不是他的对手，但是战书都下了，再反悔了这口气我也咽不下，而且这还是关乎着我绰号的名誉而战，绝不能退缩，这一战一定要赢。我得想个办法。</p>
<p>我托着下巴开始想，想了好久却都想不到什么好办法，就在这时我猛然想到了我哥当年挖坑的主意……</p>
<p>中午，我草草的吃完了饭，趁着陈三炮还没来，在教室不远处的杏树林边一颗大槐树下，迅速的挖了一个坑，我憋了半天憋出一泡屎，然后盖上一层杏叶。为了防止到时候自己认错，我还特意搬来了一块巴掌大的石头放在坑边作为标记。</p>
<p> 终于一切准备妥当后，快两点了，我到土场上等陈三炮到来。不一会儿，他就出现了。我俩站在土场的两端，彼此对视，一动不动。</p>
<p>陈三炮说：“来吧！”我说：“行，不过我们不在这里打，不然等会要被同学们看到，我们去那边的杏树林里打。”一指杏树林。陈三炮说：“好！走。”于是我们俩肩并着肩朝那片树林走去。</p>
<p>到了林里，我俩对视一眼，陈三炮大喝一声，使出一招黑虎掏心，大喊：“降龙十八掌！”我二话不说，直接就往大槐树那跑。但是没想到跑的太急，一下子被树棍绊到了地上，眼看着陈三炮就冲了过来，我一咬牙，在地上滚了一圈站起来，抓住旁边一棵大树就爬了上去。</p>
<p>陈三炮跑到树下喊：“你下来。”</p>
<p>我说：“你上来。”</p>
<p>“你下来。”</p>
<p>“你上来。”</p>
<p> 没想到陈三炮还真的就要上来。</p>
<p>他伸开他肥胖的身体环抱着树干，双脚一蹬，就要往上爬。爬了一半时，不料“撕拉”一声，从腿跟到后腰的布料一下子被划破，露出了两瓣肥嘟嘟的大白屁股。</p>
<p>陈三炮脸色煞白，头使劲的朝屁股后面看，哭丧着脸，声音绝望：“等会还要上课啊……”我在树上正要下去安慰他，刚好看到远处马大秃头的儿子马小福朝这边走来。我对陈三炮说：“别急，有办法了。”说着跳下来在陈三炮耳边说了几句，然后躲到一颗大树后。</p>
<p>马小福走在路上，想着自己今天去哪里玩，是去山上掏鸟窝，还是抓泥鳅呢？这时突然听见有人喊他，忙抬头看过去，只见树林里陈三炮翘着光溜溜的屁股，手上托着几根零碎的布条，头一会儿朝屁股看，一会儿又朝自己看，顿时好奇心大起。</p>
<p>虽然想到那陈三炮和史小宝经常欺负自己，但是此刻那史小宝不在，眼前又有这么好奇的事情，怎么能不去看一下呢？</p>
<p>他慢慢的走到陈三炮跟前，还没待他看的仔细，陈三炮忽然把头从屁股后面转过来对他龇牙一笑。</p>
<p>马小福这辈子还没看到过如此风骚的一笑，狡黠、期盼、渴望、乃至一点点的娇羞……就在他反复回味之间，我已从大树后跳了出来，瞬间把他拦腰抱住，陈三炮二话不说上前就扒他的裤子。</p>
<p>马小福哇的一声哭出来，两条腿像风火轮一样乱踢。但是他再踢也阻住不了陈三炮扒裤子的决心，不到片刻功夫，就把马小福的裤子扒了下来。</p>
<p>我放开马小福，装作恶狠狠的说：“别哭！你找个地方待一下午，我们放学就把裤子还给你。你要是敢告状，哼哼！”马小福的嘴巴反翘成了月亮，脸上泪水不停的滚。旁边陈三炮已经把马小福的裤子换好。</p>
<p> “记住，先到没人的地方待一下午，放学后我们就到这里来还你裤子！”说完，我和陈三炮勾肩搭背着往学校走。</p>
<p>回到教室，没一会儿上课铃就打响了，马大秃头拿着书上课。就像往常一样，平静的上完一篇课文之后，他把书放下，说：“我来喊几个同学上黑板听写一下刚才学的字词。”</p>
<p>我和陈三炮对视一眼，微微感到一丝不妙。</p>
<p>由于黑板很高，每次上黑板的同学都会扛着凳子站上去。眼下陈三炮穿着马小福的裤子，坐在板凳上还看不出来，但是一旦上了黑板，还站在凳子上，被马大秃头看到岂不是暴露无遗！</p>
<p>我和陈三炮使劲向下低头，就差钻到桌子底下了，马大秃头在连续喊了两个同学之后，意外的看到我们，“陈三炮！史从良！”</p>
<p>我俩抬起头，脸色大变。我倒是还好，眼看着陈三炮坐在凳子上脸胀得通红，我一看不对，大喊一声：“三炮，快跑！”</p>
<p>陈三炮就像风一样拼命向外跑，马大秃头愣了一下，看着三炮肥硕的屁股渐渐远去，忽然醒悟过来，怒喝一声：“陈三炮，给老子站住！”说着提着棍子就追了出去。</p>
<p>我赶紧顺着他们的方向追赶，没跑多远，转到了杏树林，猛地停了下来。</p>
<p>在树林边，我中午寻找的大槐树上，陈三炮正死死抱着一根树枝不敢下来，树下，马大秃头一边扶着树干使劲抖腿，一边用手颤巍巍的指着陈三炮，气的说不出话来。</p>
<p>而那个放在屎坑边做标记的石头，早已经孤零零的躺在十米开外。</p>
<p>陈三炮见我来了，生怕我没看到马大秃头脚上的屎，大喊：“从良，从良，马老师踩到屎了！马老师踩到屎了！”</p>
<p>同学们从后面纷纷涌过来，闻言都叽叽喳喳的饱含着好奇。</p>
<p>“马老师踩到屎啦？！”</p>
<p>“马老师踩到屎了呀！”</p>
<p>“马老师踩到屎了哎！”</p>
<p>马大秃头抖着腿，一个哆嗦，差点摔到地上。</p>
<p>他回过头看着这群天真无邪的同学们，仿佛看到了他们下午放学回家，在晚上吃饭的时候，一个个把这个事情告诉他们家长，然后整个村子的人都知道了，今天晚上他们将会在洗碗洗脸和上床睡觉之前保持着高度的热忱一直谈论着此事，有人说不定还会在梦里笑着醒了过来……</p>
<p>第二天，马大秃头没有来上课。第三天，还是没有来。第四天，第五天……马大秃头什么时候回来呢？</p>
<p>那个人也许明天回来，也许永远不会回来了。</p>
<br/>

<p><font color="#999999">——写于2015年3月1日 大学</font></p>
]]></content>
      <categories>
        <category>写作</category>
      </categories>
      <tags>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title>从前慢</title>
    <url>/2020/%E4%BB%8E%E5%89%8D%E6%85%A2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><blockquote>
<p>从前的日色变得慢<br>车，马，邮件都慢<br>一生只够爱一个人</p>
</blockquote>
<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>明海把书放下，轻轻地闭上眼。</p>
<p>冬季的阳光照在院子里，照在躺椅上。明海爷爷在旁边劈好了柴，把刀扔在一边，擤了把鼻涕，站起身来。他回头看了看明海，脸上露出微笑，慢慢往厨屋里走。</p>
<a id="more"></a>

<p>鸡群在院落里伸脖子找食，明海爷爷经过时，惊的几只鸡瞪大眼睛，扑棱着翅膀慌忙往两边跑。明海睁开眼，看到水槽被一只奔跑的老母鸡掀翻，在地上打着圈，清水洒了一地。</p>
<p>堂屋的座钟传来悠长而古老的响声，铛……铛……，上午九点了。</p>
<p>明海眯着眼看天空，阳光并不刺眼，高大的松木在院墙外窜上来，直窜到树梢隐没在眼帘外，风吹了起来。</p>
<p>明海仰头看了一会儿，百无聊赖，便站起身，拿扫把扫院里的几摊鸡屎。</p>
<p>明海爷爷走进厨屋，在水缸里舀了一瓢水倒进脸盆。明海奶奶在锅台边炒饼心，顺手拿水瓢准备往锅里添水，一摸没摸到，转头看见明海爷爷，叫到：“要死了，老头子把我水瓢拿走了。”</p>
<p>嘴上说着话，手上的动作却不落下，一把大铲子灵活的在锅里左右翻动，磁……磁……不一会儿，一股浓郁的香味顺着烟雾就飘了出来。</p>
<p>明海爷爷把手放进水里，随意得搓了两下。水里漂出一些污垢，像小蝌蚪一样，甩动着尾巴，撒欢的往水底跑。明海爷爷的手很糙，比院外的那颗老松树皮还要糙，手心里沟壑纵横，老茧又厚又黄，每一道指关节的纹理间都深深嵌着不知名的黑色物质，怎么洗都洗不掉。它们嵌到了皮下，嵌到肉里，与血肉长成一块了。</p>
<p>洗了手，明海爷爷变得活泼起来，他把水泼到门外的沟里，花白的头朝外伸。</p>
<p>屋后，明海二爷爷家的大门半开着，里面传来几句热闹的笑声。还没等他听的真切，明海奶奶拿着铲子喝骂道:“老头子还不去把面粉搬过来！”明海爷爷回到屋里把脸盆放下，湿漉漉的双手在裤子上抹抹，有些悻悻地说：“这么急，还一下不歇了！”</p>
<p>当然这话明海奶奶是听不见的，因为明海奶奶的耳朵不太好，非得别人对着她的耳边大声的重复好几遍才能勉强听见。明海在院子里看着，感觉有些好笑。都这么多年了，两个人有时候还像个小孩子似的。</p>
<p>明海爷爷在屋里找了一圈没找到面粉，问明海奶奶：“面粉在哪？”</p>
<p>明海奶奶一边炒菜一边把头侧过来说：“什么呀？”</p>
<p>“面粉在哪？”</p>
<p>“你说什么？”</p>
<p>“我说面粉在哪？”</p>
<p>“啊？”</p>
<p>明海爷爷倒也不急，他张大了嘴，将多余的字都省了，嘴唇不紧不慢的做出口型，他喊：“面粉！面粉！”</p>
<p>这次明海奶奶终于听见了。“面粉哦。”她左手朝上一指：“面粉不在楼上晒着嘛！”</p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>明海奶奶的耳朵听不见已经好多年了，无论谁要跟她说话，都需要耐着些性子。有时即使在她耳边使劲喊也不大管用了，于是大家渐渐改为呼喊和做口型并重，同时配以一定的手势动作。</p>
<p>比如明海二爷爷来串门，问她吃过了没，就把嘴巴龇咧着，然后张大，露出“吃饭”的口型，同时右手假装拿着筷子，左手端饭碗，哗哗哗，做出扒饭的动作，嘴里使劲喊：“吃饭！吃饭！”这样做果然效果明显，明海奶奶一下子就懂了，说：“吃饭啊，问我吃饭了是吧，吃过了吃过了，早吃过了！”</p>
<p>但是接电话的时候可就没有口型和动作配合了，偏偏明海奶奶还喜欢和明海爷爷抢电话。就像昨天，明海在城里打电话回来，明海爷爷接起来说：“喂，谁呀？”</p>
<p>明海说:“我是海子。”在明海村里，喊晚辈名字都喜欢在最后一个字后面加“子”，就像桌子、椅子一样。</p>
<p>明海爷爷说：“哦，海子啊……”还没等他继续说，明海奶奶在一旁看到了，急忙跑过来说：“老头子，电话哦，谁呀，问一下是谁。”然后用围裙把手上的水擦擦，直接就夺过来。“来，我来！”</p>
<p>明海爷爷也不跟她抢，他对明海说：“给你奶奶了。”</p>
<p>明海奶奶拿过电话，将话筒郑重的贴在脸上，身子靠着床头，大声喊道：“喂，谁呀？你是谁呀？”</p>
<p>明海说：“我是海子！”</p>
<p>明海奶奶说：“谁呀，是不是海子？”</p>
<p>“是的，我是海子！”</p>
<p>“不是啊？你是哪个？是铃子吗”</p>
<p>“不是，我是海子！”</p>
<p>明海爷爷在一边一直使劲地说：“是海子！是海子呀！”</p>
<p>明海奶奶转过头看着明海爷爷：“谁呀？你说谁呀？是不是铃子，是铃子吧？”然后就对着听筒喊：“铃子啊，什么事啊？”</p>
<p>明海大声喊：“我是海子！海子！”明海爷爷也大声喊：“是海子！海子！”</p>
<p>“哦，是东子啊！”</p>
<p>就这样，爷孙俩一个在电话这边，一个在电话那边，同时喊海子喊了有两分钟，直到明海奶奶快把家里亲戚都猜完了，她自己都不耐烦了，然后把电话扔给明海爷爷。</p>
<p>“呐，老头子，给你接吧。”</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>明海爷爷到楼上很快搬来装着面粉的大木盆。</p>
<p>明海将柴抱到墙边的柴堆上摆整齐，然后去厨屋帮忙。</p>
<p>明海奶奶把水和面粉和在一起，边揉边嘟囔：“这老头子怎么不管事，面粉在哪都不知道！”明海将饼心从锅里盛起来装到盘子里，看了看爷爷，笑了笑，不说话。</p>
<p>明海爷爷在旁边摇摇头，叹一口气：“你奶奶耳朵聋，又有心脏病，高血压，她一生都性子强，不让着她怎么行呢……”</p>
<p>明海奶奶很快就把面团和好，笑眯眯的对明海说：“奶奶做糙面饼给你吃，中午吃糙面饼可好？”明海使劲的点头，这句话她上午已经说了五遍了，奶奶年纪越大越喜欢把一件小事不断的重复。</p>
<p>“家里做的饼可不像外面卖得，好吃哩！”明海奶奶又说。她从面团中拽出一小块来，伸出手指扒了一个口，用勺子舀了两勺饼心，然后把缺口合上，在手心里拍成一个圆状，啪啪两下，一个糙面饼就做好了。</p>
<p>饼下了锅，明海爷爷坐在锅台下往锅洞里添柴火。几根树枝塞进去，锅洞里烧的兴旺，噼里啪啦，火光映了出来。明海看见爷爷脸上红彤彤的一片，影子摇曳着。烟囱鼓鼓的往外冒。</p>
<p>十二点多，三个人把饭菜摆好，吃中饭了。</p>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>中饭后，明海爷爷和明海奶奶都闲下来了。冬天的庄稼地里没有活儿，明海奶奶端了个火盆，把手缩进围裙下面，靠在躺椅子上晒太阳。</p>
<p>明海爷爷双手蜷缩拢在袖子里，驼着背在院子里转悠，走到院门口时，时不时伸个头朝门外瞟。</p>
<p>明海奶奶看了一会，说：“老头子，别转了，你去玩吧！”</p>
<p>明海爷爷转过头，看着明海奶奶。</p>
<p>“下午也没事，去玩一会儿吧！”</p>
<p>明海爷爷朝门外又看了一眼，转过身，摇着头，说：“麻将有什么好玩的，不去哦。”</p>
<p>明海奶奶看到他摇头，笑着说：“不玩啊？”</p>
<p>“不玩。”</p>
<p>“不去啊？”</p>
<p>“不去。”</p>
<p>“那你干什么？”</p>
<p>“看电视！”</p>
<p>明海爷爷走到屋里，把电视打开。</p>
<p>没一会儿明海奶奶喊明海搬着躺椅也进来了。明海奶奶躺到上面，轻轻摇晃，“吱呀”——“吱呀”——，电视里老旦托着袖子咿呀呀唱着黄梅戏。</p>
<p>明海爷爷在床尾坐着，盯着屏幕看的认真。</p>
<p>明海奶奶说话了：“坐的这么近，眼睛不要了！”</p>
<p>明海爷爷就从床尾站起来，往后退几步，到床边靠着。</p>
<p>“再往后一点！”</p>
<p>明海爷爷就往后退一点。</p>
<p>“再往后一点！”</p>
<p>明海爷爷就又退了一点。</p>
<p>外面阳光照进来。</p>
<p>明海奶奶把明海爷爷的大棉袄裹的紧了一点，只露出了瘦小的脸庞，看着电视，不一会儿传来轻微的鼾声。明海爷爷半边屁股靠在床沿上，看戏看的入了神。</p>
<p>明海搬了个椅子坐在院子里，鸡群咯咯的叫。堂屋的座钟“铛……铛……铛……”地响了三声。</p>
<p>起风了。</p>
<br/>

<p><font color="#999999">——写于2015年1月29日 大学</font></p>
]]></content>
      <categories>
        <category>写作</category>
      </categories>
      <tags>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中url-loader新版本的坑（变化）</title>
    <url>/2020/webpack%E4%B8%ADurl-loader%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E5%9D%91%EF%BC%88%E5%8F%98%E5%8C%96%EF%BC%89.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>之前在进行webpack配置练习过程中遇到了一个坑，花了2个小时才搞定，挺有感触，以记之。</p>
<p>webpack有几个核心概念，其中一个是loader。</p>
<p>loader其实就是用于对模块的源代码进行转换，如TypeScript转换为 JavaScript，sass转成css等，就要安装相对应的 loader。</p>
<p>其中有几个常用的loader如下：</p>
<ul>
<li>处理图片、字体等文件<code>file-loader</code>或者<code>url-loader</code>。（file-loader可以对图片、字体等文件进行打包，url-loader是基于file-loader进行的一层封装，可以将限制在大小以内的图片文件转成base64格式，减少图片请求）</li>
<li>处理vue文件<code>vue-loader</code>（详见vue-loader文档）</li>
<li>处理css文件<code>css-loader</code>、<code>style-loader</code></li>
<li>处理scss文件<code>sass-loader</code>、<code>node-sass</code></li>
<li>处理vue文件里的style <code>vue-style-loader</code></li>
<li>css预处理<code>postcss-loader</code></li>
<li>…</li>
</ul>
<h3 id="url-loader新版本的坑"><a href="#url-loader新版本的坑" class="headerlink" title="url-loader新版本的坑"></a>url-loader新版本的坑</h3><p>我把将图片和字体资源放进项目，根据webpack的官方文档介绍安装了<code>file-loader</code>和<code>url-loader</code>，进行配置并加载，此时出问题了。</p>
<p>通过<code>file-loader</code>加载的字体正常，<strong>而通过<code>url-loader</code>加载的图片却出不来。</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gai032c55hj30pu082t9c.jpg" alt="image-20200101214727561"></p>
<p>开始以为是配置出的错误，经过反复的尝试修改，结果一无所获。</p>
<p>于是去网上找了一个别人的webpack相关项目拉下来运行，但很奇怪的是， <strong>url-loader</strong>相关的配置，大家基本都差不多按文档来的，那为啥别人的图片就能运行成功，到我这里就加载失败了？</p>
<h3 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h3><p>经过反复的比对分析，一点点排除错误因素，终于找到了问题所在——<code>url-loader</code>版本问题。</p>
<p>通过npm-check-updates，我检查到package.json里面的版本变化：</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gai03k9m3oj30pu0f875y.jpg" alt="image-20200101221638094"></p>
<p>这里面最大的变化就是<code>file-loader</code>和<code>url-loader</code>，是一个大版本的更新。</p>
<p>但是项目中字体解析正常，那么<strong>问题很可能就出在<code>url-loader</code>上。</strong></p>
<p>于是我去github上查看<code>url-loader</code>的更新日志，看看都更新了什么，结果看到了这个：</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gai03qz5hkj31240h0whb.jpg" alt="image-20200101222340289"></p>
<p>翻译过来就是：</p>
<ul>
<li>最低要求的nodejs版本是10.13.0</li>
<li>将esModules选项重命名为esModule</li>
<li>默认情况下切换到ES模块（<strong>默认情况下，esModule选项为true</strong>）</li>
</ul>
<p>那么一切就水落石出了：最新版本的 <code>url-loader</code> 添加了一个新的配置选择 <strong>esModule</strong>。</p>
<p>如果不设置 <strong>esModule</strong> 为 <strong>false</strong>，那么默认它会将图片导出一个module对象，而不是一个url路径，所以此时页面图片当然加载不出来了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js </span></span><br><span class="line"><span class="comment">// 入口文件 引入图片和logo</span></span><br><span class="line"><span class="keyword">const</span> happy = <span class="built_in">require</span>(<span class="string">&#x27;./happy.jpg&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> logo = <span class="built_in">require</span>(<span class="string">&#x27;./logo.png&#x27;</span>)</span><br><span class="line"><span class="comment">// 注: url-loader在3.0.0版本有重大改变</span></span><br><span class="line"><span class="comment">// 需在webpack.config.js里添加 esModule: false</span></span><br><span class="line"><span class="comment">// 否则打印出来的happy是个module对象，不是一个url路径</span></span><br><span class="line"><span class="built_in">console</span>.log(happy)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 加载图片</span></span><br><span class="line">    test: <span class="regexp">/\.(png|jpg|gif|svg)$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: <span class="number">5</span> * <span class="number">1024</span>,</span><br><span class="line">          name: <span class="string">&#x27;images/[name].[ext]&#x27;</span>,</span><br><span class="line">          <span class="comment">// 如果要在图片的src里使用，这里要添加esModule属性，默认是true，需要设置成false</span></span><br><span class="line">          esModule: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>注：而<strong>关于<code>url-loader</code>最近的这次更新，webpack中文文档上面并没有同步更新</strong>，仍然只有以前的三个options配置选项，我去翻英文文档，才发现它更新了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>不仅仅是webpack，许多项目的中文文档都不是及时更新的，有一定的滞后性，要习惯看英文文档，看英文文档，看英文文档！！！</strong></li>
<li>爬坑的过程，也是快速深入学习的过程，爬完之后对webpack相关配置理解了很多。</li>
</ul>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
</search>
