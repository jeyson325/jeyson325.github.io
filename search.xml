<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Vue中transition过渡组件全掌握</title>
    <url>/2021/Vue%E4%B8%ADtransition%E8%BF%87%E6%B8%A1%E7%BB%84%E4%BB%B6%E5%85%A8%E6%8E%8C%E6%8F%A1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6804a1350b9b4b7cae6fce6803ac6d55~tplv-k3u1fbpfcp-zoom-1.image" alt="view4"></p>
<p>在冷冰冰的网页上，加上些许过渡或动画，其变化虽小，却能极大的提升页面质感，给人一种顺畅、丝滑的视觉体验。它的实现过程主要是通过css中的<code>transition</code>和<code>animation</code>来实现的。</p>
<a id="more"></a>

<p>而在vue框架中也对此进行了封装，提供了便捷的过渡用法。</p>
<h3 id="1、transition组件用法"><a href="#1、transition组件用法" class="headerlink" title="1、transition组件用法"></a>1、transition组件用法</h3><p>在业务开发过程中，最常用的还是transition组件的用法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;slide-fade&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;show&quot;</span>&gt;</span> hello world <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 可以设置不同的进入和离开动画 */</span></span><br><span class="line"><span class="comment">/* 设置持续时间和动画函数 */</span></span><br><span class="line"><span class="selector-class">.slide-fade-enter-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all .<span class="number">3s</span> ease;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.slide-fade-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all .<span class="number">8s</span> <span class="built_in">cubic-bezier</span>(<span class="number">1.0</span>, <span class="number">0.5</span>, <span class="number">0.8</span>, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.slide-fade-enter</span>, <span class="selector-class">.slide-fade-leave-to</span></span><br><span class="line">  <span class="selector-tag">transform</span>: <span class="selector-tag">translateX</span>(10<span class="selector-tag">px</span>);</span><br><span class="line">  <span class="selector-tag">opacity</span>: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进入/离开的过渡中，主要有 6 个 钩子被触发，并对应6个class 切换。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18c2e6475de64fe08c67647395f1a4bf~tplv-k3u1fbpfcp-zoom-1.image" alt="状态过渡变化"></p>
<p>如果你的<code>transition</code>组件没有设置<code>name</code>属性，则 <code>v-</code> 是这些类名的默认前缀。如果你使用了<code>&lt;transition name=&quot;my-transition&quot;&gt;</code> ，那么 <code>v-enter</code> 会替换为 <code>my-transition-enter</code>。</p>
<p>这6种class类名可以自定义，他们的优先级高于普通的类名：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;slide-fade&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">enter-active-class</span>=<span class="string">&quot;custom-enter-active-class&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">leave-active-class</span>=<span class="string">&quot;custom-leave-active-class&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;show&quot;</span>&gt;</span> hello world <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* css部分 */</span></span><br><span class="line"><span class="selector-class">.custom-enter-active-class</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: bounce-in .<span class="number">5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.custom-leave-active-class</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: bounce-in .<span class="number">5s</span> reverse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> bounce-in &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  50% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.5</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当有<strong>相同标签名</strong>的元素切换时，推荐<strong>在 <code>&lt;transition&gt;</code> 组件中的多个元素设置 key</strong> 让vue区分它们</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-if</span>=<span class="string">&quot;isEditing&quot;</span> <span class="attr">key</span>=<span class="string">&quot;save&quot;</span>&gt;</span></span><br><span class="line">    Save</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-else</span> <span class="attr">key</span>=<span class="string">&quot;edit&quot;</span>&gt;</span></span><br><span class="line">    Edit</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>该例子可以用key不同的值代替<code>v-if</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">:key</span>=<span class="string">&quot;isEditing&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; isEditing ? &#x27;Save&#x27; : &#x27;Edit&#x27; &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>另外在不同组件中切换过渡：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;component-fade&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;out-in&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;view&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">    	view: <span class="string">&#x27;v-a&#x27;</span></span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">&#x27;v-a&#x27;</span>: &#123;</span><br><span class="line">      template: <span class="string">&#x27;&lt;div&gt;Component A&lt;/div&gt;&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;v-b&#x27;</span>: &#123;</span><br><span class="line">      template: <span class="string">&#x27;&lt;div&gt;Component B&lt;/div&gt;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，上述两个组件的进入和离开是同时发生的，一个离开过渡的时候另一个开始进入过渡，只有离开的组件完成动画之后，才会把位置让出来，通常这会造成一种卡顿的效果（<strong>如果两个元素都设置了绝对定位，则没有这个问题</strong>）。</p>
<p>可以通过添加<strong>过渡模式mode</strong>来满足我们的需求：</p>
<ul>
<li><code>in-out</code>：新元素先进行过渡，完成之后当前元素过渡离开。</li>
<li><code>out-in</code>：当前元素先进行过渡，完成之后新元素过渡进入。</li>
</ul>
<p>通常我们更多的会使用<code>out-in</code>，让当前元素先离开，然后再进行新元素的进入。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;fade&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;out-in&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 不同元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>了解了以上的用法，基本就可以实现大部分业务场景了。</p>
<h3 id="2、使用JavaScript动态过渡"><a href="#2、使用JavaScript动态过渡" class="headerlink" title="2、使用JavaScript动态过渡"></a>2、使用JavaScript动态过渡</h3><p>在大部分场景下，我们主要是使用css来进行过渡，css已经前置写好了，但在某些情况下，我们还需要动态过渡。</p>
<p>动态过渡最基本的操作就是绑定动态属性，比如<code>name</code>，当有不同的情况时切换不同的过渡效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">:name</span>=<span class="string">&quot;transitionName&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>不过这同样需要我们提前写好对应的过渡效果，除此之外，最直接的实现动态过渡的方式是使用JavaScript过渡：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">before-enter</span>=<span class="string">&quot;beforeEnter&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">enter</span>=<span class="string">&quot;enter&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">after-enter</span>=<span class="string">&quot;afterEnter&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">enter-cancelled</span>=<span class="string">&quot;enterCancelled&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">  @<span class="attr">before-leave</span>=<span class="string">&quot;beforeLeave&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">leave</span>=<span class="string">&quot;leave&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">after-leave</span>=<span class="string">&quot;afterLeave&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">leave-cancelled</span>=<span class="string">&quot;leaveCancelled&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  <span class="comment">// 过渡进入之前触发</span></span><br><span class="line">  beforeEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123; &#125;,</span><br><span class="line">  <span class="comment">// 过渡进入时触发</span></span><br><span class="line">  enter: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 当与 CSS 结合使用时，回调函数 done 是可选的</span></span><br><span class="line">    <span class="comment">// 不用CSS过渡，设置了:css=&quot;false&quot;，则必须使用回调done </span></span><br><span class="line">    done()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 过渡进入结束时触发</span></span><br><span class="line">  afterEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123; &#125;,</span><br><span class="line">  <span class="comment">// 过渡进入被取消时触发</span></span><br><span class="line">  enterCancelled: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123; &#125;,</span><br><span class="line">	<span class="comment">// 在离开之前触发</span></span><br><span class="line">  beforeLeave: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123; &#125;,</span><br><span class="line">  <span class="comment">// 离开时触发</span></span><br><span class="line">  leave: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 当与 CSS 结合使用，回调函数 done 是可选的</span></span><br><span class="line">    <span class="comment">// 不用CSS过渡，设置了:css=&quot;false&quot;，则必须使用回调done </span></span><br><span class="line">    done()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 离开后触发</span></span><br><span class="line">  afterLeave: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123; &#125;,</span><br><span class="line">  <span class="comment">// 离开过程被取消时触发（只用于 v-show 中）</span></span><br><span class="line">  leaveCancelled: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这些JavaScript过渡钩子可以和 CSS <code>transitions/animations</code> 同时使用，也可以单独使用。</p>
<p>不过<strong>既然你都使用了 JavaScript 过渡，那么推荐就不用CSS过渡，元素添加 <code>v-bind:css=&quot;false&quot;</code>，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响</strong>。</p>
<p>如这个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Velocity 和 jQuery.animate 的工作方式类似，也是用来实现 JavaScript 动画的一个很棒的选择 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-4&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;show = !show&quot;</span>&gt;</span></span><br><span class="line">    Toggle</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">transition</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">before-enter</span>=<span class="string">&quot;beforeEnter&quot;</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">enter</span>=<span class="string">&quot;enter&quot;</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">leave</span>=<span class="string">&quot;leave&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:css</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;show&quot;</span>&gt;</span></span><br><span class="line">      Demo</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example-4&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    show: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 钩子函数里写具体的过渡数据，可以实现js动态控制</span></span><br><span class="line">    beforeEnter: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">      el.style.opacity = <span class="number">0</span></span><br><span class="line">      el.style.transformOrigin = <span class="string">&#x27;left&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    enter: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</span><br><span class="line">      Velocity(el, &#123; <span class="attr">opacity</span>: <span class="number">1</span>, <span class="attr">fontSize</span>: <span class="string">&#x27;1.4em&#x27;</span> &#125;, &#123; <span class="attr">duration</span>: <span class="number">300</span> &#125;)</span><br><span class="line">      Velocity(el, &#123; <span class="attr">fontSize</span>: <span class="string">&#x27;1em&#x27;</span> &#125;, &#123; <span class="attr">complete</span>: done &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    leave: <span class="function"><span class="keyword">function</span> (<span class="params">el, done</span>) </span>&#123;</span><br><span class="line">      Velocity(el, &#123; <span class="attr">translateX</span>: <span class="string">&#x27;15px&#x27;</span>, <span class="attr">rotateZ</span>: <span class="string">&#x27;50deg&#x27;</span> &#125;, &#123; <span class="attr">duration</span>: <span class="number">600</span> &#125;)</span><br><span class="line">      Velocity(el, &#123; <span class="attr">rotateZ</span>: <span class="string">&#x27;100deg&#x27;</span> &#125;, &#123; <span class="attr">loop</span>: <span class="number">2</span> &#125;)</span><br><span class="line">      Velocity(el, &#123;</span><br><span class="line">        rotateZ: <span class="string">&#x27;45deg&#x27;</span>,</span><br><span class="line">        translateY: <span class="string">&#x27;30px&#x27;</span>,</span><br><span class="line">        translateX: <span class="string">&#x27;30px&#x27;</span>,</span><br><span class="line">        opacity: <span class="number">0</span></span><br><span class="line">      &#125;, &#123; <span class="attr">complete</span>: done &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="3、初始渲染appear"><a href="#3、初始渲染appear" class="headerlink" title="3、初始渲染appear"></a>3、初始渲染appear</h3><p>上述过渡的用法通常需要元素或者组件有变化才会触发，如需要<code>v-if</code>、<code>v-show</code>、<code>动态组件</code>等。</p>
<p>如果你的需求是第一次进页面的时候，它就过渡渲染出来，之后是不需要再过渡的，那可以使用<code>appear</code>这个属性。如下面这个示例：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16557ad5478a411787323d10ab20c8b5~tplv-k3u1fbpfcp-zoom-1.image" alt="view2"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- appear 也可以自定义 CSS 类名 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">appear</span></span></span><br><span class="line"><span class="tag">            <span class="attr">appear-class</span>=<span class="string">&quot;custom-appear-class&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">appear-active-class</span>=<span class="string">&quot;custom-appear-active-class&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">appear-to-class</span>=<span class="string">&quot;custom-appear-to-class&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一段测试appear初始渲染文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.custom-appear-class</span>&#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.custom-appear-active-class</span>&#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">3s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.custom-appear-to-class</span>&#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>appear</code>和<code>enter</code>有点像，但它只在初始渲染的时候触发，并且只要把触发之前和触发之后的状态设置不同，便可以实现中间的自然过渡。</p>
<p>同时，它也可以用JavaScript钩子函数实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">appear</span> </span></span><br><span class="line"><span class="tag">            @<span class="attr">before-appear</span>=<span class="string">&quot;customBeforeAppearHook&quot;</span></span></span><br><span class="line"><span class="tag">            @<span class="attr">appear</span>=<span class="string">&quot;customAppearHook&quot;</span></span></span><br><span class="line"><span class="tag">            @<span class="attr">after-appear</span>=<span class="string">&quot;customAfterAppearHook&quot;</span></span></span><br><span class="line"><span class="tag">            @<span class="attr">appear-cancelled</span>=<span class="string">&quot;customAppearCancelledHook&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="4、列表过渡和v-move"><a href="#4、列表过渡和v-move" class="headerlink" title="4、列表过渡和v-move"></a>4、列表过渡和v-move</h3><p>同一时间内渲染单个节点，或者多个节点中的一个，使用<code>&lt;transition&gt;</code>组件，如果同时渲染多个节点，比如整个列表，则需要用<code>&lt;transition-group&gt;</code>组件，该组件有几个特点：</p>
<ul>
<li>不同于 <code>&lt;transition&gt;</code>，它会以一个真实元素呈现：默认为一个 <code>&lt;span&gt;</code>。可以通过 <code>tag</code> 属性更换为其他元素。</li>
<li>列表渲染中没有过渡模式。</li>
<li>内部元素必须要提供<code>key</code>值。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置tag属性为p元素，v-for中的每一项设置key值 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- items为一个连续数字组成的数组 [0, 1, 2, ...] --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transition-group</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;p&quot;</span> <span class="attr">class</span>=<span class="string">&quot;list-item&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">     &#123;&#123; item &#125;&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list-item</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list-enter-active</span>, <span class="selector-class">.list-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list-enter</span>, <span class="selector-class">.list-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">30px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc3ab1c6c0f944e0bd9a0e6fef5efb84~tplv-k3u1fbpfcp-zoom-1.image" alt="view3"></p>
<p>效果如上，但是这有一个问题：当添加和移除元素的时候，周围的元素会瞬间移动到他们的新布局的位置，有一种卡顿的感觉。</p>
<p>要解决这个问题可以通过<code>&lt;transition-group&gt;</code>组件中的 <strong><code>v-move</code></strong> class，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 <code>name</code> attribute 来自定义前缀，也可以通过 <code>move-class</code> attribute 手动设置。</p>
<p>于是只要在上面的例子中修改一下css：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.list-item</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 这里增加和一个.list-move类样式，它会在元素改变的过程中生效 */</span></span><br><span class="line"><span class="selector-class">.list-move</span>&#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list-enter-active</span>, <span class="selector-class">.list-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 这里在元素离开时增加一个绝对定位属性 */</span></span><br><span class="line"><span class="comment">/* 这样元素离开的瞬间就会触发改变位置，使上面的.list-move生效 */</span></span><br><span class="line"><span class="comment">/* 如果不加绝对定位，则元素离开动作完成后周围的元素才会移动到它的位置 */</span></span><br><span class="line"><span class="comment">/* 而那个时候所有过渡已结束 .list-move已经被移除，会造成卡顿感觉 */</span></span><br><span class="line"><span class="selector-class">.list-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list-enter</span>, <span class="selector-class">.list-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">30px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6804a1350b9b4b7cae6fce6803ac6d55~tplv-k3u1fbpfcp-zoom-1.image" alt="view4"></p>
<p>如此就有了一种丝滑的感觉，另外上述css可进一步修改简化：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 直接在元素上增加transition属性 */</span></span><br><span class="line"><span class="comment">/* 它会在元素改变的所有过程中生效，包括v-move的时候 */</span></span><br><span class="line"><span class="selector-class">.list-item</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 因此v-move和v-active相关的均可不需要了 */</span></span><br><span class="line"><span class="comment">/* 只要在元素离开时增加一个绝对定位属性即可 */</span></span><br><span class="line"><span class="selector-class">.list-leave-active</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.list-enter</span>, <span class="selector-class">.list-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">30px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：v-move的内部实现，Vue 使用了一个叫 <a href="https://aerotwist.com/blog/flip-your-animations/">FLIP</a> 简单的动画队列。</p>
<p><strong>使用 FLIP 过渡的元素不能设置为 <code>display: inline</code> 。</strong></p>
<p><strong>所以可以设置为 <code>display: inline-block</code> 或者放置于 flex 中。</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中url-loader新版本的坑（变化）</title>
    <url>/2020/webpack%E4%B8%ADurl-loader%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E5%9D%91%EF%BC%88%E5%8F%98%E5%8C%96%EF%BC%89.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>之前在进行webpack配置练习过程中遇到了一个坑，花了2个小时才搞定，挺有感触，以记之。</p>
<p>webpack有几个核心概念，其中一个是loader。</p>
<p>loader其实就是用于对模块的源代码进行转换，如TypeScript转换为 JavaScript，sass转成css等，就要安装相对应的 loader。</p>
<p>其中有几个常用的loader如下：</p>
<ul>
<li>处理图片、字体等文件<code>file-loader</code>或者<code>url-loader</code>。（file-loader可以对图片、字体等文件进行打包，url-loader是基于file-loader进行的一层封装，可以将限制在大小以内的图片文件转成base64格式，减少图片请求）</li>
<li>处理vue文件<code>vue-loader</code>（详见vue-loader文档）</li>
<li>处理css文件<code>css-loader</code>、<code>style-loader</code></li>
<li>处理scss文件<code>sass-loader</code>、<code>node-sass</code></li>
<li>处理vue文件里的style <code>vue-style-loader</code></li>
<li>css预处理<code>postcss-loader</code></li>
<li>…</li>
</ul>
<h3 id="url-loader新版本的坑"><a href="#url-loader新版本的坑" class="headerlink" title="url-loader新版本的坑"></a>url-loader新版本的坑</h3><p>我把将图片和字体资源放进项目，根据webpack的官方文档介绍安装了<code>file-loader</code>和<code>url-loader</code>，进行配置并加载，此时出问题了。</p>
<p>通过<code>file-loader</code>加载的字体正常，<strong>而通过<code>url-loader</code>加载的图片却出不来。</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gai032c55hj30pu082t9c.jpg" alt="image-20200101214727561"></p>
<p>开始以为是配置出的错误，经过反复的尝试修改，结果一无所获。</p>
<p>于是去网上找了一个别人的webpack相关项目拉下来运行，但很奇怪的是， <strong>url-loader</strong>相关的配置，大家基本都差不多按文档来的，那为啥别人的图片就能运行成功，到我这里就加载失败了？</p>
<h3 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h3><p>经过反复的比对分析，一点点排除错误因素，终于找到了问题所在——<code>url-loader</code>版本问题。</p>
<p>通过npm-check-updates，我检查到package.json里面的版本变化：</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gai03k9m3oj30pu0f875y.jpg" alt="image-20200101221638094"></p>
<p>这里面最大的变化就是<code>file-loader</code>和<code>url-loader</code>，是一个大版本的更新。</p>
<p>但是项目中字体解析正常，那么<strong>问题很可能就出在<code>url-loader</code>上。</strong></p>
<p>于是我去github上查看<code>url-loader</code>的更新日志，看看都更新了什么，结果看到了这个：</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gai03qz5hkj31240h0whb.jpg" alt="image-20200101222340289"></p>
<p>翻译过来就是：</p>
<ul>
<li>最低要求的nodejs版本是10.13.0</li>
<li>将esModules选项重命名为esModule</li>
<li>默认情况下切换到ES模块（<strong>默认情况下，esModule选项为true</strong>）</li>
</ul>
<p>那么一切就水落石出了：最新版本的 <code>url-loader</code> 添加了一个新的配置选择 <strong>esModule</strong>。</p>
<p>如果不设置 <strong>esModule</strong> 为 <strong>false</strong>，那么默认它会将图片导出一个module对象，而不是一个url路径，所以此时页面图片当然加载不出来了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js </span></span><br><span class="line"><span class="comment">// 入口文件 引入图片和logo</span></span><br><span class="line"><span class="keyword">const</span> happy = <span class="built_in">require</span>(<span class="string">&#x27;./happy.jpg&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> logo = <span class="built_in">require</span>(<span class="string">&#x27;./logo.png&#x27;</span>)</span><br><span class="line"><span class="comment">// 注: url-loader在3.0.0版本有重大改变</span></span><br><span class="line"><span class="comment">// 需在webpack.config.js里添加 esModule: false</span></span><br><span class="line"><span class="comment">// 否则打印出来的happy是个module对象，不是一个url路径</span></span><br><span class="line"><span class="built_in">console</span>.log(happy)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line">rules: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 加载图片</span></span><br><span class="line">    test: <span class="regexp">/\.(png|jpg|gif|svg)$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">      &#123;</span><br><span class="line">        loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: <span class="number">5</span> * <span class="number">1024</span>,</span><br><span class="line">          name: <span class="string">&#x27;images/[name].[ext]&#x27;</span>,</span><br><span class="line">          <span class="comment">// 如果要在图片的src里使用，这里要添加esModule属性，默认是true，需要设置成false</span></span><br><span class="line">          esModule: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>注：而<strong>关于<code>url-loader</code>最近的这次更新，webpack中文文档上面并没有同步更新</strong>，仍然只有以前的三个options配置选项，我去翻英文文档，才发现它更新了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>不仅仅是webpack，许多项目的中文文档都不是及时更新的，有一定的滞后性，要习惯看英文文档，看英文文档，看英文文档！！！</strong></li>
<li>爬坑的过程，也是快速深入学习的过程，爬完之后对webpack相关配置理解了很多。</li>
</ul>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>从前慢</title>
    <url>/2020/%E4%BB%8E%E5%89%8D%E6%85%A2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><blockquote>
<p>从前的日色变得慢<br>车，马，邮件都慢<br>一生只够爱一个人</p>
</blockquote>
<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>明海把书放下，轻轻地闭上眼。</p>
<p>冬季的阳光照在院子里，照在躺椅上。明海爷爷在旁边劈好了柴，把刀扔在一边，擤了把鼻涕，站起身来。他回头看了看明海，脸上露出微笑，慢慢往厨屋里走。</p>
<a id="more"></a>

<p>鸡群在院落里伸脖子找食，明海爷爷经过时，惊的几只鸡瞪大眼睛，扑棱着翅膀慌忙往两边跑。明海睁开眼，看到水槽被一只奔跑的老母鸡掀翻，在地上打着圈，清水洒了一地。</p>
<p>堂屋的座钟传来悠长而古老的响声，铛……铛……，上午九点了。</p>
<p>明海眯着眼看天空，阳光并不刺眼，高大的松木在院墙外窜上来，直窜到树梢隐没在眼帘外，风吹了起来。</p>
<p>明海仰头看了一会儿，百无聊赖，便站起身，拿扫把扫院里的几摊鸡屎。</p>
<p>明海爷爷走进厨屋，在水缸里舀了一瓢水倒进脸盆。明海奶奶在锅台边炒饼心，顺手拿水瓢准备往锅里添水，一摸没摸到，转头看见明海爷爷，叫到：“要死了，老头子把我水瓢拿走了。”</p>
<p>嘴上说着话，手上的动作却不落下，一把大铲子灵活的在锅里左右翻动，磁……磁……不一会儿，一股浓郁的香味顺着烟雾就飘了出来。</p>
<p>明海爷爷把手放进水里，随意得搓了两下。水里漂出一些污垢，像小蝌蚪一样，甩动着尾巴，撒欢的往水底跑。明海爷爷的手很糙，比院外的那颗老松树皮还要糙，手心里沟壑纵横，老茧又厚又黄，每一道指关节的纹理间都深深嵌着不知名的黑色物质，怎么洗都洗不掉。它们嵌到了皮下，嵌到肉里，与血肉长成一块了。</p>
<p>洗了手，明海爷爷变得活泼起来，他把水泼到门外的沟里，花白的头朝外伸。</p>
<p>屋后，明海二爷爷家的大门半开着，里面传来几句热闹的笑声。还没等他听的真切，明海奶奶拿着铲子喝骂道:“老头子还不去把面粉搬过来！”明海爷爷回到屋里把脸盆放下，湿漉漉的双手在裤子上抹抹，有些悻悻地说：“这么急，还一下不歇了！”</p>
<p>当然这话明海奶奶是听不见的，因为明海奶奶的耳朵不太好，非得别人对着她的耳边大声的重复好几遍才能勉强听见。明海在院子里看着，感觉有些好笑。都这么多年了，两个人有时候还像个小孩子似的。</p>
<p>明海爷爷在屋里找了一圈没找到面粉，问明海奶奶：“面粉在哪？”</p>
<p>明海奶奶一边炒菜一边把头侧过来说：“什么呀？”</p>
<p>“面粉在哪？”</p>
<p>“你说什么？”</p>
<p>“我说面粉在哪？”</p>
<p>“啊？”</p>
<p>明海爷爷倒也不急，他张大了嘴，将多余的字都省了，嘴唇不紧不慢的做出口型，他喊：“面粉！面粉！”</p>
<p>这次明海奶奶终于听见了。“面粉哦。”她左手朝上一指：“面粉不在楼上晒着嘛！”</p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>明海奶奶的耳朵听不见已经好多年了，无论谁要跟她说话，都需要耐着些性子。有时即使在她耳边使劲喊也不大管用了，于是大家渐渐改为呼喊和做口型并重，同时配以一定的手势动作。</p>
<p>比如明海二爷爷来串门，问她吃过了没，就把嘴巴龇咧着，然后张大，露出“吃饭”的口型，同时右手假装拿着筷子，左手端饭碗，哗哗哗，做出扒饭的动作，嘴里使劲喊：“吃饭！吃饭！”这样做果然效果明显，明海奶奶一下子就懂了，说：“吃饭啊，问我吃饭了是吧，吃过了吃过了，早吃过了！”</p>
<p>但是接电话的时候可就没有口型和动作配合了，偏偏明海奶奶还喜欢和明海爷爷抢电话。就像昨天，明海在城里打电话回来，明海爷爷接起来说：“喂，谁呀？”</p>
<p>明海说:“我是海子。”在明海村里，喊晚辈名字都喜欢在最后一个字后面加“子”，就像桌子、椅子一样。</p>
<p>明海爷爷说：“哦，海子啊……”还没等他继续说，明海奶奶在一旁看到了，急忙跑过来说：“老头子，电话哦，谁呀，问一下是谁。”然后用围裙把手上的水擦擦，直接就夺过来。“来，我来！”</p>
<p>明海爷爷也不跟她抢，他对明海说：“给你奶奶了。”</p>
<p>明海奶奶拿过电话，将话筒郑重的贴在脸上，身子靠着床头，大声喊道：“喂，谁呀？你是谁呀？”</p>
<p>明海说：“我是海子！”</p>
<p>明海奶奶说：“谁呀，是不是海子？”</p>
<p>“是的，我是海子！”</p>
<p>“不是啊？你是哪个？是铃子吗”</p>
<p>“不是，我是海子！”</p>
<p>明海爷爷在一边一直使劲地说：“是海子！是海子呀！”</p>
<p>明海奶奶转过头看着明海爷爷：“谁呀？你说谁呀？是不是铃子，是铃子吧？”然后就对着听筒喊：“铃子啊，什么事啊？”</p>
<p>明海大声喊：“我是海子！海子！”明海爷爷也大声喊：“是海子！海子！”</p>
<p>“哦，是东子啊！”</p>
<p>就这样，爷孙俩一个在电话这边，一个在电话那边，同时喊海子喊了有两分钟，直到明海奶奶快把家里亲戚都猜完了，她自己都不耐烦了，然后把电话扔给明海爷爷。</p>
<p>“呐，老头子，给你接吧。”</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>明海爷爷到楼上很快搬来装着面粉的大木盆。</p>
<p>明海将柴抱到墙边的柴堆上摆整齐，然后去厨屋帮忙。</p>
<p>明海奶奶把水和面粉和在一起，边揉边嘟囔：“这老头子怎么不管事，面粉在哪都不知道！”明海将饼心从锅里盛起来装到盘子里，看了看爷爷，笑了笑，不说话。</p>
<p>明海爷爷在旁边摇摇头，叹一口气：“你奶奶耳朵聋，又有心脏病，高血压，她一生都性子强，不让着她怎么行呢……”</p>
<p>明海奶奶很快就把面团和好，笑眯眯的对明海说：“奶奶做糙面饼给你吃，中午吃糙面饼可好？”明海使劲的点头，这句话她上午已经说了五遍了，奶奶年纪越大越喜欢把一件小事不断的重复。</p>
<p>“家里做的饼可不像外面卖得，好吃哩！”明海奶奶又说。她从面团中拽出一小块来，伸出手指扒了一个口，用勺子舀了两勺饼心，然后把缺口合上，在手心里拍成一个圆状，啪啪两下，一个糙面饼就做好了。</p>
<p>饼下了锅，明海爷爷坐在锅台下往锅洞里添柴火。几根树枝塞进去，锅洞里烧的兴旺，噼里啪啦，火光映了出来。明海看见爷爷脸上红彤彤的一片，影子摇曳着。烟囱鼓鼓的往外冒。</p>
<p>十二点多，三个人把饭菜摆好，吃中饭了。</p>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>中饭后，明海爷爷和明海奶奶都闲下来了。冬天的庄稼地里没有活儿，明海奶奶端了个火盆，把手缩进围裙下面，靠在躺椅子上晒太阳。</p>
<p>明海爷爷双手蜷缩拢在袖子里，驼着背在院子里转悠，走到院门口时，时不时伸个头朝门外瞟。</p>
<p>明海奶奶看了一会，说：“老头子，别转了，你去玩吧！”</p>
<p>明海爷爷转过头，看着明海奶奶。</p>
<p>“下午也没事，去玩一会儿吧！”</p>
<p>明海爷爷朝门外又看了一眼，转过身，摇着头，说：“麻将有什么好玩的，不去哦。”</p>
<p>明海奶奶看到他摇头，笑着说：“不玩啊？”</p>
<p>“不玩。”</p>
<p>“不去啊？”</p>
<p>“不去。”</p>
<p>“那你干什么？”</p>
<p>“看电视！”</p>
<p>明海爷爷走到屋里，把电视打开。</p>
<p>没一会儿明海奶奶喊明海搬着躺椅也进来了。明海奶奶躺到上面，轻轻摇晃，“吱呀”——“吱呀”——，电视里老旦托着袖子咿呀呀唱着黄梅戏。</p>
<p>明海爷爷在床尾坐着，盯着屏幕看的认真。</p>
<p>明海奶奶说话了：“坐的这么近，眼睛不要了！”</p>
<p>明海爷爷就从床尾站起来，往后退几步，到床边靠着。</p>
<p>“再往后一点！”</p>
<p>明海爷爷就往后退一点。</p>
<p>“再往后一点！”</p>
<p>明海爷爷就又退了一点。</p>
<p>外面阳光照进来。</p>
<p>明海奶奶把明海爷爷的大棉袄裹的紧了一点，只露出了瘦小的脸庞，看着电视，不一会儿传来轻微的鼾声。明海爷爷半边屁股靠在床沿上，看戏看的入了神。</p>
<p>明海搬了个椅子坐在院子里，鸡群咯咯的叫。堂屋的座钟“铛……铛……铛……”地响了三声。</p>
<p>起风了。</p>
<br/>

<p><font color="#999999">——写于2015年1月29日 大学</font></p>
]]></content>
      <categories>
        <category>写作</category>
      </categories>
      <tags>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title>html5中播放rtsp流实现监控、直播等方案</title>
    <url>/2020/html5%E4%B8%AD%E6%92%AD%E6%94%BErtsp%E6%B5%81%E5%AE%9E%E7%8E%B0%E7%9B%91%E6%8E%A7%E3%80%81%E7%9B%B4%E6%92%AD%E7%AD%89%E6%96%B9%E6%A1%88.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><p>工作需求：<strong>在浏览器网页上播放建筑工地摄像头监控的画面，如工地出入口通道画面、塔吊可视化，并且可兼容不同型号的摄像头设备</strong>。</p>
<p>由于摄像头大多都是通过 RTSP 协议传输视频流的，而HTML 并不标准支持 RTSP 流，经过网上各种查资料并一番讨论后初步拟定如下方案，<code>node + ffmpeg + websocket + flv.js</code>：</p>
<ol>
<li>在node服务中建立websocket</li>
<li>通过fluent-ffmpeg转码，将RTSP 流转为flv格式</li>
<li>前端通过flv.js连接websocket，并对获取的flv格式视频数据进行渲染播放</li>
</ol>
<p>思路非常清晰，下面开始实践。</p>
<h3 id="一、node服务搭建"><a href="#一、node服务搭建" class="headerlink" title="一、node服务搭建"></a>一、node服务搭建</h3><p>首先是新建一个项目，配置基础的webpack和babel，并安装websocket相关的两个库 <code>ws</code>、<code>websocket-stream</code>。</p>
<p>然后新建一个index.js文件，搭建websocket服务：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> WebSocket <span class="keyword">from</span> <span class="string">&#x27;ws&#x27;</span></span><br><span class="line"><span class="keyword">import</span> webSocketStream <span class="keyword">from</span> <span class="string">&#x27;websocket-stream/stream&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立WebSocket服务</span></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">8888</span>, <span class="attr">perMessageDeflate</span>: <span class="literal">false</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接</span></span><br><span class="line">wss.on(<span class="string">&#x27;connection&#x27;</span>, handleConnection)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接时触发事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleConnection</span> (<span class="params">ws, req</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;一个客户端连接进来啦&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此，一个简单的websocket服务就搭建好了，可以通过配置脚本运行该文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;nodemon --exec babel-node index.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行 <code>npm run start</code>即可启动websocket服务，端口是8888。可在前端通过websocket连接该地址，测试是否连接成功。</p>
<h3 id="二、ffmpeg转码"><a href="#二、ffmpeg转码" class="headerlink" title="二、ffmpeg转码"></a>二、ffmpeg转码</h3><p>接下来就是重点了，通过npm安装<code>fluent-ffmpeg</code>。</p>
<blockquote>
<p>注意，在安装fluent-ffmpeg之前，需要确认你的服务器环境中是否安装了<strong>ffmpeg</strong>这个工具，因为转码的核心其实就是通过 <strong>ffmpeg命令</strong> 转码，需要你通过在命令行里输入 <code>ffmpeg</code>  来确认安装。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glu89iqm70j31iw09mgt2.jpg" alt="image-20201220125133824"></p>
<p>不同的系统安装方法可查阅ffmpeg官网，最终只要确认环境变量里有ffmpeg就好了。这样就可以通过ffmpeg命令来对视频进行各种转码、编码操作。</p>
<p>而<code>fluent-ffmpeg</code>这个库类似语法糖，本质上就是通过nodejs在终端中执行ffmpeg的命令，它将繁琐的ffmpeg命令进行封装，转化成易于理解的链式调用，让我们不需要花费太多的时间去了解ffmpeg命令中琐碎的细节，只需通过封装好的一些显而易见的方法就可以操作视频转码。</p>
</blockquote>
<p>好了，直接上代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> WebSocket <span class="keyword">from</span> <span class="string">&#x27;ws&#x27;</span></span><br><span class="line"><span class="keyword">import</span> webSocketStream <span class="keyword">from</span> <span class="string">&#x27;websocket-stream/stream&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ffmpeg <span class="keyword">from</span> <span class="string">&#x27;fluent-ffmpeg&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立WebSocket服务</span></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">8888</span>, <span class="attr">perMessageDeflate</span>: <span class="literal">false</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听连接</span></span><br><span class="line">wss.on(<span class="string">&#x27;connection&#x27;</span>, handleConnection)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接时触发事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleConnection</span> (<span class="params">ws, req</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取前端请求的流地址（前端websocket连接时后面带上流地址）</span></span><br><span class="line">  <span class="keyword">const</span> url = req.url.slice(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 传入连接的ws客户端 实例化一个流</span></span><br><span class="line">  <span class="keyword">const</span> stream = webSocketStream(ws, &#123; <span class="attr">binary</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  <span class="comment">// 通过ffmpeg命令 对实时流进行格式转换 输出flv格式</span></span><br><span class="line">  <span class="keyword">const</span> ffmpegCommand = ffmpeg(url)</span><br><span class="line">    .addInputOption(<span class="string">&#x27;-analyzeduration&#x27;</span>, <span class="string">&#x27;100000&#x27;</span>, <span class="string">&#x27;-max_delay&#x27;</span>, <span class="string">&#x27;1000000&#x27;</span>)</span><br><span class="line">    .on(<span class="string">&#x27;start&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Stream started.&#x27;</span>) &#125;)</span><br><span class="line">    .on(<span class="string">&#x27;codecData&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;Stream codecData.&#x27;</span>) &#125;)</span><br><span class="line">    .on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;An error occured: &#x27;</span>, err.message)</span><br><span class="line">      stream.end()</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Stream end!&#x27;</span>)</span><br><span class="line">      stream.end()</span><br><span class="line">    &#125;)</span><br><span class="line">    .outputFormat(<span class="string">&#x27;flv&#x27;</span>).videoCodec(<span class="string">&#x27;copy&#x27;</span>).noAudio()</span><br><span class="line"></span><br><span class="line">  stream.on(<span class="string">&#x27;close&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ffmpegCommand.kill(<span class="string">&#x27;SIGKILL&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行命令 传输到实例流中返回给客户端</span></span><br><span class="line">    ffmpegCommand.pipe(stream)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，简单的websocket和流转码服务就搭建好了，运行起来。如果后续投入生产环境时，也可以通过docker进行服务端部署，开机自运行。</p>
<h3 id="三、前端flv-js获取视频数据并渲染"><a href="#三、前端flv-js获取视频数据并渲染" class="headerlink" title="三、前端flv.js获取视频数据并渲染"></a>三、前端flv.js获取视频数据并渲染</h3><p>服务端搭建完，接下来就等前端连接服务器上的websocket，获取转码后的flv格式数据，然后渲染出来就行了。我们通过flv.js这个库来便捷的实现它。</p>
<blockquote>
<p>flv.js 是B站开源的一款纯js编写的HTML5 Flash Video（FLV）播放器，完全不需要Flash。</p>
<p>简单的说就是一款可以利用html5的video标签对flv格式数据进行实时播放的js版播放器。</p>
<p>原理大概就是获取到FLV格式的音视频数据后将 FLV 文件流转码复用成 ISO BMFF（MP4 碎片）片段，再通过Media Source Extensions API 传递给原生HTML5 Video标签进行播放。</p>
<p>所以从兼容性上说，支持Media Source Extensions的浏览器都是兼容flv.js的。而主流浏览器都是支持的，所以flv.js的兼容性是很不错的。</p>
</blockquote>
<p>安装flv.js，在vue中使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;wrap&quot;&gt;</span><br><span class="line">    &lt;video class&#x3D;&quot;video&quot; muted autoplay controls ref&#x3D;&quot;player&quot;&gt;&lt;&#x2F;video&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import flvjs from &#39;flv.js&#39; &#x2F;&#x2F; 引入flvjs</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      player: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果浏览器支持flvjs，则执行相应的程序</span><br><span class="line">    if (flvjs.isSupported()) &#123;</span><br><span class="line">      &#x2F;&#x2F; 准备监控设备流地址</span><br><span class="line">      const url &#x3D; &#39;rtsp:&#x2F;&#x2F;admin:1234567@192.168.1.100:554&#x2F;Streaming&#x2F;Channels&#x2F;101?transportmode&#x3D;unicast&#39;</span><br><span class="line">      &#x2F;&#x2F; 创建一个flvjs实例</span><br><span class="line">      &#x2F;&#x2F; 下面的ws:&#x2F;&#x2F;localhost:8888换成你搭建的websocket服务地址，后面加上设备流地址</span><br><span class="line">      this.player &#x3D; flvjs.createPlayer(&#123;</span><br><span class="line">        type: &#39;flv&#39;,</span><br><span class="line">        isLive: true,</span><br><span class="line">        url: &#39;ws:&#x2F;&#x2F;localhost:8888&#x2F;&#39; + url</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">      this.player.on(&#39;error&#39;, (e) &#x3D;&gt; &#123;</span><br><span class="line">        console.log(e)</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">     &#x2F;&#x2F; 将实例挂载到video元素上面</span><br><span class="line">      this.player.attachMediaElement(this.$refs.player)</span><br><span class="line">      </span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F; 开始运行加载 只要流地址正常 就可以在h5页面中播放出画面了</span><br><span class="line">        this.player.load()</span><br><span class="line">        this.player.play()</span><br><span class="line">      &#125; catch (error) &#123;</span><br><span class="line">        console.log(error)</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy () &#123;</span><br><span class="line">    &#x2F;&#x2F; 页面销毁前 关闭flvjs</span><br><span class="line">    this.player.destroy()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;</span><br><span class="line">  .wrap&#123;</span><br><span class="line">    .video &#123;</span><br><span class="line">      width: 300px;</span><br><span class="line">      height: 300px;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>以上基本上实现了业务功能需求，运用到生产环境时，可进一步完善代码细节，测试各种异常情况，增加代码健壮性。</p>
<p>如果需要同时打开多个监控或直播画面，前端多实例化几个flvjs，挂载到video元素上即可。demo效果如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glv87mbthtj31fb0u07wh.jpg" alt="image-20201221093518005"></p>
<h3 id="四、方案总结"><a href="#四、方案总结" class="headerlink" title="四、方案总结"></a>四、方案总结</h3><p>这套方案主要的核心思路就是搭建服务端websocket服务并转码，客户端通过flv.js连接websocket并渲染画面。</p>
<p>优点有：</p>
<ol>
<li>不需要flash</li>
<li>可部署在本地环境中</li>
<li>兼容性良好</li>
<li>延迟较低，没有卡顿和花屏，CPU 占用率也不高</li>
<li>服务端和客户端全部js实现，适合大前端路线的开发者来实践</li>
</ol>
<p>以上就是在html5中播放rtsp流的一个方案，可实现监控、直播、播放视频等业务。</p>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>业务实践</tag>
      </tags>
  </entry>
  <entry>
    <title>前言：我平淡生活的最后目击者</title>
    <url>/2020/%E5%89%8D%E8%A8%80%EF%BC%9A%E6%88%91%E5%B9%B3%E6%B7%A1%E7%94%9F%E6%B4%BB%E7%9A%84%E6%9C%80%E5%90%8E%E7%9B%AE%E5%87%BB%E8%80%85.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmcx3mbrsfj31og0qcnpe.jpg" alt="image-20210105165036090"></p>
<p>今年的大部分时间里，我一个人住在距离上班的地方仅10分钟路程的公寓里，每天会经过两个红绿灯，在第二个路口处拐弯，可以看到一排枫树，用脚步数过去，大约300多步就会到达公司楼下，然后掏出钉钉打卡。</p>
<p>所以我几乎不会迟到，因为实在太近了，以至于我可以精确的将打卡时间卡在8点59分这个节点上而游刃有余，堪称卡点狂魔。</p>
<p>生活作息也因此变得极其规律，晚上基本12点左右睡觉，早上可以睡到自然醒，然后煮点东西去洗漱，吃完早饭后带上一杯枸杞，慢悠悠的步行到公司。</p>
<p>工作任务并不算繁重，随着技术的沉淀和积累，我在处理项目问题时越来越得心应手。工作时常常会屏蔽所有消息，戴上耳机，陷入到专注开发的快乐中而无法自拔。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmcwlkt68ej315y0s2npe.jpg" alt="image-20210105163315081"></p>
<p>每天基本上就是朝九晚六，没啥娱乐活动，也懒得花费时间去社交，于是造成了一种愈发想远离人群的孤独感。</p>
<p>由于住得近，我下班后吃完晚饭通常不到8点，之后我有将近4个小时的时间可以自由安排，我可以在这段时间里选择看书、写东西、练琴、健身、敲代码、看综艺和洗澡。</p>
<p>有时候也会熬夜，比如看喜欢的节目、沉迷于代码等等，那第二天基本会被8点半的闹钟吵醒，然后赶紧起来洗漱，并顶着乱糟糟的头发一路狂奔，顺带着枸杞杯中的水一路跑一路撒。</p>
<p>每天过得就如云朵一般轻柔、平淡，像一阵风拂过。</p>
<p>风来来去去，日子也就这样过去了。</p>
<p>最近两年里，我的性格潜移默化的改变了很多。也是在这两年里，我才真心觉得自己是个大人了，从心底认可自己已不再年轻。</p>
<p>从小到大，好像都在习惯被别人照顾、被年长的照顾，当我开始想照顾别人的时候，就感觉有一种力量突然间觉醒了。</p>
<p>我开始走着无数前人走过的路，去关注柴米油盐，想拼命攒钱 ，也不再轻易就谈出发，而是理解人情世故，三思而行。</p>
<p>有些道理就在忽如一夜春风来中开了花，像是从身体血液里长出来一样鲜红。</p>
<p>去年有一段时间像着魔了一样疯狂的抢时间学习，上厕所的时候学，睡醒的时候学，走路的时候学，一直持续数月，直到有一天晚上学到头昏脑胀，恶心想吐，闭着眼躺在床上陷入长久的黑暗。</p>
<p>我那时想，与时间赛跑的夸父是不是就是这样倒下的？自嘲之后，还是爬起来继续学。</p>
<p>过程倒是谈不上辛苦，自己和自己做斗争罢了。</p>
<p>我在25岁之前都茫然不知所谓，看不到前路何在，空洞的想法多，欲望多，而脚踏实地的行动少，才能也不足，说是喜欢读书，实际并不怎么读书，性子无趣又乏味，每天就陷在无意义的琐碎小事上，如井底之蛙，安于一隅。</p>
<p>醒悟过来后，大好青春已消耗殆尽，时间一去不复返。无论后来怎样弥补，总有些遗憾是无法挽回的。</p>
<p>所以我有时候会想，如果以前换一种选择，是不是结果会不一样？</p>
<p>我尝试推演了一些结局，但最终发现，只要消除现在的记忆，无论在青春时做出哪一种选择，大概率都将殊途同归。</p>
<p>思想不变，视野不变，环境不变，何以能改变命运？</p>
<p>有些悲欢离合注定是无法避免的，我只能用付出青春的代价去试错，去一点点改变自己。</p>
<p>这两年我开始专注于对自身的投资，去学新的技术、学游泳、练琴、养花，我享受到其中源源不断的乐趣，也借此躲避现实的繁碎嘈杂，渐渐的找到了一种平衡内心的全新生活方式。</p>
<p>我开始认识到所谓的工作、金钱、虚荣……它们都只是过程而已，都是生活的一部分，最终都将成为我了解自己、认识自己、构造自己从而追寻自我安宁的养分。</p>
<p>现在我还是无法改变很多事情，但我可以选择在未来想要成为什么样的人，我清楚自己的天赋和软弱，我知道要如何一步步走到那里，我喜欢为改变所做的一切。</p>
<p>我决定着手搭建博客了。</p>
<p>我想把这几年积累的一些编程问题和笔记整理汇总一下，修建自己思维的小花园，沉淀技术。此外还准备加入日常生活的点滴成长，记录一些喜爱的小东西。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmd1jhomdjj317a0rwq7y.jpg" alt="image-20210105192415967"></p>
<p>总的来说，文字、技术、柴米油盐、冬天爱吃的橘子和夏天常吃的西瓜，这些东西大致组成了我生活的核心要素。我想把它们记录下来，在以后的某个时刻，通过这些痕迹，就可以一脚踏进时间的长河，沿河而上，追溯到此时的心情，找到隐藏在记忆桥底下真正生活状态的滚滚洪流。</p>
<p>子曰，朝闻道，夕死可矣。</p>
<p>既然有幸看到这个广阔世界的漫天星光，就想要去试试看。有些事还是想要做的，有些遗憾还是想弥补的。</p>
<p>而且，记录时我会思考，思考让我活着，这就是我的意义。</p>
<p>我是我平淡生活最后的目击者。</p>]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>我的昵称和logo诞生记</title>
    <url>/2021/%E6%88%91%E7%9A%84%E6%98%B5%E7%A7%B0%E5%92%8Clogo%E8%AF%9E%E7%94%9F%E8%AE%B0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><p>既然决定要做自己的博客，那我就要想一个昵称和logo作为标识。</p>
<p>它可以在各大平台注册账号时统一使用，也可以考虑用来以后做b站、搞公众号什么的。</p>
<p>所以这个昵称要简单好记、具有辨识度，同时能表达个人的想法，体现个性化。</p>
<p>我吃了好几个晚上的橘子，苦思冥想，取了诸如 <code>热心市民刘某</code>、<code>吃瓜者甲</code>、<code>烫烫烫的小米粥</code>、<code>打鱼的阮小六</code> 等等多个正经的好名字。</p>
<p>其中一开始拟定的是<code>吃瓜者甲</code>，连logo的设计都想好了，半个西瓜，一把勺子，一个简单的小人，体现出我立志要做一个社会闲散人士的春秋梦想。</p>
<p>后来觉得好low，越想越不满意，便果断弃了。</p>
<p>有一天看群里朋友聊天，他们提到了一个词：<strong>游刃有余</strong>。我那时候正在纠结昵称，突然觉得这个词很好，读起来很顺口、很舒服，而且它所表达的意思也是我喜欢的一种状态，淡定，从容，于是我开始对这个词下功夫。</p>
<p>一般来说，现成的成语用于昵称是不太巧妙的，所以要改一改，或音变，或形变，比如之前我看到有个网友昵称叫<code>怕瓦落地</code>，就很有趣，也很巧妙，印象深刻，所以我开始拆解变形，<code>游刃有鱼</code>、<code>游刃有渔</code>、<code>有刃有余</code>，最终定到<code>有刃有鱼</code>的时候，觉得如有一道神光入体，这个词的音好、形好、意也好，各方面都甚是巧妙。</p>
<p>于是我拟定了<code>有刃有鱼</code>这个词，后来还加入了花名<code>阮小六</code>，组成最终昵称 <strong>有刃有鱼阮小六</strong>。</p>
<p><code>阮小六</code>的想法来源于《水浒传》，梁山好汉里有三兄弟：阮小二、阮小五、阮小七，家住石碣村，皆以打渔为生，那么我就想了，既有阮小七，说明应该有七个孩子，剩下的阮小一、阮小三、阮小四和阮小六去哪了呢？</p>
<p>按照那时候的环境和习俗，我猜测其他几人或是夭折，或是平庸无奇、淡于众人也。</p>
<p>但这些已不重要，主要是我向往他们的一种平平淡淡、自由自在的生活方式，便如李煜在《渔父词》中写道：</p>
<blockquote>
<p>一棹春风一叶舟， 一纶茧缕一轻钩。</p>
<p>花满渚，酒满瓯， 万顷波中得自由。</p>
</blockquote>
<p>即如此，便借<code>阮小六</code>之名，以寄我之向往，刚好我在大学宿舍中也排行老六。</p>
<p>确定好昵称，接下来就是设计logo了。</p>
<p>我又吃了好几个晚上的橘子，苦思冥想，设计了如下草图：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmiuke0do9j31ci0u0hdt.jpg" alt="image-20210110195608471"></p>
<p>logo要包含刃、鱼、渔夫三种元素，走中国风的路子。</p>
<p>我从中筛选了两种，代表两种设计思路：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmis9t445bj31ac0ii1kx.jpg" alt="image-20210110183647105"></p>
<ol>
<li>左边的设计思路通过展示鱼、刃元素，可将船和刃融合在一起，形成有刃有鱼。</li>
<li>右边的设计思路是鱼竿下没有鱼，因为鱼藏水底，而人+倒影合在一起就是一把刃，我就是刃，以身化刃。通过鱼藏水底、以身化刃，达到有刃有鱼的意境。</li>
</ol>
<p>设计思路是有了，接下来是实践它。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmis35ludzj314b0u07wi.jpg" alt="image-20210110183019035"></p>
<p>我在双十一的时候买了个板子，本用来学板绘的，此时用来画logo却是正好。</p>
<p>初稿画出来是这个样子的，哈哈：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmisdq5pztj31cc0gsajy.jpg" alt="image-20210110184033051"></p>
<p>第一次接触板子，笔刷啥的都不太懂，在b站找的教学视频边学边画，线条丑的一批。而且渔夫身上的衣服像钢筋一样的直……妥妥的直男思维，简直不忍直视。</p>
<p>在咨询了朋友的意见之后，我又花了两个晚上进行修改，同时把下载的笔刷工具基本全都试了一遍，大致有了底，并增加设计了新的一版，然后二稿是这样的：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmisomcqd3j319k0iin53.jpg" alt="image-20210110185100710"></p>
<p>这次看起来要好很多，有点我设计之初想的那个意思了。</p>
<p>接着我又进行了第三稿的修改，加了一些的细节，还配上了样机展示：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmisqgsg47j30j208ajsz.jpg" alt="image-20210110185247734"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmit1clkdfj31c60u0npe.jpg" alt="image-20210110190314719"></p>
<p>设计到了这里，我感觉大体上算差不多了，然而理想是丰满的，<strong>现实却是残酷的</strong>，当我把第一版作为头像时，发现犯了一个致命的错误：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmiteo8nakj31060butb4.jpg" alt="image-20210110191603041"></p>
<p>因为头像的尺寸有大有小，当在比较小的情况下，几乎都看不清这是啥。</p>
<p>尤其是鱼，放小了之后就是一个小点，更不要说它身上那么细的线条了。</p>
<p>我深刻的反思了其中的问题，由于第一次设计缺乏经验，第一版算是设计了个寂寞。如果要继续修改的话，整体结构都要变，去掉字，放弃细节，鱼和刃抽象成轮廓，且画面要极简，多个元素之间尽量融合在一起。</p>
<p>相比之下，第二版要更符合logo的功能性：简洁、有轮廓感。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmitx9v1igj310c0byabz.jpg" alt="image-20210110193355535"></p>
<p>所以我决定就用这版，至于第四稿，后续可以慢慢磨，倒是也不用急。</p>
<p>我已经有了第四稿的大致想法，等板绘学的更熟练些，再来更新。</p>]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>板绘</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构&amp;算法：JS封装“栈”结构</title>
    <url>/2020/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;%E7%AE%97%E6%B3%95%EF%BC%9AJS%E5%B0%81%E8%A3%85%E2%80%9C%E6%A0%88%E2%80%9D%E7%BB%93%E6%9E%84.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近在学习数据结构和算法，虽然前端在实际业务开发中直接用到的一般不多，但学习这些能帮助我们理解一些底层知识，优化代码逻辑、提升代码质量，更重要的是对思维的锤炼，帮助我们朝着大前端的方向迈出更扎实的步伐。</p>
<p>作为一个初涉<strong>数据结构和算法</strong>的萌新，我将多看多练，尽可能的去系统的学习，并通过js来一一实现。写代码，不含糖，搞起搞起。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glppkimlzuj312g0gytdz.jpg" alt="image-20201216150239461"></p>
<h3 id="一、【数据结构】栈的介绍"><a href="#一、【数据结构】栈的介绍" class="headerlink" title="一、【数据结构】栈的介绍"></a>一、【数据结构】栈的介绍</h3><blockquote>
<p>栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。栈的特点是：先进后出LIFO(last in first out)，从栈顶放入元素的操作叫入栈，取出元素叫出栈。</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glze434gj6j30xs0fi0x3.jpg" alt="image-20201225000135502"></p>
<h3 id="二、JS封装实现一个栈"><a href="#二、JS封装实现一个栈" class="headerlink" title="二、JS封装实现一个栈"></a>二、JS封装实现一个栈</h3><p>js本身提供了数组相关操作的方法，十分方便灵活，那么我们便基于数组来封装一个类，实现简单的栈结构及相关操作。</p>
<p>思路：</p>
<ul>
<li>创建一个类，在构造实例时创建一个数组类型的变量，来存放相关操作数据</li>
<li>类中提供一些栈相关操作方法和属性</li>
<li>实例化并测试操作</li>
</ul>
<p>封装如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装一个栈类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.data = [] <span class="comment">// 存放栈数据的变量</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过length属性 获取栈的长度</span></span><br><span class="line">  get length () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.data.length</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过isEmpty属性 判断是否空栈</span></span><br><span class="line">  get isEmpty () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.data.length === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 压栈</span></span><br><span class="line">  push (item) &#123;</span><br><span class="line">    <span class="built_in">this</span>.data.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 出栈</span></span><br><span class="line">  pop () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.data.pop()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清空栈</span></span><br><span class="line">  clear () &#123;</span><br><span class="line">    <span class="built_in">this</span>.data.length = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查看栈顶元素</span></span><br><span class="line">  peek () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.data[<span class="built_in">this</span>.data.length - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的栈结构就封装好了，接下来进行测试：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化并进行相关操作</span></span><br><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> Stack()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stack.length)  <span class="comment">// 栈长度，打印结果 0</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.isEmpty) <span class="comment">// 是否空栈 打印结果 true</span></span><br><span class="line"></span><br><span class="line">stack.push(<span class="number">1</span>) <span class="comment">// 将数字1压入栈中</span></span><br><span class="line">stack.push(<span class="number">2</span>) <span class="comment">// 将数字2压入栈中</span></span><br><span class="line">stack.push(<span class="number">3</span>) <span class="comment">// 将数字3压入栈中</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.peek()) <span class="comment">// 获取栈顶元素 打印结果 3</span></span><br><span class="line"></span><br><span class="line">stack.pop() <span class="comment">// 出栈</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.length)  <span class="comment">// 栈长度，打印结果 2</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.isEmpty) <span class="comment">// 是否空栈 打印结果 false</span></span><br><span class="line"></span><br><span class="line">stack.clear()</span><br><span class="line"><span class="built_in">console</span>.log(stack.length)  <span class="comment">// 栈长度，打印结果 0</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.isEmpty) <span class="comment">// 是否空栈 打印结果 true</span></span><br></pre></td></tr></table></figure>



<h3 id="三、栈相关经典题目解法"><a href="#三、栈相关经典题目解法" class="headerlink" title="三、栈相关经典题目解法"></a>三、栈相关经典题目解法</h3><h4 id="1、元素出栈、入栈顺序的合理性。"><a href="#1、元素出栈、入栈顺序的合理性。" class="headerlink" title="1、元素出栈、入栈顺序的合理性。"></a>1、元素出栈、入栈顺序的合理性。</h4><p>题目：入栈顺序是1、2、3、4、5，那么出栈顺序是4、5、3、2、1是否合理？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解：是否合理先从出栈顺序入手，我们可以通过实例化一个栈结构来模拟</span></span><br><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> Stack()</span><br><span class="line"><span class="comment">// 第一个出栈是4，那么4必然在栈顶，那么根据入栈顺序，依次如下：</span></span><br><span class="line">stack.push(<span class="number">1</span>)</span><br><span class="line">stack.push(<span class="number">2</span>)</span><br><span class="line">stack.push(<span class="number">3</span>)</span><br><span class="line">stack.push(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">stack.pop() <span class="comment">// 出栈 4</span></span><br><span class="line"></span><br><span class="line">stack.push(<span class="number">5</span>)</span><br><span class="line">stack.pop() <span class="comment">// 出栈 5</span></span><br><span class="line"></span><br><span class="line">stack.pop() <span class="comment">// 出栈 3</span></span><br><span class="line">stack.pop() <span class="comment">// 出栈 2</span></span><br><span class="line">stack.pop() <span class="comment">// 出栈 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此以上出栈顺序是合理的</span></span><br></pre></td></tr></table></figure>



<h4 id="2、通过栈结构来实现进制转换"><a href="#2、通过栈结构来实现进制转换" class="headerlink" title="2、通过栈结构来实现进制转换"></a>2、通过栈结构来实现进制转换</h4><p>题目，实现十进制整数转换为二进制、八进制、十六进制。</p>
<p>分析：<strong>十进制整数转换为二进制整数采用”除2取余，逆序排列”法。具体做法是：用2整除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glzefwxlrgj30ui0e8dj2.jpg" alt="image-20201225001302901"></p>
<p>转八进制和转十六进制思路同样如此。</p>
<p>下面通过栈结构来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 十进制整数转换其他进制方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>num [Number] 十进制整数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>base [Number] 要转换的进制；可选有：2-二进制（默认）；8-八进制；16-十六进制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> decimalcConversion = <span class="function">(<span class="params">num, base = <span class="number">2</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 判断要转换的是哪个进制</span></span><br><span class="line">  <span class="keyword">const</span> baseList = [<span class="number">2</span>, <span class="number">8</span>, <span class="number">16</span>]</span><br><span class="line">  <span class="keyword">if</span> (baseList.includes(base)) &#123;</span><br><span class="line">    <span class="comment">// 创建一个栈实例</span></span><br><span class="line">    <span class="keyword">const</span> stack = <span class="keyword">new</span> Stack()</span><br><span class="line">    <span class="comment">// 向栈内压入余数</span></span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      stack.push(num % base)</span><br><span class="line">      num = <span class="built_in">Math</span>.floor(num / base)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出栈，存放到字符串中</span></span><br><span class="line">    <span class="keyword">let</span> string = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty) &#123;</span><br><span class="line">      <span class="keyword">let</span> item = stack.pop()</span><br><span class="line">      <span class="comment">// 针对16进制的处理</span></span><br><span class="line">      <span class="keyword">if</span> (item &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        item = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>][item - <span class="number">10</span>]</span><br><span class="line">      &#125;</span><br><span class="line">      string += item</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回转换后的进制字符串值</span></span><br><span class="line">    <span class="keyword">return</span> string</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;请输入正确的进制数&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">decimalcConversion(<span class="number">100</span>) <span class="comment">// 二进制 1100100</span></span><br><span class="line">decimalcConversion(<span class="number">100</span>, <span class="number">8</span>) <span class="comment">// 八进制 144</span></span><br><span class="line">decimalcConversion(<span class="number">100</span>, <span class="number">16</span>) <span class="comment">// 十六进制 64</span></span><br><span class="line">decimalcConversion(<span class="number">300</span>) <span class="comment">// 二进制 100101100</span></span><br><span class="line">decimalcConversion(<span class="number">300</span>, <span class="number">8</span>) <span class="comment">// 八进制 454</span></span><br><span class="line">decimalcConversion(<span class="number">300</span>, <span class="number">16</span>) <span class="comment">// 十六进制 12c</span></span><br></pre></td></tr></table></figure>



<h4 id="3、返回栈中元素的最小值"><a href="#3、返回栈中元素的最小值" class="headerlink" title="3、返回栈中元素的最小值"></a>3、返回栈中元素的最小值</h4><p>分析：元素入栈后，要直接从栈中寻找最小值是很困难的，因为栈结构主要就是入栈、出栈两个核心操作，因此要获取最小值，可以通过新建一个数组存放。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glzetiyujmj30ui0d6djv.jpg" alt="image-20201225002608310"></p>
<p>可以在上面封装栈的基础上继承，增加一个存放最小值的数组以及获取最小值的方法。</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承上面封装的栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> <span class="keyword">extends</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>()</span><br><span class="line">    <span class="built_in">this</span>.minData = [] <span class="comment">// 存放栈中最小值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取栈中最小元素</span></span><br><span class="line">  get minimum () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.minData[<span class="built_in">this</span>.minData.length - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重写压栈push方法</span></span><br><span class="line">  push (item) &#123;</span><br><span class="line">    <span class="keyword">let</span> min = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.data.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 第一个元素进来时</span></span><br><span class="line">      min = item</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则，对栈顶元素和压入元素进行比较，小的进minData</span></span><br><span class="line">      <span class="keyword">const</span> minimum = <span class="built_in">this</span>.minimum</span><br><span class="line">      min = item &lt;= minimum ? item : minimum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.data.push(item)</span><br><span class="line">    <span class="built_in">this</span>.minData.push(min)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 重写出栈pop方法</span></span><br><span class="line">  pop () &#123;</span><br><span class="line">    <span class="built_in">this</span>.minData.pop()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.data.pop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> MinStack()</span><br><span class="line"></span><br><span class="line">stack.push(<span class="number">2</span>)</span><br><span class="line">stack.push(<span class="number">30</span>)</span><br><span class="line">stack.push(<span class="number">1</span>)</span><br><span class="line">stack.push(<span class="number">88</span>)</span><br><span class="line"><span class="built_in">console</span>.log(stack.minimum) <span class="comment">// 1</span></span><br><span class="line">stack.pop()</span><br><span class="line">stack.pop()</span><br><span class="line"><span class="built_in">console</span>.log(stack.minimum) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>当然，上面的实现主要是基于“栈”结构的特点，提供的一种解决问题的方式，目的是为了锤炼思维的多样性和灵活性。</p>
<p>实际上由于我们是通过js的数组来模拟封装栈结构的，所以完全可以直接通过操作原始数组来获取最小值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 封装一个栈类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.data = [] <span class="comment">// 存放栈数据的变量</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取栈中最小元素</span></span><br><span class="line">  get minimum () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.min(...this.data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其他属性和方法</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了最小值以外，获取栈结构中最大值的写法也同样如此。</p>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构&amp;算法</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器探索之旅：选购和登陆</title>
    <url>/2020/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A2%E7%B4%A2%E4%B9%8B%E6%97%85%EF%BC%9A%E9%80%89%E8%B4%AD%E5%92%8C%E7%99%BB%E9%99%86.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><p>去年在阿里云上购买了第一台云服务器作为个人学习使用。在这台服务器上，我实践了linux系统操作、mysql、mongodb、docker、jenkins、node等各种好用的技能，受益匪浅。</p>
<p>可惜当时不知道 <strong>新人专享</strong> 的优惠福利，只买了1年的有效期，直到续费时看到那个费用才追悔莫及。</p>
<p>噫吁嚱，悔乎迟矣！😭</p>
<a id="more"></a>

<h2 id="一、服务器选购"><a href="#一、服务器选购" class="headerlink" title="一、服务器选购"></a>一、服务器选购</h2><p>阿里云的服务器到期之后，我开始转战腾讯云，因为我的腾讯云还没注册过，可以享受新人优惠。</p>
<p>这一次果断选了服务器3年的有效期，注册账号后，实名认证。新人第一次购买打骨折，配置是1核2G，系统环境选的是centOS 7.6。因此：</p>
<blockquote>
<p><strong>以下所有的配置都是基于centOS 7.6系统环境下</strong>的。</p>
</blockquote>
<p>服务器购买成功后，我们先进行第一次登陆。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm2i3blwp7j31wm0rw7es.jpg" alt="image-20201227163551118"></p>
<p>腾讯云的控制台里选择购买的实例，进去后<strong>重置密码</strong>，然后重启服务器。</p>
<p>因为云服务器一般均会预装好 <code>ssh</code> 服务，所以可以直接用终端连接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -p 22 root@ip</span><br></pre></td></tr></table></figure>

<p>其中root指默认管理员用户，ip则是该服务器的公网ip，因为默认ssh端口就是22，可以省略<code>-p 22</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@ip</span><br></pre></td></tr></table></figure>

<p>提示输入完密码，输完后即可登录上这台服务器啦。（上车上车）</p>
<blockquote>
<p>注：登录服务器需要使用到 <code>ssh</code> 协议，如果是 <code>Mac</code> 用户，默认的 <code>terminal</code> 终端即可支持，而 <code>Windows</code> 用户可以安装  <code>Git for Windows</code> 来进行操作。</p>
</blockquote>
<h2 id="二、开启防火墙和配置安全组"><a href="#二、开启防火墙和配置安全组" class="headerlink" title="二、开启防火墙和配置安全组"></a>二、开启防火墙和配置安全组</h2><p>新购的服务器怎么能没有防火墙呢？于是第一步就是查看防火墙的状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure>

<p>发现是Active: inactive (dead)，于是开启防火墙服务，并设置开启自启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动防火墙</span></span><br><span class="line">systemctl start firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机启动防火墙</span></span><br><span class="line">systemctl <span class="built_in">enable</span> firewalld</span><br></pre></td></tr></table></figure>

<p>再次查看状态就显示Active: <strong>active (running)</strong> 啦</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3bhsiq8vj31bi0b2thm.jpg" alt="image-20201228093310448"></p>
<p>常用的防火墙相关命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld <span class="comment"># 查看防火墙服务状态</span></span><br><span class="line">systemctl start firewalld <span class="comment"># 启动防火墙服务</span></span><br><span class="line">systemctl stop firewalld <span class="comment"># 关闭防火墙服务</span></span><br><span class="line">systemctl restart firewalld <span class="comment"># 重启防火墙服务</span></span><br><span class="line">systemctl <span class="built_in">enable</span> firewalld <span class="comment"># 开机自启防火墙服务</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld <span class="comment"># 禁止自启防火墙服务</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 防火墙新增开放一个端口号</span></span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line"><span class="comment"># 开放多个端口:</span></span><br><span class="line">firewall-cmd --zone=public --add-port=80-90/tcp --permanent</span><br><span class="line"><span class="comment"># 删除一个端口</span></span><br><span class="line">firewall-cmd --zone=public --remove-port=80/tcp --permanent</span><br><span class="line"><span class="comment"># –-zone #作用域</span></span><br><span class="line"><span class="comment"># –-add-port=80/tcp #添加端口，格式为：端口/通讯协议</span></span><br><span class="line"><span class="comment"># --remove-port=80/tcp #移除端口，格式为：端口/通讯协议</span></span><br><span class="line"><span class="comment"># –-permanent 永久生效，没有此参数重启后失效</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看防火墙相关信息，包括添加的端口</span></span><br><span class="line">firewall-cmd --list-all</span><br><span class="line"><span class="comment"># 在不改变状态的条件下重新加载防火墙（注：修改了防火墙端口后，需要重载服务）</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<p>开启了服务器内的防火墙服务，还需要在实例中配置安全组规则。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3cdptls7j31jc0u0dmd.jpg" alt="image-20201228100351348"></p>
<blockquote>
<p>安全组是一种虚拟防火墙，具备有状态的数据包过滤功能，用于设置云服务器、负载均衡、云数据库等实例的网络访问控制，控制实例级别的出入流量，是重要的网络安全隔离手段。</p>
<p>您可以通过配置安全组规则，允许或禁止安全组内的实例的出流量和入流量。</p>
</blockquote>
<p>简单的说，安全组就是在外面再加一层防火墙，只有内外“两个防火墙”的端口都开放了，那个端口才能被访问。</p>
<p>默认的安全组规则是开放所有端口，这是相对不安全的，因此我们创建一个新的安全组，只设置我们需要暴露出去的几个端口，然后将新创建的安全组绑定到服务器实例上，并取消默认安全组的绑定。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3cmz0jl9j31we0fe434.jpg" alt="image-20201228101245113"></p>
<h2 id="三、修改主机名"><a href="#三、修改主机名" class="headerlink" title="三、修改主机名"></a>三、修改主机名</h2><p>作为一个强迫症患者，进去后主机名那一连串随机字符简直不能忍，于是开启防火墙之后，第二件事就是修改主机名。</p>
<p>注：主机名最好用连续的小写字母，因为任何特殊字符或空白字符会被移除，而提供的参数中的任何大写字母会自动转化为小写。</p>
<ul>
<li><p>临时修改</p>
<p>使用命令行修改 hostname 主机名(可自定义)，如<code>hostname myHostName</code>，重新登录 shell 生效。</p>
<p>注：此命令只是暂时的修改linux的主机名,它的存活时间为linux当前的运行时间,即在下一次服务器重启前的运行时间内。</p>
</li>
<li><p>永久修改</p>
<p>如果是 CentOS 7 操作系统，可以使用命令hostnamectl set-hostname 主机名 来修改，修改完毕后重新 SHELL 登录即可。如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname myHostName</span><br></pre></td></tr></table></figure>

<p>如果是 Ubuntu 系统，则需要修改文件 /etc/hostname， 将其对应的主机名修改为新的主机名。</p>
</li>
</ul>
<p>修改完成后，再次登陆进去，即可看到主机名已修改啦。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3cw4485ej31aw052go5.jpg" alt="image-20201228102132525"></p>
<h2 id="四、修改ssh默认端口"><a href="#四、修改ssh默认端口" class="headerlink" title="四、修改ssh默认端口"></a>四、修改ssh默认端口</h2><p>ssh是安全的加密协议，默认端口是22 <code>ssh -p 22 root@ip</code> ，不写可以省略，但是默认22端口不安全，因此我们需要<strong>修改ssh默认端口</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"><span class="comment"># 注：vim是linux系统里的常用编辑器，具体文件的创建、修改、删除等操作自行查阅了解。</span></span><br></pre></td></tr></table></figure>

<p>要注意是编辑文件名为<strong>sshd_config</strong>，是指sshd服务的配置，而不是ssh_config。</p>
<p>进入到文件里后找到里面的 <strong># Port 22</strong></p>
<p>将 <strong># Port 22</strong> 前面的 # 去掉，后面22端口改成自定义端口，如: <strong>Port 10022</strong></p>
<p>建议Port 22同时保留，防止修改失误后无法远程连接服务器，修改成功后再注释去掉22。</p>
<p>保存退出vim界面，重启服务。</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3die8ew0j31cg0a8aep.jpg" alt="image-20201228104257120"></p>
<blockquote>
<p>注意：在修改ssh默认端口前，要先去设置防火墙 + 云服务器的安全组规则，开放你所设置的端口，然后再去改配置文件。</p>
<ol>
<li><p>去安全组里添加规则，添加一个10022端口，具体详见服务器提供商文档。</p>
</li>
<li><p>然后登陆云服务器，查询该端口是否被占用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --query-port=10022/tcp</span><br></pre></td></tr></table></figure>

<p>如果是no，就添加一下，成功后重载防火墙：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=10022/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>修改了ssh端口 还要告诉SElinux做了改变。也就是sshd_config文件里的这个提示：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3dse4a2bj319o0a2n1p.jpg" alt="image-20201228105233126"></p>
<blockquote>
<p>SELinux是linux系统里的一个安全模块，想要了解的可自行查阅。</p>
</blockquote>
<p>于是运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">semanage port -a -t ssh_port_t -p tcp 10022</span><br></pre></td></tr></table></figure>

<p>如果提示没有semanage命令，那么可进行如下操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找semanage是通过哪个安装包来提供的</span></span><br><span class="line">yum whatprovides semanage</span><br><span class="line"><span class="comment"># 查找完成后 运行安装</span></span><br><span class="line">yum install /*上面查出来的包名*/</span><br></pre></td></tr></table></figure>

<p>安装完成后，再次运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">semanage port -a -t ssh_port_t -p tcp 10022</span><br><span class="line"><span class="comment"># 查看是否设置成功</span></span><br><span class="line">semanage port -l | grep ssh</span><br></pre></td></tr></table></figure>

<p>最后重启服务即可修改成功，退出后用新端口重新登录。</p>
<p>然后去除上面的22端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 防火墙去除</span></span><br><span class="line">firewall-cmd --zone=public --remove-port=22/tcp --permanent</span><br><span class="line"><span class="comment"># SElinux去除</span></span><br><span class="line">semanage port -d -t ssh_port_t -p tcp 22</span><br><span class="line"><span class="comment"># 重启防火墙服务</span></span><br><span class="line">systemctl restart firewalld</span><br></pre></td></tr></table></figure>



<h2 id="五、ssh密钥登陆"><a href="#五、ssh密钥登陆" class="headerlink" title="五、ssh密钥登陆"></a>五、ssh密钥登陆</h2><p>登陆云服务器的方式其实有很多种，比如通过账号密码/密钥的<strong>命令行登陆</strong>、通过安装图形化工具进行<strong>图形化登陆</strong>、通过控制台实例里的<strong>远程连接登陆</strong>。</p>
<p>但是相对来说，最常用的还是ssh命令行登陆方式。</p>
<p>其中通过<code>ssh root@ip</code>账号/密码登陆，每次连接都要输入用户、ip和登陆密码，比较麻烦，并不适合常年都是在自己电脑上使用的场景，它更适合需要切换设备、在多个不同的地方登陆访问的场景，因此我们这里主要配置便捷的密钥登陆。</p>
<p>创建密钥主要有两种方式：</p>
<ul>
<li><p>云服务器控制台里直接创建密钥对。</p>
</li>
<li><p>自己通过ssh-keygen生成密钥对。</p>
</li>
</ul>
<p>两种方式实现效果都一样，这里介绍第一种最简单的方式创建：</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm3ec8o023j323w0l0n0y.jpg" alt="image-20201228111138356"></p>
<p>创建成功后，会自动下载密钥.pem文件到电脑上，这里将.pem私钥文件放在~/.ssh/下，修改权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 400 ~/.ssh/你的私钥文件</span><br></pre></td></tr></table></figure>

<p>接着在.ssh/里的config进行配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.ssh/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在该文件里编辑如下</span></span><br><span class="line">Host <span class="built_in">test</span>   <span class="comment"># 这里test是别名，等会你就可以直接 “ssh test” 就能登陆服务器了</span></span><br><span class="line">    HostName 121.199.57.149 <span class="comment"># 这里是你的服务器ip</span></span><br><span class="line">    Port 10022 <span class="comment"># 你的服务器ssh端口</span></span><br><span class="line">    User root <span class="comment"># 登录用户</span></span><br><span class="line">    IdentityFile ~/.ssh/ali_ecs_study.pem  <span class="comment"># 私钥地址</span></span><br></pre></td></tr></table></figure>

<p>修改成功后保存，这样服务器端就有了公钥（公钥要绑定到你的服务器实例上），客户端上就有了私钥，相当于双端互留了电话号码，接着直接连接即可登录了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>注：如果配置了密钥登陆，设置里会默认关闭密码登录。如果你要同时可以密钥登录或者密码登录，重置下实例密码即可。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>神仙资源合集</title>
    <url>/2021/%E7%A5%9E%E4%BB%99%E8%B5%84%E6%BA%90%E5%90%88%E9%9B%86.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><p>要分享的资源主要分三大类：</p>
<ol>
<li><strong>vip资源破解类</strong>：如百度文库vip资源下载、各大平台vip视频资源播放和下载。</li>
<li><strong>浏览器插件类</strong>：如跨平台音乐播放、神仙功能百宝箱。</li>
<li><strong>收藏的网站类</strong>：一些个人觉得不错的网站。</li>
</ol>
<h2 id="一、vip资源破解类"><a href="#一、vip资源破解类" class="headerlink" title="一、vip资源破解类"></a>一、vip资源破解类</h2><h3 id="1、-百度文库vip资源获取"><a href="#1、-百度文库vip资源获取" class="headerlink" title="1、 百度文库vip资源获取"></a>1、 百度文库vip资源获取</h3><p>在地址栏的baidu后面加vvv：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmht9kaa1uj31980lgwmt.jpg" alt="image-20210109222528101"></p>
<p>然后回车，自动跳转到下载页：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhtapirxwj31od0u0wxo.jpg" alt="image-20210109222640092"></p>
<p>首次可能要关注个公众号拿个验证码，拿到后就行了，word和pdf格式自选下载。</p>
<h3 id="2、vip视频资源破解"><a href="#2、vip视频资源破解" class="headerlink" title="2、vip视频资源破解"></a>2、vip视频资源破解</h3><p>在该视频链接地址 https://  后面 <strong>加上wn.run</strong>，然后回车。如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhu6jzfm0j31wk0oi17i.jpg" alt="image-20210109225717479"></p>
<p>跳转到这个页面：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhu2uv84nj31kz0u0gzf.jpg" alt="image-20210109225344123"></p>
<p>然后这个vip视频就解析出来了：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhu850zsxj31gz0u0e1z.jpg" alt="image-20210109225848799"></p>
<p>该方法同样可适用在<strong>手机浏览器</strong>上（但手机端解析效果没有pc端好，因为脚本代码大多数是为PC端写的）：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhv5yhf07j316x0u0b29.jpg" alt="image-20210109233117697"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhv6v1jv3j31qf0u0b29.jpg" alt="image-20210109233211260"></p>
<p>注：<strong>wn.run这个命令可适用于几乎任何网站，针对要解析的网站，它可能会提供视频破解、下载、翻译、网页转pdf等各种功能，相当于把许多功能的脚本进行了汇总</strong>。</p>
<p>所以这个方法也可以适用于百度文库vip资源下载：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhvfvj305j31ya0s2h0j.jpg" alt="image-20210109234050404"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhvi1w01sj318y0u0gv2.jpg" alt="image-20210109234256547"></p>
<p>综上，以后<strong>遇到任何想要破解的vip资源，不管是视频还是文档，都可以先通过加 wn.run/ 的方法去试验一下</strong>，虽然不能说100%有效，但是说不定就有效呢。</p>
<p>以上是最简单直接的资源破解方法，无复杂操作，也无需登录，只要在网址那里输几个字母即可。</p>
<p><strong>注：该方法仅供技术交流和个人使用，严禁各种商业和不法用途。同时不保证其永久稳定。如有变动，后续再关注并更新。</strong></p>
<p><font color="#ff0000"><strong>另外，该方法虽然简单直接，但在稳定性和效率上没有后面将介绍的插件破解方式好，我更推荐插件去获取vip资源。</strong></font></p>
<h2 id="二、浏览器插件类"><a href="#二、浏览器插件类" class="headerlink" title="二、浏览器插件类"></a>二、浏览器插件类</h2><h3 id="1、Listen1"><a href="#1、Listen1" class="headerlink" title="1、Listen1"></a>1、Listen1</h3><p>我在2019年的时候，有一段时间特别烦听歌要切换各大音乐平台，因为版权的缘故，经常听一首歌要去网易云、酷狗、qq音乐上找一圈，歌单也变得异常零碎。</p>
<p>我那时候就想如果能开发一款跨平台音乐播放的应用多好。</p>
<p>很显然，有这样想法的远不止我一个人，而是很多人。于是我在github上找到了这样一个开源的项目：<strong>Listen1</strong>音乐播放器。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhwe3iyh4j31wy0tk44o.jpg" alt="image-20210110001342338"></p>
<p>这个项目曾因为触动了大公司的利益，被QQ音乐举报而导致代码库临时关闭。后来经过开发团队和许多支持的人的守护而发展至今。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhwbn4rzxj31li0u0e81.jpg" alt="image-20210110001122442"></p>
<p>2019年我在使用它的时候，觉得它还有点瑕疵，并向开发团队发邮件反馈过issue。如今过了快2年时间，它经过不断的升级更新，变得愈发成熟稳定。</p>
<p>它的使用方法很简单，就跟各大音乐应用一样的的操作，下载安装后打开主界面：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhxc7fu2ej31cy0kw43h.jpg" alt="123"></p>
<p>最重要的功能是，在这里<strong>你可以创建一个歌单，这个歌单里能存放跨平台的音乐</strong>：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhxmqc8g8j323y0f60x2.jpg" alt="image-20210110005638679"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhxq3lbhvj322k0bu0w0.jpg" alt="image-20210110005952304"></p>
<p>我的歌单瞬间打破了平台壁垒，可以愉快的跨平台听歌啦：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhxtvfxusj31lg0ssgsa.jpg" alt="image-20210110010329974"></p>
<p>当前<strong>Listen1</strong>音乐播放器提供多种下载安装方式，包括<strong>windows桌面端、mac桌面端、手机安卓端、手机IOS端、浏览器插件端</strong>等等，可自行选择平台下载。</p>
<p><a href="http://listen1.github.io/listen1/">Listen1官网选择平台下载</a></p>
<h3 id="2、Tempermonkey（油猴）"><a href="#2、Tempermonkey（油猴）" class="headerlink" title="2、Tempermonkey（油猴）"></a>2、Tempermonkey（油猴）</h3><p>插件对于浏览器来说，就像给老虎插上了翅膀，瞬间让浏览器升了一个档次。</p>
<p>而在插件领域，你可以没有任何别的插件，但一定要有Tempermonkey（俗称油猴）。</p>
<p>无他，因为它是综合的用户脚本管理器，就相当于机器猫的那个口袋，里面包罗万象，什么神仙功能都有可能搞出来。</p>
<p>它经过全球各地无数开发者数年的积累，现在其官网已经有一大把的优秀的现成脚本，完全可以满足普通用户的日常应用，比如：<strong>屏蔽网页广告，网盘全速下载，免费观看腾讯、优酷、爱奇艺等各大视频网站VIP电影，免费下载酷狗、腾讯等音乐网站歌曲，免费下载文库文档，领取京东、天猫购物券，购物比价</strong>等等。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhywtsmfdj30u20u0qc8.jpg" alt="image-20210110014055843"></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhz039rwxj30ts0z4k1s.jpg" alt="image-20210110014404532"></p>
<p>总之，这个插件综合管理了一大堆的神仙功能脚本，只要你到这个广阔的空间中去搜索和选择自己想要的功能，然后一键安装启动即可。</p>
<p>通过这个插件去<strong>破解视频是最稳定、速度最快、效率最高的</strong>，并且会保持时常更新。</p>
<p><strong>安装及使用方法</strong>：</p>
<blockquote>
<p> 以360安全浏览器为例（其他国内大部分浏览器都类似，主要是找拓展程序，如果找不到可以去度娘，或者联系我）</p>
<p> <strong>1、打开浏览器</strong></p>
<p> <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmkygru637j31n60sak8i.jpg" alt="image-20210112154206220"></p>
<p> <strong>2、进入市场搜索 tampermonkey，然后安装</strong> </p>
<p> <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmkyi6cuyxj31di0kqtjd.jpg" alt="image-20210112154329841"></p>
<p> <strong>3、安装成功后，从库中获取你想要的功能脚本</strong></p>
<p> <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmkykmifcmj319i0rqdri.jpg" alt="image-20210112154550941"></p>
<p> <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmkyl2renyj31720q6qc5.jpg" alt="image-20210112154616769"></p>
<p> <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmkylmwjswj31cs0m2nfu.jpg" alt="image-20210112154648716"></p>
<p> <strong>4、寻找你需要的功能脚本并安装</strong></p>
<p> <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmkynftfh0j31820u01kx.jpg" alt="image-20210112154832407"></p>
<p> <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmkyod8osij31bg0quqn5.jpg" alt="image-20210112154926765"></p>
<p> <strong>5、使用</strong></p>
<p> <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmkz3v2ujsj31v90u016p.jpg" alt="image-20210112160419841"></p>
<p> <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmkz687a9vj31e40u0gz6.jpg" alt="image-20210112160636204"></p>
<p> <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmkz7ol6d9j31f10u0wip.jpg" alt="image-20210112160759999"></p>
</blockquote>
<p>因此，<strong>只要你用电脑端，我就建议你安装一下这个插件，一劳永逸，安装完之后你就可以享受各种爽歪歪的功能了。其中好处，懂得人都懂</strong>。</p>
<p>至于在手机端上去安装这个插件，然后躺在床上看各种vip视频，想法很好，不过目前需要指定的少数几个手机浏览器才支持拓展插件，比如yandex、Kiwi，都是国外的，你懂的，如果你愿意搞，那就执行下面这几步：</p>
<blockquote>
<p>1、有梯子，手机能上梯子。</p>
<p>2、下载kiwi浏览器，去插件市场下载油猴，安装相应的脚本。</p>
<p>3、因为大多数【油猴脚本】是针对PC端的，因此要在设置里选择“桌面版网站”，然后就能正常使用了。</p>
</blockquote>
<p>具体实现细节就不介绍了，要搭建SSR梯子等一些操作，过程略长，所以你最好找懂得人当面给你搞，123就搞定。</p>
<p>另外在电脑端，我用的是谷歌浏览器，它要安装这个插件需要<strong>科学上网</strong>，如果你用的也是谷歌，那就要介绍下面这个插件了。⬇️</p>
<h3 id="3、集装箱"><a href="#3、集装箱" class="headerlink" title="3、集装箱"></a>3、集装箱</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhz3xavw7j319s0u0qeh.jpg" alt="image-20210110014745528"></p>
<p>集装箱这个插件想要做的其实和上面的油猴类似，也是一个插件管理一大堆的服务，目前它提供快捷跳转、搜索、生成二维码等功能的右键菜单，当然这不是重点。重点是它提供的<strong>代理功能</strong>。</p>
<p>也就是通过安装它可以实现部分<strong>科学上网</strong>，然后可以访问谷歌相关应用，比如谷歌搜索，谷歌翻译，打开谷歌网上商店等等。</p>
<blockquote>
<p> <a href="https://www.yuque.com/newday-me/doc/roppru">查看集装箱插件安装方式</a></p>
<p> 注：该安装方式介绍中，如果你还无法科学上网，推荐文件安装方式，选择你想要安装的浏览器，然后根据上面的安装介绍，下载最新crx插件文件，拖动安装。</p>
</blockquote>
<p>安装完集装箱后，在浏览器中选择启动接管浏览器代理：</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmhzj2ty91j30y40hsacl.jpg" alt="image-20210110020219933"></p>
<p>于是便可以愉快的（部分）科学上网了。</p>
<p>从浏览器拓展程序中打开谷歌网上商店，然后去下载安装油猴吧。</p>
<h2 id="三、收藏的网站类"><a href="#三、收藏的网站类" class="headerlink" title="三、收藏的网站类"></a>三、收藏的网站类</h2><p>1、最大资源网：<a href="http://www.zuidazy4.com/">http://www.zuidazy4.com</a> </p>
<p>   天空资源网：<a href="http://www.tiankongzy.com/">http://www.tiankongzy.com</a></p>
<blockquote>
<p>注：微信端无法打开，要在浏览器中打开。</p>
<p>如果上面介绍的<code>wn.run/</code> 命令方法获取vip资源失效了，可到这里来尝试搜索，这里面的新的视频资源很多，且很多平台的vip视频都能搜到，可以观看和下载。</p>
</blockquote>
<p>2、今日热榜：<a href="https://tophub.today/">https://tophub.today/</a></p>
<blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmi014939aj31xu0u0tot.jpg" alt="image-20210110021939706"></p>
<p>综合了各行各业最热门的消息，不仅包括各大主流媒体的消息，也包括你所在的行业内最热门消息。可以紧跟时事，睁眼看世界。</p>
</blockquote>
<p>3、全历史：<a href="https://www.allhistory.com/">https://www.allhistory.com/</a></p>
<blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmi061ihslj31ns0u0hdu.jpg" alt="image-20210110022423594"></p>
<p>国家历史时间轴、关系图谱、时间地图、画作、古籍全都可以查，逻辑设计的很惊艳，比如你要查秦始皇和拿破仑之间的关系，只要输入这两个人，就会通过各种联系自动建立起两人的关系图，十分有趣。可以学历史、查作品、查古籍。</p>
</blockquote>
<p>4、考拉新媒体导航：<a href="https://www.kaolamedia.com/">https://www.kaolamedia.com/</a></p>
<blockquote>
<p>做自媒体相关的人必备。</p>
</blockquote>
<p>5、好用的壁纸素材站：</p>
<p>​        <a href="https://wallhaven.cc/">https://wallhaven.cc/</a></p>
<p>​        <a href="https://wall.alphacoders.com/?lang=Chinese">https://wall.alphacoders.com/?lang=Chinese</a></p>
<p>​        <a href="https://bz.zzzmh.cn/#index">https://bz.zzzmh.cn/#index</a></p>
<blockquote>
<p>手机和电脑端都有，高清、可自选尺寸、各种快捷筛选。</p>
</blockquote>
<hr>
<p>…</p>
<p>暂时就先分享这么多吧，后续有时间再持续补充。</p>
<p>如果你有好玩的、好用的资源，也欢迎随时联系我进行交流。</p>]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title>卿本佳人，奈何从贼</title>
    <url>/2020/%E5%8D%BF%E6%9C%AC%E4%BD%B3%E4%BA%BA%EF%BC%8C%E5%A5%88%E4%BD%95%E4%BB%8E%E8%B4%BC.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><p>我姓史，名小宝，之所以叫史小宝，是因为我还有个哥哥，他叫史大宝。史家两个宝，一大一小，刚刚好。但我爹贪心不足，还想再养一个，名字都想好了，叫史多宝。</p>
<p>我爹说起这名字时把头仰起，显得洋洋得意。我娘随手拿起一根板凳腿，照我爹劈头盖脸就打：“叫你多宝！叫你多宝！”我爹抱着头吓得左闪右躲，上蹿下跳，忙喊：“不多了，不多了！别打！别打！”</p>
<a id="more"></a>

<p>其实也不怪我娘，在我家，十顿有八顿喝稀饭，特别是还有个四处惹祸的哥哥，简直操碎了她的心。村里人听到我哥的大名，无不闻风丧胆，大家都说，我哥是村中一害，堪比电视里的商纣、夏桀。其中尤以马大秃头最为痛恨。</p>
<p>马大秃头是村里的小学校长，也兼任班主任和语文老师，他这个人除了发型有点炫酷之外，还有一个显著的特点，就是爱给学生起绰号。</p>
<p>当年因为我哥的裤裆上总是破破烂烂的补丁，所以给我哥取了个史裤裆的绰号，惹恼了我哥，当天中午，我哥趁没人的时候，在他家门口挖了一个坑，往里面拉了一泡屎，用稀土和树叶掩盖上。马大秃头下午出门，一脚踩进去，脸瞬间绿到了脖子根。第二天，我哥又从他家快到学校的半路上挖了一个坑，让他扶着墙在学校门口抖了半天的腿，第三天马大秃头实在是怕了，决定不从必经之路上走，而改从小道绕，却被我哥所料定，早在一堆杂草中埋伏了兵马，在一声撕裂的惨叫后又悲壮的陷于马下。</p>
<p>想那马大秃头平时出门走路都是把双手背在后面，秃头扬的高高的，步伐何等优美，举止何等高雅，但是竟然连续三天，出门都踩到了屎，简直成了村里的一大笑柄，对于我哥更是谈之色变。</p>
<p>但我和我哥不一样，我是个乖巧懂事、聪明认真、乐善好施、仗义疏财的好孩子，虽然我今年才上小学三年级，但我已经是班里的山东及时雨、孝义黑二郎了。</p>
<p>特别是今天早上吃过早饭，有个算命瞎子经过我家门口，被我爹拉进去给我算了一卦，我当时正准备背着书包上学去，突然听到那瞎子把手一掐，黑眼珠子差点都吓回来了。</p>
<p>他大叫了一声：“哎呀！”我爹连忙问：“大师，怎么了？”他把胡子一摸，笑道：“你这二儿子不凡，正是天上的文曲星下凡啊！”我爹闻言大喜，说：“何以见得？”那瞎子把我的生辰八字一摆，说：“你看，文曲属水，北斗第四星，主科甲星，与你儿子的出生年干正好一一对应，天衣无缝啊。你这儿子以后写的文章可了不得啦！”</p>
<p>我躲在门外，听得心里直痒痒，妈的，原来我出身这么不凡，是天上的星星下凡，等会到班上一定要告诉陈三炮那个家伙，让他以后见到我都服服帖帖的。想到这，我飞一般的往学校跑。</p>
<p>陈三炮这个家伙是我的同桌，本名叫陈伟东，他家十顿有八顿都吃大米饭，养的白白胖胖的。三炮是他的绰号，正是由我们亲爱的班主任马大秃头所取。</p>
<p>那天上学的时候，陈三炮发现他的板凳坏了，坐不成了，眼看着还有一下午的课，我大手一挥，说，来，坐我这，于是分出了半个板凳给他。</p>
<p>在我们村，板凳都是学生自己从家里扛过来的，我的更是我爹亲自量了我屁股的尺寸打出的一个规范的样板，实在是没考虑到还有这么一天。陈三炮的屁股实在是太大了，我只得再退一点，把半边屁股都悬在了空中。</p>
<p>但如果仅仅这样也就算了，却不知道陈三炮中午吃了什么好东西，在上课文《在艰苦的岁月里》时，突然就开始放屁。恰恰这屁还放在马大秃头转身写字、全班沉默的间隙，不早不晚，不偏不倚，真是拿捏的恰到好处，好像生怕大家听不到似的。而且还是三响连环，璞！璞！璞！堪称屁音界之离骚，建校史来之绝唱，其气势恢宏，又如三道夺命飞镖，分别朝着三个方向疾射而出，瞬间在班级群豪间掀起了一股血雨腥风。</p>
<p>我悬着半边屁股正艰难的坐在板凳上，一时还没反应过来，只听见有三声暗响传来，屁股下的板凳被嘣的嗡嗡的作响，差点就从上面震了下来，班级里早已爆发出哄堂的笑声。</p>
<p>马大秃头转过身来，脸上笑成了一团麻花，他指着陈三炮，哈哈大笑，说：“你嘣坏了自己的凳子就算了，还去嘣人家的凳子……”同学们闻言更是笑的直拍桌子。于是，马大秃头亲自给他取了陈三炮这个绰号。</p>
<p> 我赶到了学校，刚才因为一直偷听瞎子算命过去了很长时间，上课铃已经打响，马大秃头搬着一沓方格本走上讲台，我没理他，直接跑到位子上。陈三炮在一旁说：“怎么现在才来？”</p>
<p> 我放下书包，得意洋洋的说：“等会告诉你个事。”我准备等到下课后再把这件事详细的告诉他。马大秃头在讲台开始讲课了。</p>
<p> “上次布置的作文大家总体上都写的不错，尤其是有一位同学，写的事情感人肺腑，情感真挚，写的非常好。”听到这句话，同学们都感觉虎躯一震，默默的在脑中把自己的作文代入进去，忐忑的等着老师说出自己的名字。</p>
<p>我自然也不例外。只是我瞪大眼睛在脑海中想了半天，都想不起来上个星期我的作文写的是什么玩意，只得作罢。</p>
<p>只见马大秃头把最上面一个方格本打开，笑着说：“这是我们的陈三炮同学写的作文，我读一下给大家听听。”</p>
<p>说着马大秃头摇头晃脑的，咳嗽一声，清理了下喉咙。</p>
<blockquote>
<p>“上个星期，我约了好朋友小明一起去山上玩，那天的天气十分晴朗，白云一朵朵的在天空飘，我们俩一会儿爬树，一会儿打鸟，玩的十分快乐。</p>
<p>就在这时，突然碰到了一个砍柴的老奶奶，年纪很大了，好朋友小明说：‘去别的地方玩吧。’我毅然的就拒绝了他。我走到老奶奶的身边，对她说：‘奶奶，我帮您砍柴吧！’老奶奶对我露出了高兴的笑容。</p>
<p>小明看到后十分惭愧，于是加入了我们队伍。我们砍了一下午柴，虽然很累，却觉得十分快乐。临走的时候，老奶奶问：‘小伙子，你叫什么名字啊？’我回头一笑：‘奶奶，我叫雷锋！’”</p>
</blockquote>
<p>当最后一句读完，全班鸦雀无声，片刻后爆发出雷鸣般的掌声。</p>
<p>马大秃头微笑着看着大家，满意的点了点头。这真的是一篇好文章，在大家现在大部分人还在写“我昨天去奶奶家玩，路上看到了三个狗，一个是黄的，一个是黑的，一个是灰的”的时候，陈三炮已经写帮老奶奶做好事并教育好朋友小明的故事了，特别是最后一句“老奶奶问，小伙子，你叫什么名字啊，奶奶，我叫雷锋”，这种态度谦虚、语言亲切、情感真挚的好句子简直狂甩那什么“路上看到三个狗”十八条街！</p>
<p>马大秃头很满意大家的神情，毫无保留的表扬了陈三炮，只是在最后稍微批评了一句：“三炮同学啊，虽说你的作文写得很好，但还有一点要提醒一下，打鸟是不对的。以后要注意了知道吗？”陈三炮站在位子上羞涩的点了点头。</p>
<p>我在心里的念头一下子变得翻江倒海，若是以前就还算了，但是就在早上，就在刚才，那算命的大师说我是星星下凡，写的文章必然非同凡响，我现在怎么就被陈三炮这种放屁震的板凳嗡嗡响的人压过去了呢，我觉得不能忍，实在是不能忍。</p>
<p>下课后我也没跟陈三炮公布我的真实身份。我回到家找我哥，我哥刚从镇上的高中回来了。</p>
<p>我问：“哥！我怎样才能写出好文章！”</p>
<p>我哥回来后变了很多，最明显的是他开始喜欢靠在墙上，低着头不说话，眼睛被长长的头发遮住，使我一时看不清他是不是靠在墙上睡着了。我哥头也不抬，淡淡的笑了一声，说：“小宝，你知道什么样的男人最受女生喜欢吗？”</p>
<p>我说：“什么样的呀？”</p>
<p>我哥把头一甩，露出了半截眼睛：“淡淡的微笑，淡淡的行走，还有……淡淡的忧伤！”</p>
<p>我一时愣住了，感到莫名其妙。</p>
<p>我哥长叹一口气，语重心长的说：“打个比方吧，就比如你想扣鼻屎，但你不能明目张胆的扣，要装作文雅淡定的把手指塞进鼻孔里，温柔的掏出鼻屎来，然后若无其事从容不迫的将它弹出去。”</p>
<p>我歪着脑袋想了一下：“那有时弹不掉呢？”</p>
<p>我哥说：“那就多弹几下嘛！”</p>
<p>“那跟你刚才说的什么淡淡的有什么关系？”</p>
<p>“就是告诉你做什么事都要保持淡然的态度。”</p>
<p>“哦！”我说。“那我怎样才能写出好文章？”</p>
<p> 我哥直起身来，把头又轻轻的一甩。“等我下次回来再告诉你吧。”说着双手插着兜，轻轻的走开了。</p>
<p>虽然我哥还没有跟我说怎么才能写好文章，但是我却把他弹鼻屎的理论牢记在心中，并在课堂上得到了很好的实践。每次我都趁马大秃头在黑板上写字的时候，悄悄的挖出一坨鼻屎，然后淡定的弹了出去。后来练到了指哪打哪、例无虚发的境界，江湖人送绰号：弹屎神通。</p>
<p>就这样过了一个星期后，我哥终于又回来了。我迫不及待的又追问我哥。我哥从书包里拿出一本书来，对我说：“要写好文章很简单，只要你有淡然的态度，再把这本书看完，就必然能写出不同凡响的文章来。”</p>
<p>我把书拿过来一看，上面写着两个大大的字“边城”，作者是沈从文。我说为什么是这个人，而不是鲁迅、列宁呢？</p>
<p>我哥摸着我的头，说：“小宝啊，你还小，不懂，大家都知道的人你说出去就显示不出你的学问，明白了吗？”我似懂非懂的点点头，说：“哦！”于是信心十足的阅读起来。</p>
<p>终于，我花了十几分钟，把这本书从头到尾看完了，看完之后，自觉功力大增。</p>
<p>特别是《边城》里的最后一句，“那个人也许永远不会回来了，也许明天回来”那种似懂非懂，莫名其妙的感觉简直狂甩“奶奶，我叫雷锋”十九条街。我想，这么好的一句话一定要用到作文里，那用到谁身上呢？对，这么好的句子一定要用到马大秃头身上，他看到自己被用了这么好的句子，一定会十分开心。</p>
<p>我倍感兴奋，开始迫不及待的翻开方格本，在第一行写上题目：我的老师。</p>
<p>接着我写道：</p>
<blockquote>
<p>“我有一个老师，他叫马老师，是我的好朋友马小福的爸爸。他不仅是老师，还是我们小学的校长，十分的厉害。</p>
<p>他是一个很慈祥的老师，每次上课都会亲切的看着我，十分的关心我。马老师不仅关心我，也关心我的同桌陈三炮，我们俩都十分的热爱他。</p>
<p>前几天马老师还跟大家说要去镇上面给大家买本子，我们听到了都十分开心。马老师去镇上买本子的这几天，大家都很怀念。不知道他什么时候回来呢？我想，那个人也许明天回来，也许永远也回不来了。”</p>
</blockquote>
<p>写到最后一句的时候，为了表示我不是照抄的，所以特意把前后调换了一下位置，还改了几个字，一下子就显示出了我的急才。</p>
<p>写完之后我感到十分满意，觉得我和沈从文的文采简直融为了一体，于是我把封面的姓名一栏用橡皮擦掉，给自己改了个名字，写上了“史从文”三个字。</p>
<p>第二天，我满怀期待的等着马大秃头在班上念我的作文。只见他面无表情的走进教室，瞟了我一眼，说：“史从文站起来！”我立马站起来：“到！”马大秃头看着我，冷笑一声，说：“史从文，倒是好名字，跟你哥一比，你真算是从良了。我看你不如就叫史从良吧。”</p>
<p>我们班上很多人还没能明白从良这种文雅的词是什么意思，但是看到马大秃头嘲讽的笑容，顿感是个好词，是个有意义的词，是比陈三炮更有炮轰力的词。一下课都跑过来喊，从良啊，走，一起上厕所去，从良啊，放学去掏鸟窝啊，从良啊，明天打方宝啊……仿佛不喊上那么几口就不配做我的同学似的。</p>
<p>陈三炮觉得自己的名头被抢了，在一旁嘟囔着说：“切，不就从良嘛，你从良了你就了不起啊。”</p>
<p>我本来还在暗恼马大秃头给我取得名字，听到陈三炮的话，一口气涌上来，把胸膛拍的震天响：“老子从良了就是了不起，不服单挑啊！”陈三炮一拍桌子，大怒：“单挑就单挑，谁怕谁啊！”</p>
<p> 于是我们约定，今天下午两点钟，在学校外的土场上进行生死决斗。</p>
<p>回到了家后，我渐渐冷静下来，陈三炮的身体肥大，力气强硬，我绝不是他的对手，但是战书都下了，再反悔了这口气我也咽不下，而且这还是关乎着我绰号的名誉而战，绝不能退缩，这一战一定要赢。我得想个办法。</p>
<p>我托着下巴开始想，想了好久却都想不到什么好办法，就在这时我猛然想到了我哥当年挖坑的主意……</p>
<p>中午，我草草的吃完了饭，趁着陈三炮还没来，在教室不远处的杏树林边一颗大槐树下，迅速的挖了一个坑，我憋了半天憋出一泡屎，然后盖上一层杏叶。为了防止到时候自己认错，我还特意搬来了一块巴掌大的石头放在坑边作为标记。</p>
<p> 终于一切准备妥当后，快两点了，我到土场上等陈三炮到来。不一会儿，他就出现了。我俩站在土场的两端，彼此对视，一动不动。</p>
<p>陈三炮说：“来吧！”我说：“行，不过我们不在这里打，不然等会要被同学们看到，我们去那边的杏树林里打。”一指杏树林。陈三炮说：“好！走。”于是我们俩肩并着肩朝那片树林走去。</p>
<p>到了林里，我俩对视一眼，陈三炮大喝一声，使出一招黑虎掏心，大喊：“降龙十八掌！”我二话不说，直接就往大槐树那跑。但是没想到跑的太急，一下子被树棍绊到了地上，眼看着陈三炮就冲了过来，我一咬牙，在地上滚了一圈站起来，抓住旁边一棵大树就爬了上去。</p>
<p>陈三炮跑到树下喊：“你下来。”</p>
<p>我说：“你上来。”</p>
<p>“你下来。”</p>
<p>“你上来。”</p>
<p> 没想到陈三炮还真的就要上来。</p>
<p>他伸开他肥胖的身体环抱着树干，双脚一蹬，就要往上爬。爬了一半时，不料“撕拉”一声，从腿跟到后腰的布料一下子被划破，露出了两瓣肥嘟嘟的大白屁股。</p>
<p>陈三炮脸色煞白，头使劲的朝屁股后面看，哭丧着脸，声音绝望：“等会还要上课啊……”我在树上正要下去安慰他，刚好看到远处马大秃头的儿子马小福朝这边走来。我对陈三炮说：“别急，有办法了。”说着跳下来在陈三炮耳边说了几句，然后躲到一颗大树后。</p>
<p>马小福走在路上，想着自己今天去哪里玩，是去山上掏鸟窝，还是抓泥鳅呢？这时突然听见有人喊他，忙抬头看过去，只见树林里陈三炮翘着光溜溜的屁股，手上托着几根零碎的布条，头一会儿朝屁股看，一会儿又朝自己看，顿时好奇心大起。</p>
<p>虽然想到那陈三炮和史小宝经常欺负自己，但是此刻那史小宝不在，眼前又有这么好奇的事情，怎么能不去看一下呢？</p>
<p>他慢慢的走到陈三炮跟前，还没待他看的仔细，陈三炮忽然把头从屁股后面转过来对他龇牙一笑。</p>
<p>马小福这辈子还没看到过如此风骚的一笑，狡黠、期盼、渴望、乃至一点点的娇羞……就在他反复回味之间，我已从大树后跳了出来，瞬间把他拦腰抱住，陈三炮二话不说上前就扒他的裤子。</p>
<p>马小福哇的一声哭出来，两条腿像风火轮一样乱踢。但是他再踢也阻住不了陈三炮扒裤子的决心，不到片刻功夫，就把马小福的裤子扒了下来。</p>
<p>我放开马小福，装作恶狠狠的说：“别哭！你找个地方待一下午，我们放学就把裤子还给你。你要是敢告状，哼哼！”马小福的嘴巴反翘成了月亮，脸上泪水不停的滚。旁边陈三炮已经把马小福的裤子换好。</p>
<p> “记住，先到没人的地方待一下午，放学后我们就到这里来还你裤子！”说完，我和陈三炮勾肩搭背着往学校走。</p>
<p>回到教室，没一会儿上课铃就打响了，马大秃头拿着书上课。就像往常一样，平静的上完一篇课文之后，他把书放下，说：“我来喊几个同学上黑板听写一下刚才学的字词。”</p>
<p>我和陈三炮对视一眼，微微感到一丝不妙。</p>
<p>由于黑板很高，每次上黑板的同学都会扛着凳子站上去。眼下陈三炮穿着马小福的裤子，坐在板凳上还看不出来，但是一旦上了黑板，还站在凳子上，被马大秃头看到岂不是暴露无遗！</p>
<p>我和陈三炮使劲向下低头，就差钻到桌子底下了，马大秃头在连续喊了两个同学之后，意外的看到我们，“陈三炮！史从良！”</p>
<p>我俩抬起头，脸色大变。我倒是还好，眼看着陈三炮坐在凳子上脸胀得通红，我一看不对，大喊一声：“三炮，快跑！”</p>
<p>陈三炮就像风一样拼命向外跑，马大秃头愣了一下，看着三炮肥硕的屁股渐渐远去，忽然醒悟过来，怒喝一声：“陈三炮，给老子站住！”说着提着棍子就追了出去。</p>
<p>我赶紧顺着他们的方向追赶，没跑多远，转到了杏树林，猛地停了下来。</p>
<p>在树林边，我中午寻找的大槐树上，陈三炮正死死抱着一根树枝不敢下来，树下，马大秃头一边扶着树干使劲抖腿，一边用手颤巍巍的指着陈三炮，气的说不出话来。</p>
<p>而那个放在屎坑边做标记的石头，早已经孤零零的躺在十米开外。</p>
<p>陈三炮见我来了，生怕我没看到马大秃头脚上的屎，大喊：“从良，从良，马老师踩到屎了！马老师踩到屎了！”</p>
<p>同学们从后面纷纷涌过来，闻言都叽叽喳喳的饱含着好奇。</p>
<p>“马老师踩到屎啦？！”</p>
<p>“马老师踩到屎了呀！”</p>
<p>“马老师踩到屎了哎！”</p>
<p>马大秃头抖着腿，一个哆嗦，差点摔到地上。</p>
<p>他回过头看着这群天真无邪的同学们，仿佛看到了他们下午放学回家，在晚上吃饭的时候，一个个把这个事情告诉他们家长，然后整个村子的人都知道了，今天晚上他们将会在洗碗洗脸和上床睡觉之前保持着高度的热忱一直谈论着此事，有人说不定还会在梦里笑着醒了过来……</p>
<p>第二天，马大秃头没有来上课。第三天，还是没有来。第四天，第五天……马大秃头什么时候回来呢？</p>
<p>那个人也许明天回来，也许永远不会回来了。</p>
<br/>

<p><font color="#999999">——写于2015年3月1日 大学</font></p>
]]></content>
      <categories>
        <category>写作</category>
      </categories>
      <tags>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue知识点补缺补漏</title>
    <url>/2021/Vue%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecde62367bf34970a53576e38a8f1073~tplv-k3u1fbpfcp-zoom-1.image" alt="image-20210119141418551"></p>
<p>最近重读了一遍vue2.0文档，感触颇深。在经过大量业务实践之后，回过头再读它们，会带着全新的视角去认识和理解。</p>
<p>另外在读文档的过程中还发现了一些盲区，有的是以前读文档时没注意一略而过，有的是实际业务开发中用的很少而渐渐忘记了，重读之后，感觉豁然开朗，有一种如汤化雪、水到渠成的舒畅感。</p>
<p>于是趁着这个机会，把一些或常用、或生僻的知识点提取出来，以记之。</p>
<h3 id="1、v-bind、v-on绑定动态属性"><a href="#1、v-bind、v-on绑定动态属性" class="headerlink" title="1、v-bind、v-on绑定动态属性"></a>1、v-bind、v-on绑定动态属性</h3><p>在实际开发中，常用的是v-bind、v-on绑定参数值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但重读文档才发现属性也可以动态绑定，以前倒是一直没注意：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 动态属性的绑定 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">key</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态事件的绑定 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">event</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>思考：</strong> 仔细想想，感觉应用场景并不多，因为一般html标签的属性并不需要动态更换， 需要什么属性在开发业务的过程都能提前预知并准备好，只要更改属性绑定的值就好了。不过还是mark一下，以便在以后遇到了合适的开发场景，能提供一个很好的解决方案。</p>
<h3 id="2、prop中传入对象的所有属性"><a href="#2、prop中传入对象的所有属性" class="headerlink" title="2、prop中传入对象的所有属性"></a>2、prop中传入对象的所有属性</h3><p>在实际开发中，最常用的是传单个属性：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">:title</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>有多少属性都一个个的传，但一次性传所有属性也很好用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 组件中</span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind</span>=<span class="string">&quot;post&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// data中的值</span><br><span class="line">post: &#123;</span><br><span class="line">  id: 1,</span><br><span class="line">  title: &#x27;My Journey with Vue&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这种也就等价于：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:id</span>=<span class="string">&quot;post.id&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:title</span>=<span class="string">&quot;post.title&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>思考：</strong> 在组件上面需要传递很多属性的时候，如果一个个的传，那么组件上会显得特别臃肿，而且每一个属性绑定的动态值都要放在data里，形成getter和setter，增加额外开销，通过传入对象的所有属性就能很好的解决这个问题。此外，<strong>配合<code>$attr</code>，<code>$listeners</code>等属性使用，成为封装组件的利器</strong>。</p>
<h3 id="3、prop中类型可以自定义构造函数"><a href="#3、prop中类型可以自定义构造函数" class="headerlink" title="3、prop中类型可以自定义构造函数"></a>3、prop中类型可以自定义构造函数</h3><p>vue中组件传递数据的prop，一般使用如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">   propA: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">   &#125; 	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中type指的是传递数据的类型，可以定义原生构造函数中的8种类型之一：</p>
<p><code>String</code>、<code>Number</code>、<code>Boolean</code>、<code>Array</code>、<code>Object</code>、<code>Date</code>、<code>Function</code>、<code>Symbol</code></p>
<p>但实际上<code>type</code> 还可以是一个自定义的构造函数，如定义一个构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.firstName = firstName</span><br><span class="line">  <span class="built_in">this</span>.lastName = lastName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">props: &#123;</span><br><span class="line">    author: &#123;</span><br><span class="line">      type: Person,</span><br><span class="line">      <span class="keyword">default</span>: <span class="function">() =&gt;</span> <span class="keyword">new</span> Person(<span class="string">&#x27;Jeyson&#x27;</span>, <span class="string">&#x27;Liu&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在<code>author</code>的值不是构造函数Person的实例的时候，就会验证不通过而报错。</p>
<p><strong>思考：</strong> 在自己封装一些组件的时候，需要自定义一些专属的属性，可以通过自定义构造函数，来对传递参数进行检查验证，从而增强组件的健壮性。</p>
<h3 id="4、计算属性缓存-vs-方法的区别"><a href="#4、计算属性缓存-vs-方法的区别" class="headerlink" title="4、计算属性缓存 vs 方法的区别"></a>4、计算属性缓存 vs 方法的区别</h3><p>在实际开发中，计算属性和方法常常能达到一样的最终结果，如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 使用计算属性</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">// 使用方法</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 在组件中</span><br><span class="line">data: &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">	message: &#x27;&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">computed: &#123;</span><br><span class="line">  reversedMessage: function () &#123;</span><br><span class="line">    return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  reversedMessage: function () &#123;</span><br><span class="line">    return this.message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是它们是有区别的。</p>
<ul>
<li><strong>计算属性是基于它们的响应式依赖进行缓存的</strong>。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 <code>message</code> 还没有发生改变，多次访问 <code>reversedMessage</code> 计算属性会立即返回之前的计算结果，而不必再次执行函数。</li>
<li>方法是每当<strong>触发重新渲染时，调用方法将总会再次执行函数</strong>。</li>
</ul>
<p>另外<strong>计算属性</strong>和<strong>侦听属性</strong>的区别是：</p>
<ul>
<li>计算属性适合应用在有一些数据需要随着其它数据变动而变动时，需要计算。</li>
<li>watch需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。比如当data里某个数据变化了，需要重新像后台发送请求获取数据，或者需要重新执行某个方法，就需要用watch。</li>
</ul>
<p><strong>思考：</strong> 在实际开发的过程中，要灵活的使用着三种方式，虽然大部分情况下多种方式都能实现，但是各自都有各自优劣的地方，理解它们，扬长避短。</p>
<h3 id="5、自定义v-model"><a href="#5、自定义v-model" class="headerlink" title="5、自定义v-model"></a>5、自定义v-model</h3><p>组件上<strong>v-model默认是value和input事件</strong>，如果是单选框和复选框等<strong>自定义类型的输入，就需要用model属性</strong>改变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;base-checkbox&#x27;</span>, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    <span class="comment">// 用model属性将默认的props:value和event:input改成想要的checked和change</span></span><br><span class="line">    prop: <span class="string">&#x27;checked&#x27;</span>,</span><br><span class="line">    event: <span class="string">&#x27;change&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    checked: <span class="built_in">Boolean</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      type=&quot;checkbox&quot;</span></span><br><span class="line"><span class="string">      v-bind:checked=&quot;checked&quot;</span></span><br><span class="line"><span class="string">      v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>现在在这个组件上使用 <code>v-model</code> 的时候，就可以实现单选框、复选框等自定义双向绑定：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-checkbox</span> <span class="attr">v-model</span>=<span class="string">&quot;lovingVue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">base-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="6、禁止继承-attr来接传递的属性"><a href="#6、禁止继承-attr来接传递的属性" class="headerlink" title="6、禁止继承 + $attr来接传递的属性"></a>6、禁止继承 + $attr来接传递的属性</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">Vue.component(<span class="string">&#x27;base-input&#x27;</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>, <span class="comment">// 禁止继承</span></span><br><span class="line">  props: [<span class="string">&#x27;label&#x27;</span>, <span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;label&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;input</span></span><br><span class="line"><span class="string">        v-bind=&quot;$attrs&quot;</span></span><br><span class="line"><span class="string">        v-bind:value=&quot;value&quot;</span></span><br><span class="line"><span class="string">        v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">    &lt;/label&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// $attrs即父组件传递的额外参数</span></span><br><span class="line"><span class="comment">// 因为子组件设置了inheritAttrs: false, 所以父组件传递的额外参数不会落在根元素上</span></span><br><span class="line"><span class="comment">// 而是进入了$attrs里面，可以你让你决定这些 attribute 会被赋予哪个元素上。</span></span><br><span class="line"><span class="comment">// 注：style 和 class 属性依然还是在根元素上</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 父组件</span><br><span class="line"><span class="tag">&lt;<span class="name">base-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">&quot;username&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">required</span></span></span><br><span class="line"><span class="tag">  <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>思考：</strong> 封装组件很好用，可以接父组件传递的额外参数，尤其是针对原生元素进行封装。</p>
<h3 id="7、-native-listeners来接监听的事件"><a href="#7、-native-listeners来接监听的事件" class="headerlink" title="7、.native + $listeners来接监听的事件"></a>7、.native + $listeners来接监听的事件</h3><p>组件的根元素上直接监听一个原生事件，用 <code>.native</code> 修饰符：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span> <span class="attr">v-on:focus.native</span>=<span class="string">&quot;onFocus&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是.native只作用在子组件的根元素上，如果根元素没有这个事件，则是无效的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">  &#123;&#123; label &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:value</span>=<span class="string">&quot;value&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:input</span>=<span class="string">&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你想在父组件调用.native是作用在子组件里的某个元素上，可以使用Vue 提供了 <code>$listeners</code> 属性，它是一个对象，里面包含了作用在这个组件上的所有监听器。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  focus: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  input: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如同给子组件内指定的元素继承属性<code>$attrs</code>一样，通过<code>$listeners</code>属性就可以给指定的元素继承该事件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;base-input&#x27;</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  props: [<span class="string">&#x27;label&#x27;</span>, <span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">  computed: &#123;</span><br><span class="line">    inputListeners: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> vm = <span class="built_in">this</span></span><br><span class="line">      <span class="comment">// `Object.assign` 将所有的对象合并为一个新对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,</span><br><span class="line">        <span class="comment">// 我们从父级添加所有的监听器</span></span><br><span class="line">        <span class="built_in">this</span>.$listeners,</span><br><span class="line">        <span class="comment">// 然后我们添加自定义监听器，</span></span><br><span class="line">        <span class="comment">// 或覆写一些监听器的行为</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 这里确保组件配合 `v-model` 的工作</span></span><br><span class="line">          input: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">            vm.$emit(<span class="string">&#x27;input&#x27;</span>, event.target.value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;label&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;input</span></span><br><span class="line"><span class="string">        v-bind=&quot;$attrs&quot;</span></span><br><span class="line"><span class="string">        v-bind:value=&quot;value&quot;</span></span><br><span class="line"><span class="string">        v-on=&quot;inputListeners&quot;</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">    &lt;/label&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在子组件想要监听事件的元素上中通过v-on=”YourListenersObj”，绑定一个对象，里面是从父组件添加的监听事件，这个对象可以通过computed计算属性里面处理一些逻辑后返回（比如覆写一些监听器行为，防止被父组件添加的覆盖），拿父组件监听事件通过<code>$listeners</code>属性。如果不需要处理逻辑，则可以直接v-on=”$listeners”。</p>
<h3 id="8、-sync对prop-进行“双向绑定”"><a href="#8、-sync对prop-进行“双向绑定”" class="headerlink" title="8、.sync对prop 进行“双向绑定”"></a>8、.sync对prop 进行“双向绑定”</h3><p>在有些情况下，我们可能需要对一个 prop 进行“双向绑定”，可以通过.sync修饰符来实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件text-document中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;，</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 在需要修改props中title的值的时候，调用update:myPropName方法</span></span><br><span class="line">    handleChangeEvent () &#123;</span><br><span class="line">      <span class="built_in">this</span>.$emit(<span class="string">&#x27;update:title&#x27;</span>, <span class="string">&#x27;testTitle&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在父组件中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span> <span class="attr">:title.sync</span>=<span class="string">&quot;doc.title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>.sync</code>修饰符写法是简写，这样写实际上等价于：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:title</span>=<span class="string">&quot;doc.title&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:update:title</span>=<span class="string">&quot;doc.title = $event&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这种双向绑定的思路实际上和v-model很类似。实际上都是子组件通过$emit向上通知父组件去改动数据。</p>
<p>当我们用一个对象同时设置多个 prop 的时候，也可以将这个 <code>.sync</code> 修饰符和 <code>v-bind</code> 配合使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span> <span class="attr">v-bind.sync</span>=<span class="string">&quot;doc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样会把 <code>doc</code> 对象中的每一个 property (如 <code>title</code>) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 <code>v-on</code> 监听器。</p>
<h3 id="9、插槽基础"><a href="#9、插槽基础" class="headerlink" title="9、插槽基础"></a>9、插槽基础</h3><p><strong>#具名插槽</strong></p>
<p>有时我们需要多个插槽，通过name属性具名。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把页头放这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把主要内容放这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把页脚放这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一个不带 <code>name</code> 的 <code>slot</code> 出口会带有隐含的名字“default”。</p>
<p>在父组件使用插槽的时候通过在<code>&lt;template&gt;</code>元素上使用<code>v-slot:slotName</code>的方式（可缩写成 <code>#slotName</code>）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里面的内容在头部 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 没有指定slot名字的，默认放在default部分的slot里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 这里面的内容在底部 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 可缩写成#footer，注：如果使用缩写，后面必须有参数，如#default才行 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here&#x27;s some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意 <strong><code>v-slot</code> 只能添加在 <code>&lt;template&gt;</code>上</strong>，除非只有一个默认插槽。</p>
<p><strong>#作用域插槽</strong></p>
<p>插槽内容和子组件里的数据是各自在独立的作用域内，如果想插槽内容可以访问子组件内的数据，可以在子组件的<code>&lt;slot&gt;</code>元素上绑定该数据，如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 子组件中插槽里绑定了user属性，值为user，默认插槽内是具体数据 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 绑定在 &lt;slot&gt; 元素上的 attribute 被称为 插槽prop --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:user</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; user.lastName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在父组件中引用时，可以定义插槽prop来取子组件提供的属性值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 将包含所有 插槽prop 的对象命名为 slotProps，这个可以自定义名字 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为只有一个默认插槽，可以简洁写法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>作用域插槽的内部工作原理是将插槽内容包裹在一个拥有单个参数的函数里：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">slotProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 插槽内容</span></span><br><span class="line">  <span class="comment">// slotProps即包含所有 插槽prop 的对象,也就是形参，可以自由命名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以形参slotProps也可以通过es6来解构：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">&quot;&#123; user, detail, info: newInfo &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName + newInfo &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>另外可以实现<strong>动态插槽</strong>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:</span>[<span class="attr">dynamicSlotName</span>]&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>注：以上插槽用法是2.6.0版本后更新的，有一些ui组件或者插件还是之前废弃的写法，大致如下：</p>
<p>具名插槽使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或者直接作用在元素上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">slot</span>=<span class="string">&quot;header&quot;</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>作用域插槽：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;header&quot;</span> <span class="attr">slot-scope</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; slotProps.msg &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 或者直接作用在元素上，如果是default插槽可以简写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">slot-scope</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; slotProps.msg &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="10、插槽妙用：复用模版"><a href="#10、插槽妙用：复用模版" class="headerlink" title="10、插槽妙用：复用模版"></a>10、插槽妙用：复用模版</h3><p>例如，我们要实现一个 <code>todo-list</code> 组件，它是一个列表且包含布局和过滤逻辑：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in filteredTodos&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;todo.id&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们可以在每个li元素里面写一个同名插槽，并传递插槽prop出去，在父组件对其进行统一控制：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in filteredTodos&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;todo.id&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 每个todo里面都有一个同名插槽，并绑定了数据向外传递。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;todo&quot;</span> <span class="attr">:todo</span>=<span class="string">&quot;todo&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 后备内容 --&gt;</span></span><br><span class="line">      &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在父组件使用时为所有同名插槽定义一个不一样的 <code>&lt;template&gt;</code> 作为替代方案，并且可以从子组件获取传递过来的数据：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">todo-list</span> <span class="attr">:todos</span>=<span class="string">&quot;todos&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">todo</span>=<span class="string">&quot;&#123; todo &#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;todo.isComplete&quot;</span>&gt;</span>✓<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">todo-list</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个同名插槽的 <code>&lt;template&gt;</code> 模版将插入子组件所有同名的插槽里，并且渲染不同的数据。</p>
<p>因此，可以设置不同名字的插槽，设置不同的模版：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id + index&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;slotTitle&quot;</span> <span class="attr">:todo</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123; item.title &#125;&#125;</span><br><span class="line">     <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;slotData&quot;</span> <span class="attr">:todo</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123; item.data &#125;&#125;</span><br><span class="line">     <span class="tag">&lt;/<span class="name">slot</span>&gt;</span>         </span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 父组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">todo-list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">slotTitle</span>=<span class="string">&quot;&#123; todo &#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;todo.isComplete&quot;</span>&gt;</span>✓<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo.title &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">slotData</span>=<span class="string">&quot;&#123; todo &#125;&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo.data &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">todo-list</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="11、依赖注入provide、inject"><a href="#11、依赖注入provide、inject" class="headerlink" title="11、依赖注入provide、inject"></a>11、依赖注入provide、inject</h3><p>场景：父组件下有多个子组件，并且子组件内可能嵌套了子组件。此时多个子组件内需要访问父组件的一些数据/方法，可以尝试使用依赖注入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在父组件内，通过provide提供一些数据/方法</span></span><br><span class="line">provide: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 注：这里需要使用function ()的形式，如果使用() =&gt; 箭头函数，则this执行的不是本组件实例</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getData: <span class="built_in">this</span>.getData</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 另外如果是直接一个对象，里面的this是调用者的this，也就是子组件调用，则this是子组件</span></span><br><span class="line"><span class="comment">// 因此最好是通过function 返回一个对象</span></span><br><span class="line">provide: &#123;</span><br><span class="line">  getData () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  foo: <span class="number">123</span></span><br><span class="line">&#125;,</span><br><span class="line">  </span><br><span class="line">methods: &#123;</span><br><span class="line">  getData () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">123</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件内，通过inject注入父组件提供的数据或者方法，然后就可以在组件内访问了</span></span><br><span class="line"><span class="comment">// 所以在子组件内可以尝试更新父组件的数据，从而影响到子组件，但这样会造成读起来不容易理解</span></span><br><span class="line">inject: [<span class="string">&#x27;getData&#x27;</span>],</span><br><span class="line">methods: &#123;</span><br><span class="line">  test () &#123;</span><br><span class="line">    <span class="built_in">this</span>.getData()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在任何后代组件里，我们都可以使用 <code>inject</code> 选项来接收从父组件提供的数据/方法，实际上，可以把依赖注入看作针对父组件下任何后代组件的“大范围有效的 prop”。</p>
<p>注：使用依赖注入容易使各组件结构耦合，负面影响类似于通过$root、$parents来访问组件，所以更好的推荐是使用vuex。<code>provide</code> 和 <code>inject</code> 主要在开发高阶插件/组件库时使用。并不推荐用于普通应用程序代码中。</p>
<h3 id="12、程序化的侦听器去清理自己"><a href="#12、程序化的侦听器去清理自己" class="headerlink" title="12、程序化的侦听器去清理自己"></a>12、程序化的侦听器去清理自己</h3><p><code>$emit</code>可以派发一个事件，然后可以侦听：</p>
<ul>
<li>通过 <code>$on(eventName, eventHandler)</code> 侦听一个事件</li>
<li>通过 <code>$once(eventName, eventHandler)</code> 一次性侦听一个事件</li>
<li>通过 <code>$off(eventName, eventHandler)</code> 停止侦听一个事件</li>
</ul>
<p>你通常不会用到这些，但是当你需要在一个组件实例上手动侦听事件时，它们是派得上用场的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Pikaday 是一个第三方日期选择器的库</span></span><br><span class="line">  <span class="built_in">this</span>.picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">    field: <span class="built_in">this</span>.$refs.input,</span><br><span class="line">    format: <span class="string">&#x27;YYYY-MM-DD&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 在组件被销毁之前，也销毁这个日期选择器。</span></span><br><span class="line">beforeDestroy: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.picker.destroy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样有两个问题：</p>
<p>1、需要在组件实例data中保存这个picker，如果别的地方不需要调用，则最好不要这样保存，只在生命函数钩子里可以访问到它就好了。</p>
<p>2、创建代码和清理代码相互独立，不利于程序化的去管理。</p>
<p>所以可以通过一个程序化的侦听器解决这两个问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">    field: <span class="built_in">this</span>.$refs.input,</span><br><span class="line">    format: <span class="string">&#x27;YYYY-MM-DD&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 侦听钩子函数事件beforeDestroy，触发清理</span></span><br><span class="line">  <span class="built_in">this</span>.$once(<span class="string">&#x27;hook:beforeDestroy&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    picker.destroy()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以程序化的清理自己：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.attachDatepicker(<span class="string">&#x27;startDateInput&#x27;</span>)</span><br><span class="line">  <span class="built_in">this</span>.attachDatepicker(<span class="string">&#x27;endDateInput&#x27;</span>)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  attachDatepicker: <span class="function"><span class="keyword">function</span> (<span class="params">refName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">      field: <span class="built_in">this</span>.$refs[refName],</span><br><span class="line">      format: <span class="string">&#x27;YYYY-MM-DD&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.$once(<span class="string">&#x27;hook:beforeDestroy&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      picker.destroy()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="13、递归组件和循环引用"><a href="#13、递归组件和循环引用" class="headerlink" title="13、递归组件和循环引用"></a>13、递归组件和循环引用</h3><p><strong>#递归组件</strong></p>
<p>组件是可以在它们自己的模板中调用自身的。不过它们只能通过 <code>name</code> 选项来做这件事，稍有不慎，递归组件就可能导致无限循环：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">name: <span class="string">&#x27;stack-overflow&#x27;</span>,</span><br><span class="line">template: <span class="string">&#x27;&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>类似上述的组件将会导致“max stack size exceeded”错误，所以请确保递归调用是条件性的 (例如使用一个最终会得到 <code>false</code> 的 <code>v-if</code>)。</p>
<p><strong>#组件循环引用</strong></p>
<p>假设需要构建一个文件目录树，模板是这样的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;tree-folder&gt;组件模版 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; folder.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tree-folder-contents</span> <span class="attr">:children</span>=<span class="string">&quot;folder.children&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- &lt;tree-folder-contents&gt;组件模版 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;child in children&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tree-folder</span> <span class="attr">v-if</span>=<span class="string">&quot;child.children&quot;</span> <span class="attr">:folder</span>=<span class="string">&quot;child&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123; child.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>&lt;tree-folder&gt;组件</code>中引用了<code>&lt;tree-folder-contents&gt;组件</code>，而<code>&lt;tree-folder-contents&gt;组件</code>中又引用了<code>&lt;tree-folder&gt;组件</code>，这样就会出现问题。</p>
<p>解决的方法是：</p>
<p>1、通过 <code>Vue.component</code> 全局注册组件。</p>
<p>2、本地注册组件的时候，你可以使用 webpack 的异步 <code>import</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">components: &#123;</span><br><span class="line">  TreeFolderContents: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./tree-folder-contents.vue&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="14、X-Template另一种模板方式"><a href="#14、X-Template另一种模板方式" class="headerlink" title="14、X-Template另一种模板方式"></a>14、X-Template另一种模板方式</h3><p>另一个定义模板的方式是在一个 `` 元素中，并为其带上 <code>text/x-template</code> 的类型，然后通过一个 id 将模板引用过去。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/x-template&quot;</span> id=<span class="string">&quot;hello-world-template&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;Hello hello hello&lt;/p&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">&#x27;hello-world&#x27;</span>, &#123;</span><br><span class="line">  template: <span class="string">&#x27;#hello-world-template&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>x-template 需要<strong>定义在 Vue 所属的 DOM 元素外</strong>。</p>
<p>注：这些可以用于模板特别大的 demo 或极小型的应用，但是<strong>其它情况下请避免使用，因为这会将模板和该组件的其它定义分离开</strong>。</p>
<h3 id="15、自定义指令directive"><a href="#15、自定义指令directive" class="headerlink" title="15、自定义指令directive"></a>15、自定义指令directive</h3><p>除了vue内置的v-modal、v-show之外，可以自定义指令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个自定义指令v-focus</span></span><br><span class="line">directives: &#123;</span><br><span class="line">  focus: &#123;</span><br><span class="line">    inserted: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">      el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在需要的地方使用</span></span><br><span class="line"><span class="comment">// &lt;input v-focus&gt;</span></span><br></pre></td></tr></table></figure>

<p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p>
<ul>
<li><p><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p>
</li>
<li><p><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p>
</li>
<li><p><code>update</code>：所在组件的 VNode 更新时调用，<strong>但是可能发生在其子 VNode 更新之前</strong>。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 。</p>
</li>
<li><p><code>componentUpdated</code>：指令所在组件的 VNode <strong>及其子 VNode</strong> 全部更新后调用。</p>
</li>
<li><p><code>unbind</code>：只调用一次，指令与元素解绑时调用。</p>
</li>
</ul>
<p>钩子函数的参数，以下面这个<code>v-demo</code>为例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是模版部分</span></span><br><span class="line"><span class="comment">// &lt;div v-demo:foo.a.b=&quot;message&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是script部分</span></span><br><span class="line">directives: &#123;</span><br><span class="line">  demo: &#123;</span><br><span class="line">    bind: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding, vnode</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 处理一些事情</span></span><br><span class="line">      <span class="built_in">console</span>.log(el) <span class="comment">// 本例即div元素，指定绑定的元素</span></span><br><span class="line">      <span class="built_in">console</span>.log(binding.name) <span class="comment">// demo，不包括 v- 前缀的指令名</span></span><br><span class="line">      <span class="built_in">console</span>.log(binding.value) <span class="comment">// hello，指定的绑定值</span></span><br><span class="line">      <span class="built_in">console</span>.log(binding.expression) <span class="comment">// message，字符串形式的指令表达式</span></span><br><span class="line">      <span class="built_in">console</span>.log(binding.arg) <span class="comment">// foo，传给指令的参数</span></span><br><span class="line">      <span class="built_in">console</span>.log(binding.modifiers) <span class="comment">// &#123;a: true, b: true&#125; 一个包含修饰符的对象</span></span><br><span class="line">      <span class="built_in">console</span>.log(vnode) <span class="comment">// vue编译生成的虚拟节点</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">data () &#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		message: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>el</code>：指令所绑定的元素。</li>
<li><code>binding</code>：一个对象，包含以下 property：<ul>
<li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。上例为：</li>
<li><code>value</code>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code>。</li>
<li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li>
<li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>。</li>
<li><code>arg</code>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。</li>
<li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>&#123; foo: true, bar: true &#125;</code>。</li>
</ul>
</li>
<li><code>vnode</code>：Vue 编译生成的虚拟节点。</li>
<li><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</li>
</ul>
<blockquote>
<p>注：除了 <code>el</code> 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的<code>dataset</code>来进行。</p>
</blockquote>
<h3 id="16、自定义指令动态参数妙用"><a href="#16、自定义指令动态参数妙用" class="headerlink" title="16、自定义指令动态参数妙用"></a>16、自定义指令动态参数妙用</h3><p>在 <code>v-mydirective:[argument]=&quot;value&quot;</code> 中，<code>argument</code> 参数可以根据组件实例数据进行更新。</p>
<p>如下面这个例子把元素动态的固定在距离页面顶部（或者左侧） 200 px的位置：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;dynamicexample&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Scroll down inside this section ↓<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pin:</span>[<span class="attr">direction</span>]=<span class="string">&quot;200&quot;</span>&gt;</span>I am pinned onto the page at 200px to the left.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Vue.directive(&#x27;pin&#x27;, &#123;</span><br><span class="line">  bind: function (el, binding, vnode) &#123;</span><br><span class="line">    el.style.position = &#x27;fixed&#x27;</span><br><span class="line">    var s = (binding.arg == &#x27;left&#x27; ? &#x27;left&#x27; : &#x27;top&#x27;)</span><br><span class="line">    el.style[s] = binding.value + &#x27;px&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#dynamicexample&#x27;,</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      direction: &#x27;left&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="17、渲染函数render"><a href="#17、渲染函数render" class="headerlink" title="17、渲染函数render"></a>17、渲染函数render</h3><p>大部分情况下用模版来创建html就好了，但是在某些情况下，需要js完全编程的能力，可以用渲染函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一个js文件 render-test.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;h1&#x27;</span>, <span class="built_in">this</span>.title)</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">&#x27;标题&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在vue文件中引用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">render-test</span> <span class="attr">title</span>=<span class="string">&quot;测试标题&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">render-test</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上面这个组件渲染为 &lt;h1&gt;测试标题&lt;/h1&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> RenderTest <span class="keyword">from</span> <span class="string">&#x27;./render-test.js&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  components: &#123; RenderTest &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实际场景如：需要动态创建html标签h1-h6，里面内容通过插槽来传入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建一个js文件 render-title.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this.$slots.default是一个数组，里面包含这个元素之间的虚拟节点</span></span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;h&#x27;</span> + <span class="built_in">this</span>.level, <span class="built_in">this</span>.$slots.default)</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    level: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">1</span>,</span><br><span class="line">      required: <span class="literal">true</span>,</span><br><span class="line">      validator: <span class="function">(<span class="params">val</span>) =&gt;</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>].includes(val)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在vue文件中引用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">render-title</span> <span class="attr">:level</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 这里面的内容即为render-title组件的$slot.default中内容 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- $slot.default是虚拟节点组成的数组 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;title-icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>我是标题</span><br><span class="line">  	<span class="tag">&lt;/<span class="name">render-title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上面这个组件渲染为 &lt;h3&gt;【图标】我是标题&lt;/h3&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> RenderTitle <span class="keyword">from</span> <span class="string">&#x27;./render-title.js&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  components: &#123; RenderTitle &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>渲染函数的实现过程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">&#x27;h1&#x27;</span>, <span class="built_in">this</span>.title)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过createElement()方法返回的是虚拟dom，createElement方法中的参数如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">createElement(</span><br><span class="line">  <span class="comment">// &#123;String | Object | Function&#125;</span></span><br><span class="line">  <span class="comment">// 一个html标签名、组件选项对象，或者 resolve 了这两个中任何一种的一个 async 函数。必填项。</span></span><br><span class="line">  <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;Object&#125;</span></span><br><span class="line">  <span class="comment">// 对上述标签/组件属性的描述。可选。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&#x27;class&#x27;</span>: &#123; <span class="attr">foo</span>: <span class="literal">true</span>, <span class="attr">bar</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="comment">// (详情见vue文档中渲染函数部分)</span></span><br><span class="line">    <span class="comment">// https://cn.vuejs.org/v2/guide/render-function.html#%E6%B7%B1%E5%85%A5%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// &#123;String | Array&#125;</span></span><br><span class="line">  <span class="comment">// 子级虚拟节点，可选。</span></span><br><span class="line">  [</span><br><span class="line">    <span class="string">&#x27;先写一些文字&#x27;</span>,</span><br><span class="line">    createElement(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;一则头条&#x27;</span>),</span><br><span class="line">    createElement(MyComponent, &#123;</span><br><span class="line">      props: &#123;</span><br><span class="line">        someProp: <span class="string">&#x27;foobar&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上述内容可渲染为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;foo&quot;</span>&gt;</span></span><br><span class="line">  先写一些文字</span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>一则头条<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-component</span> <span class="attr">someProp</span>=<span class="string">&quot;foobar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里只是演示，my-component组件将渲染为html --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="18、用渲染函数重写模版功能"><a href="#18、用渲染函数重写模版功能" class="headerlink" title="18、用渲染函数重写模版功能"></a>18、用渲染函数重写模版功能</h3><ul>
<li><p>在模板中使用的 <code>v-if</code> 和 <code>v-for</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">&quot;items.length&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>No items found.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用渲染函数重写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.items.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> h(<span class="string">&#x27;ul&#x27;</span>, <span class="built_in">this</span>.items.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h(<span class="string">&#x27;li&#x27;</span>, item.name)</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> h(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;No items found.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    items: &#123;</span><br><span class="line">      type: <span class="built_in">Array</span>,</span><br><span class="line">      <span class="keyword">default</span>: [</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&#x27;one&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&#x27;two&#x27;</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用渲染函数重写v-model：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: [<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;input&#x27;</span>, &#123;</span><br><span class="line">      domProps: &#123;</span><br><span class="line">        value: self.value</span><br><span class="line">      &#125;,</span><br><span class="line">      on: &#123;</span><br><span class="line">        input: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">          self.$emit(<span class="string">&#x27;input&#x27;</span>, event.target.value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="comment">// &lt;render-input :value=&quot;message&quot; @input=&quot;message = $event&quot;&gt;&lt;/render-input&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>渲染函数中的事件&amp;修饰符</p>
<p>对于 <code>.passive</code>、<code>.capture</code> 和 <code>.once</code> 这些事件修饰符，Vue 提供了相应的前缀可以用于 <code>on</code>：</p>
<table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">前缀</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>.passive</code></td>
<td align="left"><code>&amp;</code></td>
</tr>
<tr>
<td align="left"><code>.capture</code></td>
<td align="left"><code>!</code></td>
</tr>
<tr>
<td align="left"><code>.once</code></td>
<td align="left"><code>~</code></td>
</tr>
<tr>
<td align="left"><code>.capture.once</code> 或 <code>.once.capture</code></td>
<td align="left"><code>~!</code></td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">on: &#123;</span><br><span class="line">  <span class="string">&#x27;!click&#x27;</span>: <span class="built_in">this</span>.doThisInCapturingMode,</span><br><span class="line">  <span class="string">&#x27;~keyup&#x27;</span>: <span class="built_in">this</span>.doThisOnce,</span><br><span class="line">  <span class="string">&#x27;~!mouseover&#x27;</span>: <span class="built_in">this</span>.doThisOnceInCapturingMode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于所有其它的修饰符，私有前缀都不是必须的，因为你可以在事件处理函数中使用事件方法：</p>
<table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">处理函数中的等价操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>.stop</code></td>
<td align="left"><code>event.stopPropagation()</code></td>
</tr>
<tr>
<td align="left"><code>.prevent</code></td>
<td align="left"><code>event.preventDefault()</code></td>
</tr>
<tr>
<td align="left"><code>.self</code></td>
<td align="left"><code>if (event.target !== event.currentTarget) return</code></td>
</tr>
<tr>
<td align="left">按键： <code>.enter</code>, <code>.13</code></td>
<td align="left"><code>if (event.keyCode !== 13) return</code> (对于别的按键修饰符来说，可将 <code>13</code> 改为<a href="http://keycode.info/">另一个按键码</a>)</td>
</tr>
<tr>
<td align="left">修饰键： <code>.ctrl</code>, <code>.alt</code>, <code>.shift</code>, <code>.meta</code></td>
<td align="left"><code>if (!event.ctrlKey) return</code> (将 <code>ctrlKey</code> 分别修改为 <code>altKey</code>、<code>shiftKey</code> 或者 <code>metaKey</code>)</td>
</tr>
</tbody></table>
<p>这里是一个使用所有修饰符的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">on: &#123;</span><br><span class="line">  keyup: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果触发事件的元素不是事件绑定的元素</span></span><br><span class="line">    <span class="comment">// 则返回</span></span><br><span class="line">    <span class="keyword">if</span> (event.target !== event.currentTarget) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 如果按下去的不是 enter 键或者</span></span><br><span class="line">    <span class="comment">// 没有同时按下 shift 键</span></span><br><span class="line">    <span class="comment">// 则返回</span></span><br><span class="line">    <span class="keyword">if</span> (!event.shiftKey || event.keyCode !== <span class="number">13</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 阻止 事件冒泡</span></span><br><span class="line">    event.stopPropagation()</span><br><span class="line">    <span class="comment">// 阻止该元素默认的 keyup 事件</span></span><br><span class="line">    event.preventDefault()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>渲染函数中的插槽和插槽作用域</p>
<p>使用<code>this.$slots</code>访问静态插槽的内容，每个插槽都是一个 VNode 数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// &lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;</span></span><br><span class="line">  <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, <span class="built_in">this</span>.$slots.default)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>this.$scopedSlots</code>访问作用域插槽，每个作用域插槽都是一个返回若干 VNode 的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">&#x27;message&#x27;</span>],</span><br><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// &lt;div&gt;&lt;slot :text=&quot;message&quot;&gt;&lt;/slot&gt;&lt;/div&gt;</span></span><br><span class="line">  <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, [</span><br><span class="line">    <span class="built_in">this</span>.$scopedSlots.default(&#123;</span><br><span class="line">      text: <span class="built_in">this</span>.message</span><br><span class="line">    &#125;)</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要用渲染函数向子组件中传递作用域插槽，可以利用描述节点对象中的 <code>scopedSlots</code> 字段：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// &lt;div&gt;&lt;child v-slot=&quot;props&quot;&gt;&lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt;&lt;/child&gt;&lt;/div&gt;</span></span><br><span class="line">  <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, [</span><br><span class="line">    h(<span class="string">&#x27;child&#x27;</span>, &#123;</span><br><span class="line">      scopedSclots: &#123;</span><br><span class="line">        <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> h(<span class="string">&#x27;span&#x27;</span>, props.text)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="19、JSX语法"><a href="#19、JSX语法" class="headerlink" title="19、JSX语法"></a>19、JSX语法</h3><p>写render函数通常没有写模版直观简单，所以有个babel插件用来在vue中写jsx语法，让我们更接近模版的写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> AnchoredHeading <span class="keyword">from</span> <span class="string">&#x27;./AnchoredHeading.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;AnchoredHeading level=&#123;<span class="number">1</span>&#125;&gt;</span><br><span class="line">        &lt;span&gt;Hello&lt;/span&gt; world!</span><br><span class="line">      &lt;/AnchoredHeading&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过在render函数中返回一个类似模版的写法，这种就是jsx语法。</p>
<h3 id="20、函数式组件"><a href="#20、函数式组件" class="headerlink" title="20、函数式组件"></a>20、函数式组件</h3><p>上述渲染函数可以像正常的组件一样拥有各种属性和生命周期：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// functional: true,</span></span><br><span class="line">  props: [<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      test: <span class="string">&#x27;11111&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;created&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.test)</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">h, context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注：只有上面设置了functional: true，这里context才有值，否则是undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(context)</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, <span class="string">&#x27;233333&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是<strong>如果它只是一个接受一些 prop，没有响应数据，没有实例，这样的场景下可以使用函数式组件，将组件标记为 <code>functional</code>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-component&#x27;</span>, &#123;</span><br><span class="line">  functional: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// Props 是可选的</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 为了弥补缺少的实例</span></span><br><span class="line">  <span class="comment">// 提供第二个参数作为上下文</span></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement, context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>组件需要的一切都是通过 <code>context</code> 参数传递，它是一个包括如下字段的对象：</p>
<ul>
<li><code>props</code>：提供所有 prop 的对象</li>
<li><code>children</code>：VNode 子节点的数组</li>
<li><code>slots</code>：一个函数，返回了包含所有插槽的对象</li>
<li><code>scopedSlots</code>：(2.6.0+) 一个暴露传入的作用域插槽的对象。也以函数形式暴露普通插槽。</li>
<li><code>data</code>：传递给组件的整个数据对象，作为 <code>createElement</code> 的第二个参数传入组件</li>
<li><code>parent</code>：对父组件的引用</li>
<li><code>listeners</code>：(2.3.0+) 一个包含了所有父组件为当前组件注册的事件监听器的对象。这是 <code>data.on</code> 的一个别名。</li>
<li><code>injections</code>：(2.3.0+) 如果使用了 inject选项，则该对象包含了应当被注入的 property。</li>
</ul>
<p>这种函数式组件的好处是：<strong>因为函数式组件只是函数，所以渲染开销也低很多</strong>。</p>
<h3 id="21、开发插件"><a href="#21、开发插件" class="headerlink" title="21、开发插件"></a>21、开发插件</h3><p>Vue.js 的插件应该暴露一个 <code>install</code> 方法。这个方法的第一个参数是 <code>Vue</code> 构造器，第二个参数是一个可选的选项对象。通过全局方法 <code>Vue.use()</code> 使用插件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">MyPlugin.install = <span class="function"><span class="keyword">function</span> (<span class="params">Vue, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 添加全局方法或 property</span></span><br><span class="line">  Vue.myGlobalMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 添加全局资源</span></span><br><span class="line">  Vue.directive(<span class="string">&#x27;my-directive&#x27;</span>, &#123;</span><br><span class="line">    bind (el, binding, vnode, oldVnode) &#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 注入组件选项</span></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">  Vue.prototype.$myMethod = <span class="function"><span class="keyword">function</span> (<span class="params">methodOptions</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入组件模版</span></span><br><span class="line"><span class="keyword">import</span> FullLoadingComponent <span class="keyword">from</span> <span class="string">&#x27;./FullLoading&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fullLoading = &#123;</span><br><span class="line">  install: <span class="function"><span class="params">Vue</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建组件构造器</span></span><br><span class="line">    <span class="keyword">const</span> FullLoadingConstructor = Vue.extend(FullLoadingComponent)</span><br><span class="line">    <span class="comment">// 实例化组件</span></span><br><span class="line">    <span class="keyword">const</span> instance = <span class="keyword">new</span> FullLoadingConstructor()</span><br><span class="line">    <span class="comment">// 将组件挂载到div上</span></span><br><span class="line">    instance.$mount(<span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>))</span><br><span class="line">    <span class="comment">// 将div元素放到body里</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(instance.$el)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给vue绑定全局对象$fullLoading 提供两个方法show、hide</span></span><br><span class="line">    Vue.prototype.$fullLoading = &#123;</span><br><span class="line">      show: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        instance.show()</span><br><span class="line">      &#125;,</span><br><span class="line">      hide: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        instance.hide()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> fullLoading</span><br></pre></td></tr></table></figure>

<p>调用该插件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> FullLoadingComponent <span class="keyword">from</span> <span class="string">&#x27;@/plugins/FullLoading&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(FullLoadingComponent) <span class="comment">// 这样就在Vue上绑定了 $fullLoading 提供的两个方法show、hide</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...组件选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
</search>
